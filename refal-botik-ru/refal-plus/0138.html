<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal-plus@botik.ru -- Discussing the Refal+ programming langua</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klark@bagirra.net)">
<META NAME="Subject" CONTENT="Re: Об отсечениях внутри блока">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Об отсечениях внутри блока</H1>
<HR>
<P>
<!-- received="Mon Nov 27 15:41:14 2000" -->
<!-- isoreceived="20001127124114" -->
<!-- sent="Mon, 27 Nov 2000 15:38:30 +0300" -->
<!-- isosent="20001127123830" -->
<!-- name="Arkady Klimov" -->
<!-- email="klark@bagirra.net" -->
<!-- subject="Re: Об отсечениях внутри блока" -->
<!-- id="005c01c0586f$5672c470$929943c2@swan" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.21.0011252112590.22989-100000@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Об отсечениях внутри блока<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klark@bagirra.net</EM>)<BR>
<STRONG>Date: </STRONG>Mon Nov 27 2000 - 15:38:30 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#138">[ date ]</A>
<A HREF="index.html#138">[ thread ]</A>
<A HREF="subject.html#138">[ subject ]</A>
<A HREF="author.html#138">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0137.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0135.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0135.html">Arkady Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
АРК:
<BR>
Я присоединяю к данному письму ответ на вопрос, заданный мне Андреем К. См. внизу.
<BR>
(Андрей, я почему-то не получил это твое исходное письмо.)
<BR>
<P>----- Original Message ----- 
<BR>
From: Anton Yu. Orlov &lt;orlov@mccme.ru&gt;
<BR>
To: Andrei Klimov &lt;Andrei.Klimov@supercompilers.com&gt;
<BR>
Cc: &lt;refal-plus@botik.ru&gt;; Fedor Romanenko &lt;fedor@blues.ru&gt;
<BR>
Sent: Saturday, November 25, 2000 9:16 PM
<BR>
Subject: Re: Об отсечениях внутри блока.
<BR>
<P><P>|         Здравствуйте, Андрей и Сергей!
<BR>
| 
<BR>
|     Прежде всего, хочу поблагодарить вас за замечательные ответы на мой вопрос
<BR>
| и объяснение ситуации с той семантикой, которая сейчас принята. Тем не менее,
<BR>
| мне бы не хотелось мириться с существующим положением вещей, и поэтому у меня
<BR>
| есть предложение (см. ниже).
<BR>
| 
<BR>
| Andrei Klimov wrote:
<BR>
| 
<BR>
| &gt; Антон и Сергей, добрый день!
<BR>
| &gt;
<BR>
| &gt; Большое спасибо за интереснейший пример на тонкости
<BR>
| &gt; Рефала Плюс! Жизнь такова, что сложностей нет только
<BR>
| &gt; у слабых языков, скажем, у машины Тьюринга. ;-)
<BR>
| &gt;
<BR>
| &gt; А все-таки хочется разобраться по существу:
<BR>
| &gt; Интересно, из каких соображений была выбрана такая семантика? --
<BR>
| &gt;
<BR>
| &gt;     0 |- S
<BR>
| &gt;     k |- R
<BR>
| &gt;     --------
<BR>
| &gt;     k |- S R
<BR>
| &gt;
<BR>
| &gt; Это было сделано просто ради какого-то частного упрощения или
<BR>
| &gt; возникают какие-то нетривиальные &quot;противоречия&quot;?
<BR>
| &gt;
<BR>
| &gt; Задав вопрос, сам же попытаюсь дать на него ответ.
<BR>
| &gt; Для начала обобщим пример, наставив букв, обозначающих
<BR>
| &gt; некоторые правильные фрагменты программы:
<BR>
| &gt;
<BR>
| &gt;     A \? B \{ C \! D; E}, F;
<BR>
| &gt;
<BR>
| &gt; Теперь представим операционную семантику, то есть процесс вычислений.
<BR>
| &gt; После вычисления A проходим \?. Это означает, что в стеке
<BR>
| &gt; возвратов отмечается текущее точка. После того, как
<BR>
| &gt; пройдем С и \!, стек возвратов будет сброшен до этой точки.
<BR>
| &gt; В результате, возвраты из D пойдут куда-то в A, а не в C или E.
<BR>
| &gt; Хитро, но пока все разумно: именно для таких &quot;трюков&quot;
<BR>
| &gt; и были \? и \! внесены в язык.
<BR>
| &gt;
<BR>
| &gt; А вот с F -- тонкость:
<BR>
| &gt; - куда должны идти возвраты из F: в B или сразу в A?
<BR>
| &gt;
<BR>
| &gt; Если не заглядывать в скобки (понадеявшись на
<BR>
| &gt; &quot;композиционность&quot; языка -- то есть, что вложенные конструкции
<BR>
| &gt; в разумных пределах не влияют на семантику объемлющих),
<BR>
| &gt; то наивно хочется, чтобы возвраты из F шли в B.
<BR>
| 
<BR>
|     Да, это именно так. И, кажется, есть способ этого добиться (см. ниже).
<BR>
| Сразу хочу сделать замечание о целесообразности вообще рассмотрения семантики
<BR>
| отсечений, отличной от существующей. У меня уже неоднократно возникало желание
<BR>
| использовать отсечения таким образом. Это желание (как я понимаю после
<BR>
| предыдущего прекрасного объяснения) возникало в тех случаях, когда возвраты в B
<BR>
| автоматически становятся возвратами в A (например, когда B просто отсутствует).
<BR>
| И всякий раз приходится как-то выкручиваться. Особенно неприятна в этом смысле
<BR>
| ситуация, когда хочется сделать возврат из блока, котырый инциализуриет
<BR>
| какие-нибудь переменные в последующем паттерне, после чего идет долгое
<BR>
| вычисление, использующее эти переменные. Поэтому я и задал свой вопрос
<BR>
| (невнимательно, как выяснилось, прочитав книжку ;-).
<BR>
| 
<BR>
| &gt;
<BR>
| &gt;
<BR>
| &gt; - А если мы попали в F, пройдя С \! D, то что?
<BR>
| &gt;
<BR>
| &gt;     Операционная семантика подсказывает, что
<BR>
| &gt;     стек уже сброшен до уровня, отмеченного знаком \?.
<BR>
| &gt;
<BR>
| &gt; - А если мы попали в F, сделав возврат из C на Е и выйдя
<BR>
| &gt; из скобок без отсечения возвратов, то что?
<BR>
| &gt;
<BR>
| &gt;     Операционная семантика подсказывает, что
<BR>
| &gt;     стек возвратов не сбрасывался, и из F можно вернуться в C.
<BR>
| &gt;
<BR>
| &gt; Получаем противоречие принципу (использованному в Рефале Плюс),
<BR>
| &gt; что в каждой точке статически известно, куда идут возвраты.
<BR>
| &gt;
<BR>
| &gt; Какие могут быть способы снять это противоречие?
<BR>
| &gt;
<BR>
| &gt; Мне в голову приходят 2:
<BR>
| &gt;
<BR>
| &gt; 1) Тот, что приняли авторы Рефала Плюс:
<BR>
| &gt;
<BR>
| &gt;     Продолжение пути после \{...} требует, что внутри скобок
<BR>
| &gt;     \? и \! были сбалансированы. То есть в этом случае
<BR>
| &gt;     блок целиком не отсекает возвраты.
<BR>
| &gt;
<BR>
| &gt;     Что здесь нам режет глаза? -- То, что свойства блока
<BR>
| &gt;     определяются не фактом закрытия в скобки,
<BR>
| &gt;     а наличием продолжения после правой скобки.
<BR>
| &gt;     То есть, как бы различаются два вида скобок \{...}
<BR>
| &gt;     - \{...}; -- те, после которых идет точка с запятой
<BR>
| &gt;     - \{...}, и \{...}: -- те, после которых стоит запятая или двоеточие
<BR>
| &gt;
<BR>
| &gt;     Ну, что ж: два вида так два. Если на самом деле надо столько,
<BR>
| &gt;     чтобы обеспечить желаемую семантику, то пусть будут.
<BR>
| &gt;     Можно считать, что по логике все нормально,
<BR>
| &gt;     а претензии -- к дизайну Рефала Плюс.
<BR>
| &gt;
<BR>
| &gt; 2) Но можно обобщить и довести &quot;до точки и до ручки&quot;:
<BR>
| &gt;
<BR>
| &gt;     Как известно, в конце путей перед всеми точками с запятой
<BR>
| &gt;     подразумевается необходимое число закрытий стека \!.
<BR>
| &gt;     Это правило можно обобщить, чтобы правые скобки --
<BR>
| &gt;     и перед точкой с запятой, и запятой, и двоеточием, --
<BR>
| &gt;     всегда подразумевали закрытие стека возвратов.
<BR>
| &gt;     А до какого уровня? - Здесь возможны варианты.
<BR>
| &gt;     Рассмотрим самый &quot;смелый&quot;:
<BR>
| &gt;
<BR>
| &gt;     Правые скобки закрывают стек возвратов до максимального
<BR>
| &gt;     уровня вхождений \! в тело блока -- так, чтобы можно
<BR>
| &gt;     было говорить о &quot;глубине отсечения&quot; для блока целиком.
<BR>
| &gt;
<BR>
| &gt; Звучит разумно и &quot;композиционно&quot;. По логике все чисто.
<BR>
| &gt; А что же здесь плохого, что авторы Рефала Плюс не решились
<BR>
| &gt; пойти на этот вариант (не считая, что они до него &quot;не догадались&quot;)?
<BR>
| &gt; Я не автор, но с большой вероятностью берусь предсказать их ответ:
<BR>
| &gt;
<BR>
| &gt;     Слишком много подразумеваний,
<BR>
| &gt;     а правило снятия этих подразумеваний слишком сложное:
<BR>
| &gt;     нужно найти все \! в теле и вычислить максимум их вложений.
<BR>
| &gt;
<BR>
| &gt; Но заметим, что критика этого решения не по _логике_ языка, а по _дизайну_.
<BR>
| &gt; Находясь в рамках той же логики, можно попытаться улучшить дизайн:
<BR>
| &gt;
<BR>
| &gt;     Как и в нынешней семантике, все операторы
<BR>
| &gt;     (как простые, так и составное) и пути
<BR>
| &gt;     характеризуется &quot;глубиной отсечения стека&quot;:
<BR>
| &gt;       - все простые кроме \! -- 0
<BR>
| &gt;       - \! -- 1
<BR>
| &gt;       - путь -- сумма числа \! за вычетом соответствующих \?
<BR>
| &gt;       - блок \{...; ...; ...;} -- глубина отсечения каждого пути,
<BR>
| &gt;         при условии, что они _равны_.
<BR>
| &gt;         (Если не равны, компилятор выдает ошибку).
<BR>
| &gt;
<BR>
| &gt; По логике вроде бы все разумно,
<BR>
| &gt; но дизайн все равно труден для человека.
<BR>
| &gt;
<BR>
| &gt; Вот поэтому (смею предположить) авторы Рефала Плюс
<BR>
| &gt; и пошли на компромиссный вариант с ограничением:
<BR>
| &gt;
<BR>
| &gt;   - В теле блока, стоящего в конце пути, -- \{...}; -- можно
<BR>
| &gt;     отсекать возвраты (иначе этот механизм обесценивается).
<BR>
| &gt;   - Блоки, стоящие в середине пути, -- \{...}, и \{...}: --
<BR>
| &gt;     всегда имеют &quot;глубину отсечения&quot; равную 0.
<BR>
| &gt;
<BR>
| &gt; Что и объясняет, откуда взялся 0 в правилах, приведенных Сергеем:
<BR>
| &gt;
<BR>
| &gt;     0 |- S
<BR>
| &gt;     k |- R
<BR>
| &gt;     --------
<BR>
| &gt;     k |- S R
<BR>
| &gt;
<BR>
| 
<BR>
|     На мой взгляд, есть еще третий вариант, который представляется вполне
<BR>
| разумным. Он состоит в том, что блок всегда характеризуется &quot;глубиной отсечения
<BR>
| стека&quot; равной 0, но отсекать возвраты в нем все равно можно ;-). Т.е. после
<BR>
| прохождения блока тропа оказывается на том же уровне, что и до блока,
<BR>
| независимо от находящихся в нем отсечений. Иначе говоря, всякое отсечение
<BR>
| действует только до конца текущего предложения (в терминах абстрактного
<BR>
| синтаксиса; в терминах статьи Сергея Романенко про компиляцию в виртуальный
<BR>
| код, до конца текущего предложения или текущей тропы). Такая семантика
<BR>
| совпадает с принятой, в случае, если блок - это последнее действие в
<BR>
| предложении, и добавляет приятную возможность, в случае неуспеха &quot;выброситься&quot;
<BR>
| куда-нибудь даже из источника. И &quot;дизайн&quot;, вроде бы, достаточно прост для
<BR>
| написания/понимания программ.
<BR>
| 
<BR>
|         С уважением,
<BR>
|                 Антон.
<BR>
| 
<BR>
| &gt; Аркадий, интересно, а какое решение ты принял в аналогичном месте Рефала-6?
<BR>
| &gt;
<BR>
<P>Сначала вопрос поставил меня в тупик, с одной стороны, потому, что я уже
<BR>
не помню (давно это было), и к сожалению, в свое время
<BR>
не доделал описание формальной семантики рефала-6: не распространил
<BR>
ее на отсечения и заборы, которые уже были реализованы. А с другой стороны,
<BR>
не сделал я этого не потому, что так уж это было бы трудно или некрасиво, а 
<BR>
потому, что мне тогда казалось, что этот элемент языка вообще лишний, а ввел
<BR>
я его в стремлении достичь &quot;совместимости&quot; с рефалом Плюс. (Взял это слово
<BR>
в кавычки, поскольку в строгом смысле она все равно не была обеспечена).
<BR>
Я не мог (да и сейчас не взялся) бы четко обосновать это свое отношение, но
<BR>
готов подписаться под всем тем, что высказал Сергей Романенко в своем
<BR>
сегодняшнем письме на эту тему.
<BR>
<P>Возвращаясь к заданному вопросу, могу предложить выдержку из документации
<BR>
(неформальной) по рефалу-6, из которой в принципе можно что-то вывести:
<BR>
Для гибкого управления неуспехами вводятся знаки &quot;/&quot; и &quot;\&quot;, которые могут ставиться между действиями. 
<BR>
<P>Знак &quot;/&quot; усиливает неуспех, проходящий через него справа налево так, что этот усиленный неуспех не может быть перехвачен предшествующим образцом или очередным окончанием объемлющего блока. Таким образом, неуспех выходит на уровень вызова функции, где и теряет свою избыточную силу. 
<BR>
<P>Знак &quot;\&quot; ослабляет усиленный неуспех, проходящий через него справа налево, после чего он может быть перехвачен обычным образом. Неуспех может быть многократно усилен при помощи нескольких знаков &quot;/&quot;. В этом случае до полного ослабления он должен пересечь столько же знаков &quot;\&quot;. 
<BR>
<P>Рассмотрим действие знаков &quot;/&quot; и &quot;\&quot; в случае простого окончания, состоящего из участков A1 - A5 (каждый участок - последовательность действий): 
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A1 \ A2 \ A3 / A4 / A5
<BR>
Неуспех в A5 может быть перехвачен только на участке A1, неуспех в A4 - на участках A2 и A1, но не в A3. Можно считать, что знаки &quot;/&quot; и &quot;\&quot;, стоящие вдоль одного пути как бы образуют скобочную структуру: неуспех передается от правой скобки &quot;/&quot; сразу к соответствующей левой скобке &quot;\&quot;. Чтобы не перепутать знаки &quot;/&quot; и &quot;\&quot; следует представлять себе, что усиленный неуспех проходит как бы снизу.  
<BR>
<P>Напомню, что под &quot;действием&quot; здесь понимается образец, результат или блок (образцовый или результатный).
<BR>
Здесь, к сожалению, явно не сказано, что при движении справа налево блоки обходятся, но это, конечно, подразумевается (поскольку ни о каком входе в блоки по неуспехам вообще нет речи). Подразумевается также, что если неуспех возник внутри блока, то при движении влево он может выйти за пределы блока через его начало - все блоки в рефале-6 прозрачны: изначально они вводятся лишь как средство группировки. Поэтому, как я понимаю, решение получилось именно то, которое и предложил Андрей К как &quot;третий вариант&quot;.
<BR>
<P>Аркадий.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0137.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0135.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0135.html">Arkady Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Nov 27 2000 - 15:41:16 MSK</EM>
</EM>
</SMALL>
</BODY>
</HTML>
