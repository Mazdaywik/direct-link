<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal-plus@botik.ru -- Discussing the Refal+ programming langua</TITLE>
<META NAME="Author" CONTENT="Anton Yu. Orlov (orlov@mccme.ru)">
<META NAME="Subject" CONTENT="Re: Об отсечениях внутри блока">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Об отсечениях внутри блока</H1>
<HR>
<P>
<!-- received="Sat Nov 25 21:10:54 2000" -->
<!-- isoreceived="20001125181054" -->
<!-- sent="Sat, 25 Nov 2000 21:16:08 +0300 (MSK)" -->
<!-- isosent="20001125181608" -->
<!-- name="Anton Yu. Orlov" -->
<!-- email="orlov@mccme.ru" -->
<!-- subject="Re: Об отсечениях внутри блока" -->
<!-- id="Pine.LNX.4.21.0011252112590.22989-100000@mccme.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="04c401c0565c$23d5ad80$2b00a8c0@scp1" -->
<STRONG>Subject: </STRONG>Re: Об отсечениях внутри блока<BR>
<STRONG>From: </STRONG>Anton Yu. Orlov (<EM>orlov@mccme.ru</EM>)<BR>
<STRONG>Date: </STRONG>Sat Nov 25 2000 - 21:16:08 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#135">[ date ]</A>
<A HREF="index.html#135">[ thread ]</A>
<A HREF="subject.html#135">[ subject ]</A>
<A HREF="author.html#135">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0134.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Maybe reply:</STRONG> <A HREF="0134.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0138.html">Arkady Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здравствуйте, Андрей и Сергей!
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Прежде всего, хочу поблагодарить вас за замечательные ответы на мой вопрос
<BR>
и объяснение ситуации с той семантикой, которая сейчас принята. Тем не менее,
<BR>
мне бы не хотелось мириться с существующим положением вещей, и поэтому у меня
<BR>
есть предложение (см. ниже).
<BR>
<P>Andrei Klimov wrote:
<BR>
<P><EM>&gt; Антон и Сергей, добрый день!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Большое спасибо за интереснейший пример на тонкости
</EM><BR>
<EM>&gt; Рефала Плюс! Жизнь такова, что сложностей нет только
</EM><BR>
<EM>&gt; у слабых языков, скажем, у машины Тьюринга. ;-)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; А все-таки хочется разобраться по существу:
</EM><BR>
<EM>&gt; Интересно, из каких соображений была выбрана такая семантика? --
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     0 |- S
</EM><BR>
<EM>&gt;     k |- R
</EM><BR>
<EM>&gt;     --------
</EM><BR>
<EM>&gt;     k |- S R
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Это было сделано просто ради какого-то частного упрощения или
</EM><BR>
<EM>&gt; возникают какие-то нетривиальные &quot;противоречия&quot;?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Задав вопрос, сам же попытаюсь дать на него ответ.
</EM><BR>
<EM>&gt; Для начала обобщим пример, наставив букв, обозначающих
</EM><BR>
<EM>&gt; некоторые правильные фрагменты программы:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     A \? B \{ C \! D; E}, F;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Теперь представим операционную семантику, то есть процесс вычислений.
</EM><BR>
<EM>&gt; После вычисления A проходим \?. Это означает, что в стеке
</EM><BR>
<EM>&gt; возвратов отмечается текущее точка. После того, как
</EM><BR>
<EM>&gt; пройдем С и \!, стек возвратов будет сброшен до этой точки.
</EM><BR>
<EM>&gt; В результате, возвраты из D пойдут куда-то в A, а не в C или E.
</EM><BR>
<EM>&gt; Хитро, но пока все разумно: именно для таких &quot;трюков&quot;
</EM><BR>
<EM>&gt; и были \? и \! внесены в язык.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; А вот с F -- тонкость:
</EM><BR>
<EM>&gt; - куда должны идти возвраты из F: в B или сразу в A?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Если не заглядывать в скобки (понадеявшись на
</EM><BR>
<EM>&gt; &quot;композиционность&quot; языка -- то есть, что вложенные конструкции
</EM><BR>
<EM>&gt; в разумных пределах не влияют на семантику объемлющих),
</EM><BR>
<EM>&gt; то наивно хочется, чтобы возвраты из F шли в B.
</EM><BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Да, это именно так. И, кажется, есть способ этого добиться (см. ниже).
<BR>
Сразу хочу сделать замечание о целесообразности вообще рассмотрения семантики
<BR>
отсечений, отличной от существующей. У меня уже неоднократно возникало желание
<BR>
использовать отсечения таким образом. Это желание (как я понимаю после
<BR>
предыдущего прекрасного объяснения) возникало в тех случаях, когда возвраты в B
<BR>
автоматически становятся возвратами в A (например, когда B просто отсутствует).
<BR>
И всякий раз приходится как-то выкручиваться. Особенно неприятна в этом смысле
<BR>
ситуация, когда хочется сделать возврат из блока, котырый инциализуриет
<BR>
какие-нибудь переменные в последующем паттерне, после чего идет долгое
<BR>
вычисление, использующее эти переменные. Поэтому я и задал свой вопрос
<BR>
(невнимательно, как выяснилось, прочитав книжку ;-).
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; - А если мы попали в F, пройдя С \! D, то что?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Операционная семантика подсказывает, что
</EM><BR>
<EM>&gt;     стек уже сброшен до уровня, отмеченного знаком \?.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; - А если мы попали в F, сделав возврат из C на Е и выйдя
</EM><BR>
<EM>&gt; из скобок без отсечения возвратов, то что?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Операционная семантика подсказывает, что
</EM><BR>
<EM>&gt;     стек возвратов не сбрасывался, и из F можно вернуться в C.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Получаем противоречие принципу (использованному в Рефале Плюс),
</EM><BR>
<EM>&gt; что в каждой точке статически известно, куда идут возвраты.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Какие могут быть способы снять это противоречие?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Мне в голову приходят 2:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; 1) Тот, что приняли авторы Рефала Плюс:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Продолжение пути после \{...} требует, что внутри скобок
</EM><BR>
<EM>&gt;     \? и \! были сбалансированы. То есть в этом случае
</EM><BR>
<EM>&gt;     блок целиком не отсекает возвраты.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Что здесь нам режет глаза? -- То, что свойства блока
</EM><BR>
<EM>&gt;     определяются не фактом закрытия в скобки,
</EM><BR>
<EM>&gt;     а наличием продолжения после правой скобки.
</EM><BR>
<EM>&gt;     То есть, как бы различаются два вида скобок \{...}
</EM><BR>
<EM>&gt;     - \{...}; -- те, после которых идет точка с запятой
</EM><BR>
<EM>&gt;     - \{...}, и \{...}: -- те, после которых стоит запятая или двоеточие
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Ну, что ж: два вида так два. Если на самом деле надо столько,
</EM><BR>
<EM>&gt;     чтобы обеспечить желаемую семантику, то пусть будут.
</EM><BR>
<EM>&gt;     Можно считать, что по логике все нормально,
</EM><BR>
<EM>&gt;     а претензии -- к дизайну Рефала Плюс.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; 2) Но можно обобщить и довести &quot;до точки и до ручки&quot;:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Как известно, в конце путей перед всеми точками с запятой
</EM><BR>
<EM>&gt;     подразумевается необходимое число закрытий стека \!.
</EM><BR>
<EM>&gt;     Это правило можно обобщить, чтобы правые скобки --
</EM><BR>
<EM>&gt;     и перед точкой с запятой, и запятой, и двоеточием, --
</EM><BR>
<EM>&gt;     всегда подразумевали закрытие стека возвратов.
</EM><BR>
<EM>&gt;     А до какого уровня? - Здесь возможны варианты.
</EM><BR>
<EM>&gt;     Рассмотрим самый &quot;смелый&quot;:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Правые скобки закрывают стек возвратов до максимального
</EM><BR>
<EM>&gt;     уровня вхождений \! в тело блока -- так, чтобы можно
</EM><BR>
<EM>&gt;     было говорить о &quot;глубине отсечения&quot; для блока целиком.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Звучит разумно и &quot;композиционно&quot;. По логике все чисто.
</EM><BR>
<EM>&gt; А что же здесь плохого, что авторы Рефала Плюс не решились
</EM><BR>
<EM>&gt; пойти на этот вариант (не считая, что они до него &quot;не догадались&quot;)?
</EM><BR>
<EM>&gt; Я не автор, но с большой вероятностью берусь предсказать их ответ:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Слишком много подразумеваний,
</EM><BR>
<EM>&gt;     а правило снятия этих подразумеваний слишком сложное:
</EM><BR>
<EM>&gt;     нужно найти все \! в теле и вычислить максимум их вложений.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Но заметим, что критика этого решения не по _логике_ языка, а по _дизайну_.
</EM><BR>
<EM>&gt; Находясь в рамках той же логики, можно попытаться улучшить дизайн:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     Как и в нынешней семантике, все операторы
</EM><BR>
<EM>&gt;     (как простые, так и составное) и пути
</EM><BR>
<EM>&gt;     характеризуется &quot;глубиной отсечения стека&quot;:
</EM><BR>
<EM>&gt;       - все простые кроме \! -- 0
</EM><BR>
<EM>&gt;       - \! -- 1
</EM><BR>
<EM>&gt;       - путь -- сумма числа \! за вычетом соответствующих \?
</EM><BR>
<EM>&gt;       - блок \{...; ...; ...;} -- глубина отсечения каждого пути,
</EM><BR>
<EM>&gt;         при условии, что они _равны_.
</EM><BR>
<EM>&gt;         (Если не равны, компилятор выдает ошибку).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; По логике вроде бы все разумно,
</EM><BR>
<EM>&gt; но дизайн все равно труден для человека.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Вот поэтому (смею предположить) авторы Рефала Плюс
</EM><BR>
<EM>&gt; и пошли на компромиссный вариант с ограничением:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;   - В теле блока, стоящего в конце пути, -- \{...}; -- можно
</EM><BR>
<EM>&gt;     отсекать возвраты (иначе этот механизм обесценивается).
</EM><BR>
<EM>&gt;   - Блоки, стоящие в середине пути, -- \{...}, и \{...}: --
</EM><BR>
<EM>&gt;     всегда имеют &quot;глубину отсечения&quot; равную 0.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Что и объясняет, откуда взялся 0 в правилах, приведенных Сергеем:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     0 |- S
</EM><BR>
<EM>&gt;     k |- R
</EM><BR>
<EM>&gt;     --------
</EM><BR>
<EM>&gt;     k |- S R
</EM><BR>
<EM>&gt;
</EM><BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;На мой взгляд, есть еще третий вариант, который представляется вполне
<BR>
разумным. Он состоит в том, что блок всегда характеризуется &quot;глубиной отсечения
<BR>
стека&quot; равной 0, но отсекать возвраты в нем все равно можно ;-). Т.е. после
<BR>
прохождения блока тропа оказывается на том же уровне, что и до блока,
<BR>
независимо от находящихся в нем отсечений. Иначе говоря, всякое отсечение
<BR>
действует только до конца текущего предложения (в терминах абстрактного
<BR>
синтаксиса; в терминах статьи Сергея Романенко про компиляцию в виртуальный
<BR>
код, до конца текущего предложения или текущей тропы). Такая семантика
<BR>
совпадает с принятой, в случае, если блок - это последнее действие в
<BR>
предложении, и добавляет приятную возможность, в случае неуспеха &quot;выброситься&quot;
<BR>
куда-нибудь даже из источника. И &quot;дизайн&quot;, вроде бы, достаточно прост для
<BR>
написания/понимания программ.
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;С уважением,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Антон.
<BR>
<P><EM>&gt; Аркадий, интересно, а какое решение ты принял в аналогичном месте Рефала-6?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Ну, а по поводу вреда формальных спецификаций при разработке
</EM><BR>
<EM>&gt; языков -- я бы не согласился. Дело не в спецификациях как таковых,
</EM><BR>
<EM>&gt; а в их &quot;правильном&quot; использовании без &quot;болезней левизны&quot; и &quot;перегибов&quot;. ;-)
</EM><BR>
<EM>&gt; Естесвенно, когда в процессе шлифовки семантики формальной
</EM><BR>
<EM>&gt; системы подбирается и средства описания семантики.
</EM><BR>
<EM>&gt; И конечно, их &quot;синэнергизм&quot; часто получается далеко не сразу.
</EM><BR>
<EM>&gt; Живое использование приводит к дальнейшему развитию.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Что и происходит сейчас с Рефалом Плюс!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Успехов!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Андрей.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; ----- Original Message -----
</EM><BR>
<EM>&gt; From: &quot;Sergei Romanenko&quot; &lt;roman@integrum.ru&gt;
</EM><BR>
<EM>&gt; To: &quot;Anton Yu. Orlov&quot; &lt;orlov@mccme.ru&gt;
</EM><BR>
<EM>&gt; Cc: &quot;Ruten Gurin&quot; &lt;ruten@caspur.it&gt;; &lt;refal-plus@botik.ru&gt;; &quot;Andrei Klimov&quot; &lt;andrei.klimov@supercompilers.com&gt;; &quot;Fedor Romanenko&quot;
</EM><BR>
<EM>&gt; &lt;fedor@blues.ru&gt;
</EM><BR>
<EM>&gt; Sent: Friday, November 24, 2000 14:11
</EM><BR>
<EM>&gt; Subject: Re: Об отсечениях внутри блока.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; ----- Original Message -----
</EM><BR>
<EM>&gt; &gt; From: &quot;Anton Yu. Orlov&quot; &lt;orlov@mccme.ru&gt;
</EM><BR>
<EM>&gt; &gt; To: &quot;Sergei Romanenko&quot; &lt;roman@integrum.ru&gt;
</EM><BR>
<EM>&gt; &gt; Cc: &lt;refal-plus@botik.ru&gt;
</EM><BR>
<EM>&gt; &gt; Sent: Friday, November 24, 2000 9:27 AM
</EM><BR>
<EM>&gt; &gt; Subject: Об отсечениях внутри блока.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt;    У меня к Вам следующий вопрос по Рефалу+. Если попытаться
</EM><BR>
<EM>&gt; &gt; &gt; скомпилировать такую программу:
</EM><BR>
<EM>&gt; &gt; &gt;        Main = \? \{ \!; },;
</EM><BR>
<EM>&gt; &gt; &gt; то компилятор выдаст ошибку: ERROR: '\!' without corresponding '\?'.
</EM><BR>
<EM>&gt; &gt; &gt; Дело здесь в последней запятой. Если ее убрать, то все будет хорошо. В
</EM><BR>
<EM>&gt; &gt; &gt; книжке по P+ я не нашел соответствующих ограничений на такое
</EM><BR>
<EM>&gt; &gt; &gt; использование отсечений. Это ошибка в компиляторе?
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Ну что, же... Этот пример лишний раз свидетельствует, что дизайн Рефала
</EM><BR>
<EM>&gt; &gt; Плюс - слишком утонченный и заумный. Заодно это показывает ВРЕД
</EM><BR>
<EM>&gt; &gt; использования формальных спецификаций при разработке языков! (Хотя, конечно,
</EM><BR>
<EM>&gt; &gt; спецификации полезны для фиксации смысла языка после того, как его
</EM><BR>
<EM>&gt; &gt; разработка закончена.)
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Язык должен быть таким, чтобы его смысл был интуитивно понятен простому
</EM><BR>
<EM>&gt; &gt; народу, и чтобы его конструкции мжно было объяснить &quot;на пальцах&quot;, без
</EM><BR>
<EM>&gt; &gt; привлечения формальных спецификаций.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; При этом наблюдается интересная закономерность: если язык прост и понятен с
</EM><BR>
<EM>&gt; &gt; точки зрения здравого смысла, то его формальная спецификация, как правило,
</EM><BR>
<EM>&gt; &gt; оказывается вычурной и утонченной. И наоборот, изящные спецификации обычно
</EM><BR>
<EM>&gt; &gt; генерируют нечто контро-интуитивное...
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; (Кстати, ведь процесс обучения математике, в основном и состоит в том, чтобы
</EM><BR>
<EM>&gt; &gt; поставить обучаемого на уши: чтоб он ходил не ногами, а на руках. Чтобы
</EM><BR>
<EM>&gt; &gt; тривиальное ему показалось сложным, и заумное - простым и естественным.
</EM><BR>
<EM>&gt; &gt; &quot;Точка - это то, что не имеет частей, линия - это длина без ширины&quot;, и т.п.)
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Если же вернуться к вышеприведенной программе, то ей соответствует следующее
</EM><BR>
<EM>&gt; &gt; правило вывода из (Глава 2, раздел 13.5):
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; 0 |- S
</EM><BR>
<EM>&gt; &gt; k |- R
</EM><BR>
<EM>&gt; &gt; --------
</EM><BR>
<EM>&gt; &gt; k |- S R
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Т.е. &quot;\{ \!; }&quot; - это &quot;источник&quot; S, а &quot;,&quot; - это &quot;хвост&quot; R. Из правила вывода
</EM><BR>
<EM>&gt; &gt; следует, что, с точки зрения отсечений, S рассматривается как находящийся на
</EM><BR>
<EM>&gt; &gt; уровне 0, а R - на уровне k. Поэтому компилятор пожаловался правильно.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; (Впрочем, если я сам запутался в спецификации, то не возражаю, если меня
</EM><BR>
<EM>&gt; &gt; поправят...)
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Сергей
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0134.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Maybe reply:</STRONG> <A HREF="0134.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0136.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0138.html">Arkady Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Sat Nov 25 2000 - 21:10:56 MSK</EM>
</EM>
</SMALL>
</BODY>
</HTML>
