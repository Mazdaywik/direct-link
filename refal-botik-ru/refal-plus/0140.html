<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal-plus@botik.ru -- Discussing the Refal+ programming langua</TITLE>
<META NAME="Author" CONTENT="Andrei Klimov (Andrei.Klimov@supercompilers.com)">
<META NAME="Subject" CONTENT="Re: Об отсечениях внутри блока">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Об отсечениях внутри блока</H1>
<HR>
<P>
<!-- received="Thu Nov 30 07:25:20 2000" -->
<!-- isoreceived="20001130042520" -->
<!-- sent="Fri, 24 Nov 2000 16:18:38 -0500" -->
<!-- isosent="20001124211838" -->
<!-- name="Andrei Klimov" -->
<!-- email="Andrei.Klimov@supercompilers.com" -->
<!-- subject="Re: Об отсечениях внутри блока" -->
<!-- id="04c401c0565c$23d5ad80$2b00a8c0@scp1" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="00dc01c0564a$fdb1f200$0a3aa8c0@shipil.ru" -->
<STRONG>Subject: </STRONG>Re: Об отсечениях внутри блока<BR>
<STRONG>From: </STRONG>Andrei Klimov (<EM>Andrei.Klimov@supercompilers.com</EM>)<BR>
<STRONG>Date: </STRONG>Sat Nov 25 2000 - 00:18:38 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#140">[ date ]</A>
<A HREF="index.html#140">[ thread ]</A>
<A HREF="subject.html#140">[ subject ]</A>
<A HREF="author.html#140">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0141.html">Andrei Klimov: "Problems with {refal,refal-plus}@botik.u resolved (Was: Об отсечениях внутри блока."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0134.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0135.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0134.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Антон и Сергей, добрый день!
<BR>
<P>Большое спасибо за интереснейший пример на тонкости
<BR>
Рефала Плюс! Жизнь такова, что сложностей нет только
<BR>
у слабых языков, скажем, у машины Тьюринга. ;-)
<BR>
<P>А все-таки хочется разобраться по существу:
<BR>
Интересно, из каких соображений была выбрана такая семантика? --
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;0 |- S
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;k |- R
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--------
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;k |- S R
<BR>
<P>Это было сделано просто ради какого-то частного упрощения или
<BR>
возникают какие-то нетривиальные &quot;противоречия&quot;?
<BR>
<P>Задав вопрос, сам же попытаюсь дать на него ответ.
<BR>
Для начала обобщим пример, наставив букв, обозначающих
<BR>
некоторые правильные фрагменты программы:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;A \? B \{ C \! D; E}, F;
<BR>
<P>Теперь представим операционную семантику, то есть процесс вычислений.
<BR>
После вычисления A проходим \?. Это означает, что в стеке
<BR>
возвратов отмечается текущее точка. После того, как
<BR>
пройдем С и \!, стек возвратов будет сброшен до этой точки.
<BR>
В результате, возвраты из D пойдут куда-то в A, а не в C или E.
<BR>
Хитро, но пока все разумно: именно для таких &quot;трюков&quot;
<BR>
и были \? и \! внесены в язык.
<BR>
<P>А вот с F -- тонкость:
<BR>
- куда должны идти возвраты из F: в B или сразу в A?
<BR>
<P>Если не заглядывать в скобки (понадеявшись на
<BR>
&quot;композиционность&quot; языка -- то есть, что вложенные конструкции
<BR>
в разумных пределах не влияют на семантику объемлющих),
<BR>
то наивно хочется, чтобы возвраты из F шли в B.
<BR>
<P>- А если мы попали в F, пройдя С \! D, то что?
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Операционная семантика подсказывает, что
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;стек уже сброшен до уровня, отмеченного знаком \?.
<BR>
<P>- А если мы попали в F, сделав возврат из C на Е и выйдя
<BR>
из скобок без отсечения возвратов, то что?
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Операционная семантика подсказывает, что
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;стек возвратов не сбрасывался, и из F можно вернуться в C.
<BR>
<P>Получаем противоречие принципу (использованному в Рефале Плюс),
<BR>
что в каждой точке статически известно, куда идут возвраты.
<BR>
<P>Какие могут быть способы снять это противоречие?
<BR>
<P>Мне в голову приходят 2:
<BR>
<P>1) Тот, что приняли авторы Рефала Плюс:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Продолжение пути после \{...} требует, что внутри скобок
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;\? и \! были сбалансированы. То есть в этом случае
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;блок целиком не отсекает возвраты.
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Что здесь нам режет глаза? -- То, что свойства блока
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;определяются не фактом закрытия в скобки,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;а наличием продолжения после правой скобки.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;То есть, как бы различаются два вида скобок \{...}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- \{...}; -- те, после которых идет точка с запятой
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- \{...}, и \{...}: -- те, после которых стоит запятая или двоеточие
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Ну, что ж: два вида так два. Если на самом деле надо столько,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;чтобы обеспечить желаемую семантику, то пусть будут.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Можно считать, что по логике все нормально,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;а претензии -- к дизайну Рефала Плюс.
<BR>
<P>2) Но можно обобщить и довести &quot;до точки и до ручки&quot;:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Как известно, в конце путей перед всеми точками с запятой
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;подразумевается необходимое число закрытий стека \!.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Это правило можно обобщить, чтобы правые скобки --
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;и перед точкой с запятой, и запятой, и двоеточием, --
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;всегда подразумевали закрытие стека возвратов.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;А до какого уровня? - Здесь возможны варианты.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Рассмотрим самый &quot;смелый&quot;:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Правые скобки закрывают стек возвратов до максимального
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;уровня вхождений \! в тело блока -- так, чтобы можно
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;было говорить о &quot;глубине отсечения&quot; для блока целиком.
<BR>
<P>Звучит разумно и &quot;композиционно&quot;. По логике все чисто.
<BR>
А что же здесь плохого, что авторы Рефала Плюс не решились
<BR>
пойти на этот вариант (не считая, что они до него &quot;не догадались&quot;)?
<BR>
Я не автор, но с большой вероятностью берусь предсказать их ответ:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Слишком много подразумеваний,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;а правило снятия этих подразумеваний слишком сложное:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;нужно найти все \! в теле и вычислить максимум их вложений.
<BR>
<P>Но заметим, что критика этого решения не по _логике_ языка, а по _дизайну_.
<BR>
Находясь в рамках той же логики, можно попытаться улучшить дизайн:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Как и в нынешней семантике, все операторы
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(как простые, так и составное) и пути
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;характеризуется &quot;глубиной отсечения стека&quot;:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- все простые кроме \! -- 0
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- \! -- 1
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- путь -- сумма числа \! за вычетом соответствующих \?
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- блок \{...; ...; ...;} -- глубина отсечения каждого пути,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;при условии, что они _равны_.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Если не равны, компилятор выдает ошибку).
<BR>
<P>По логике вроде бы все разумно,
<BR>
но дизайн все равно труден для человека.
<BR>
<P>Вот поэтому (смею предположить) авторы Рефала Плюс
<BR>
и пошли на компромиссный вариант с ограничением:
<BR>
<P>&nbsp;&nbsp;- В теле блока, стоящего в конце пути, -- \{...}; -- можно
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;отсекать возвраты (иначе этот механизм обесценивается).
<BR>
&nbsp;&nbsp;- Блоки, стоящие в середине пути, -- \{...}, и \{...}: --
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;всегда имеют &quot;глубину отсечения&quot; равную 0.
<BR>
<P>Что и объясняет, откуда взялся 0 в правилах, приведенных Сергеем:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;0 |- S
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;k |- R
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--------
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;k |- S R
<BR>
<P>Аркадий, интересно, а какое решение ты принял в аналогичном месте Рефала-6?
<BR>
<P>Ну, а по поводу вреда формальных спецификаций при разработке
<BR>
языков -- я бы не согласился. Дело не в спецификациях как таковых,
<BR>
а в их &quot;правильном&quot; использовании без &quot;болезней левизны&quot; и &quot;перегибов&quot;. ;-)
<BR>
Естесвенно, когда в процессе шлифовки семантики формальной
<BR>
системы подбирается и средства описания семантики.
<BR>
И конечно, их &quot;синэнергизм&quot; часто получается далеко не сразу.
<BR>
Живое использование приводит к дальнейшему развитию.
<BR>
<P>Что и происходит сейчас с Рефалом Плюс!
<BR>
<P>Успехов!
<BR>
<P>Андрей.
<BR>
<P>----- Original Message -----
<BR>
From: &quot;Sergei Romanenko&quot; &lt;roman@integrum.ru&gt;
<BR>
To: &quot;Anton Yu. Orlov&quot; &lt;orlov@mccme.ru&gt;
<BR>
Cc: &quot;Ruten Gurin&quot; &lt;ruten@caspur.it&gt;; &lt;refal-plus@botik.ru&gt;; &quot;Andrei Klimov&quot; &lt;andrei.klimov@supercompilers.com&gt;; &quot;Fedor Romanenko&quot;
<BR>
&lt;fedor@blues.ru&gt;
<BR>
Sent: Friday, November 24, 2000 14:11
<BR>
Subject: Re: Об отсечениях внутри блока.
<BR>
<P><P><EM>&gt;
</EM><BR>
<EM>&gt; ----- Original Message -----
</EM><BR>
<EM>&gt; From: &quot;Anton Yu. Orlov&quot; &lt;orlov@mccme.ru&gt;
</EM><BR>
<EM>&gt; To: &quot;Sergei Romanenko&quot; &lt;roman@integrum.ru&gt;
</EM><BR>
<EM>&gt; Cc: &lt;refal-plus@botik.ru&gt;
</EM><BR>
<EM>&gt; Sent: Friday, November 24, 2000 9:27 AM
</EM><BR>
<EM>&gt; Subject: Об отсечениях внутри блока.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt;    У меня к Вам следующий вопрос по Рефалу+. Если попытаться
</EM><BR>
<EM>&gt; &gt; скомпилировать такую программу:
</EM><BR>
<EM>&gt; &gt;        Main = \? \{ \!; },;
</EM><BR>
<EM>&gt; &gt; то компилятор выдаст ошибку: ERROR: '\!' without corresponding '\?'.
</EM><BR>
<EM>&gt; &gt; Дело здесь в последней запятой. Если ее убрать, то все будет хорошо. В
</EM><BR>
<EM>&gt; &gt; книжке по P+ я не нашел соответствующих ограничений на такое
</EM><BR>
<EM>&gt; &gt; использование отсечений. Это ошибка в компиляторе?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Ну что, же... Этот пример лишний раз свидетельствует, что дизайн Рефала
</EM><BR>
<EM>&gt; Плюс - слишком утонченный и заумный. Заодно это показывает ВРЕД
</EM><BR>
<EM>&gt; использования формальных спецификаций при разработке языков! (Хотя, конечно,
</EM><BR>
<EM>&gt; спецификации полезны для фиксации смысла языка после того, как его
</EM><BR>
<EM>&gt; разработка закончена.)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Язык должен быть таким, чтобы его смысл был интуитивно понятен простому
</EM><BR>
<EM>&gt; народу, и чтобы его конструкции мжно было объяснить &quot;на пальцах&quot;, без
</EM><BR>
<EM>&gt; привлечения формальных спецификаций.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; При этом наблюдается интересная закономерность: если язык прост и понятен с
</EM><BR>
<EM>&gt; точки зрения здравого смысла, то его формальная спецификация, как правило,
</EM><BR>
<EM>&gt; оказывается вычурной и утонченной. И наоборот, изящные спецификации обычно
</EM><BR>
<EM>&gt; генерируют нечто контро-интуитивное...
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; (Кстати, ведь процесс обучения математике, в основном и состоит в том, чтобы
</EM><BR>
<EM>&gt; поставить обучаемого на уши: чтоб он ходил не ногами, а на руках. Чтобы
</EM><BR>
<EM>&gt; тривиальное ему показалось сложным, и заумное - простым и естественным.
</EM><BR>
<EM>&gt; &quot;Точка - это то, что не имеет частей, линия - это длина без ширины&quot;, и т.п.)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Если же вернуться к вышеприведенной программе, то ей соответствует следующее
</EM><BR>
<EM>&gt; правило вывода из (Глава 2, раздел 13.5):
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; 0 |- S
</EM><BR>
<EM>&gt; k |- R
</EM><BR>
<EM>&gt; --------
</EM><BR>
<EM>&gt; k |- S R
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Т.е. &quot;\{ \!; }&quot; - это &quot;источник&quot; S, а &quot;,&quot; - это &quot;хвост&quot; R. Из правила вывода
</EM><BR>
<EM>&gt; следует, что, с точки зрения отсечений, S рассматривается как находящийся на
</EM><BR>
<EM>&gt; уровне 0, а R - на уровне k. Поэтому компилятор пожаловался правильно.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; (Впрочем, если я сам запутался в спецификации, то не возражаю, если меня
</EM><BR>
<EM>&gt; поправят...)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Сергей
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0141.html">Andrei Klimov: "Problems with {refal,refal-plus}@botik.u resolved (Was: Об отсечениях внутри блока."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0139.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0134.html">Sergei Romanenko: "Re: Об отсечениях внутри блока"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0135.html">Anton Yu. Orlov: "Re: Об отсечениях внутри блока"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0134.html">Andrei Klimov: "Re: Об отсечениях внутри блока"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Thu Nov 30 2000 - 07:25:22 MSK</EM>
</EM>
</SMALL>
</BODY>
</HTML>
