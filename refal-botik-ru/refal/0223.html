<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klark@bagirra.net)">
<META NAME="Subject" CONTENT="Re: О типизации рефальских выражени">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: О типизации рефальских выражени</H1>
<HR>
<P>
<!-- received="Mon Aug 20 11:52:10 2001" -->
<!-- isoreceived="20010820075210" -->
<!-- sent="Sun, 19 Aug 2001 22:41:30 +0300" -->
<!-- isosent="20010819194130" -->
<!-- name="Arkady Klimov" -->
<!-- email="klark@bagirra.net" -->
<!-- subject="Re: О типизации рефальских выражени" -->
<!-- id="006201c128e6$f5edb530$929943c2@Bagirra" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="3B7FD34E.18B5BDAE@mindspring.com" -->
<STRONG>Subject: </STRONG>Re: О типизации рефальских выражени<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klark@bagirra.net</EM>)<BR>
<STRONG>Date: </STRONG>Sun Aug 19 2001 - 23:41:30 MSD
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#223">[ date ]</A>
<A HREF="index.html#223">[ thread ]</A>
<A HREF="subject.html#223">[ subject ]</A>
<A HREF="author.html#223">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0224.html">Mike Potanin: "Re: О типизации рефальских выражений"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0222.html">Mikhail Kovtun: "О типизации рефальских выражений"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0222.html">Mikhail Kovtun: "О типизации рефальских выражений"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0224.html">Mike Potanin: "Re: О типизации рефальских выражений"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0222.html">Arkady Klimov: "Re: О типизации рефальских выражени"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Привет всем
<BR>
Некоторые вопросы и комментарии см. ниже по тексту.
<BR>
Прошу прощения за то, что цитирую все без сокращений.
<BR>
АРКадий.
<BR>
&nbsp;&nbsp;----- Original Message ----- 
<BR>
&nbsp;&nbsp;From: Mikhail Kovtun 
<BR>
&nbsp;&nbsp;To: refal@botik.ru 
<BR>
&nbsp;&nbsp;Sent: Sunday, August 19, 2001 5:55 PM
<BR>
&nbsp;&nbsp;Subject: О типизации рефальских выражений
<BR>
<P><P>&nbsp;&nbsp;Привет всем! 
<BR>
&nbsp;&nbsp;Мне пришла в голову одна мысль, которой я бы хотел поделиться -- может быть, здесь есть что-то стоящее. 
<BR>
<P>&nbsp;&nbsp;В качестве типов рефальских выражений предлагается использовать регулярные выражения, построенные из регулярных языков деревьев. 
<BR>
<P>&nbsp;&nbsp;Регулярные языки деревьев (чтобы было не страшно:-) -- это ML-евские datatype. 
<BR>
<P>&nbsp;&nbsp;Несколько фактов об регулярных языках деревьев: 
<BR>
<P>&nbsp;&nbsp;-- Распознаются конечными автоматами. 
<BR>
<P>АРК:
<BR>
А в каком смысле они &quot;распознаются&quot;? Как дерево подается на вход автомату? (Прошу прощения за некомпетентность).
<BR>
<P>&nbsp;&nbsp;-- Обладают практически всеми свойствами регулярных строковых языков (замкнутось относительно теоретико-множественных операций, разрешимость проблем непустоты, эквивалентности, и т.п.). 
<BR>
<P>&nbsp;&nbsp;-- Мощнее регулярных строковых языков; в некотором смысле, эквивалентны контекстно-свободным языкам. Именно: для любого контекстно-свободного языка L можно построить регулярный язык деревьев T такой, что множество предложений языка L -- это в точности множество строк, являющихся списками терминалов деревьев из T. (Кстати, по-английски такая строка называется yield -- а как по-русски? Я бы воздержался от транслитерации. А интересно, как этот термин переведут любители &quot;рестрикций на перфектных деревьях&quot;? 
<BR>
<P>АРК:
<BR>
Это можно было бы назвать &quot;сериализацией&quot;, если я правильно понял
<BR>
<P>&nbsp;&nbsp;Эх, был бы жив адмирал Шишков, я бы отправил в его журнал статью под названием &quot;К чему могут привести попытки перевода иностранных слов путем транслитерации&quot;:-). Другими словами, множество деревьев синтаксического разбора некоторого строкового контекстно-свободного языка образует регулярный язык деревьев. 
<BR>
<P>&nbsp;&nbsp;При &quot;грамматическом&quot; подходе, регулярный язык деревьев задается с помощью системы правил вида: 
<BR>
<P>&nbsp;&nbsp;Phylum =&gt; Constructor(Phylum1,...,Phylumn) 
<BR>
<P>&nbsp;&nbsp;Phyla (Шишков, прости!) служат нетерминалами в выводе. В сгенерированном дереве есть только конструкторы, причем 0-местные конструкторы являются терминалами. В приложении к типизации, 0-местные конструкторы естественно отождествить с примитивными типами. 
<BR>
<P>&nbsp;&nbsp;Например, двоичные деревья, в которых каждому нетерминалу приписано целое число, могут быть описаны как: 
<BR>
<P>&nbsp;&nbsp;BinTree =&gt; NonTerminal(Integer,BinTree,BinTree) 
<BR>
&nbsp;&nbsp;BinTree =&gt; Terminal() 
<BR>
&nbsp;&nbsp;Integer =&gt; int() 
<BR>
<P>&nbsp;&nbsp;Нетрудно видеть, что с точностью до обозначений и естественных сокращений, это ML-евское определение datatype. 
<BR>
<P>&nbsp;&nbsp;Применительно к рефалу, добавим новую форму правила: 
<BR>
<P>&nbsp;&nbsp;Phylum =&gt; регулярное выражение, составленное из phyla 
<BR>
<P>&nbsp;&nbsp;и разрешим только 1- и 0-местные конструкторы (многоместные конструкторы теперь выразимы как одноместные конструкторы, имеющие аргументом регулярное выражение вида &quot;конкатенация&quot;). 
<BR>
<P>АРК:
<BR>
Одно интересное замечание: похоже, это получается в точности то, как определяется тип xml-документа посредством DTD (если отвлечься от некоторых деталей, например атрибутов). 
<BR>
<P><P><P>&nbsp;&nbsp;(Я бы мог привести формальное определение, но на данном этапе это только запутало бы дело.) 
<BR>
<P>&nbsp;&nbsp;В качестве примера рассмотрим двоичные деревья, нетерминальным вершинам которых приприсаны целые числа так, что обход &quot;левое поддерево -- корень -- правое поддерево&quot; выдает упорядоченную последовательность чисел. Рассмотрим также функцию, которая добавляет к дереву новое число с сохранением порядка. 
<BR>
<P>&nbsp;&nbsp;На &quot;нетипизированном рефале&quot; эта функция выглядит так: 
<BR>
<P>&nbsp;&nbsp;AddNode 
<BR>
&nbsp;&nbsp;{ 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.new () = (s.new () ()); 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.new (s.root t.left t.right), 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;GreaterThen s.new s.root&gt; : { 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True  = (s.root t.left &lt;AddNode s.new t.right&gt;); 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False = (s.root &lt;AddNode s.new t.left&gt; t.right); 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}; 
<BR>
&nbsp;&nbsp;}; 
<BR>
<P>&nbsp;&nbsp;(Я надеюсь, что здесь не слишком много синтаксических ошибок.) 
<BR>
<P>&nbsp;&nbsp;Теперь добавим типовую информацию (я ни в коем случае не настаиваю на синтаксисе; это дело будущего): 
<BR>
<P>&nbsp;&nbsp;datatype 
<BR>
&nbsp;&nbsp;T1 =&gt; (T2):nt | ():t; 
<BR>
&nbsp;&nbsp;T2 =&gt; int T1 T1; 
<BR>
&nbsp;&nbsp;T3 =&gt; int T1 
<BR>
&nbsp;&nbsp;enddatatype; 
<BR>
<P>&nbsp;&nbsp;AddNode : T3 -&gt; T1 
<BR>
&nbsp;&nbsp;{ 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:int.new ():T1 = (s:int.new ():t ():t):nt; 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:int.new (s:int.root t:T1.left t:T1.right):T1, 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;GreaterThen s:int.new s:int.root&gt;:bool : { 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True:bool  = (s:int.root t:T1.left &lt;AddNode s:int.new t:T1.right&gt;:T1):nt; 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False:bool = (s:int.root &lt;AddNode s:int.new t:T1.left&gt;:T1 t:T1.right):nt; 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}; 
<BR>
&nbsp;&nbsp;}; 
<BR>
<P>&nbsp;&nbsp;Здесь: 
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;a.. Вся типовая информация выделена курсивом и цветом. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;b.. В определении типов имена конструкторов записаны через двоеточие после аргументов. 
<BR>
&nbsp;&nbsp;Несколько замечаний: 
<BR>
&nbsp;&nbsp;1. Типами помечены все термы; при этом пометки в левой части -- это phyla (АРК: в смысле - предикат?), а пометки в правой части -- конструкторы. (Примитивные типы при подходящей формализации попадают в обе категории). 
<BR>
<P>&nbsp;&nbsp;2. Как мне кажется, любую данную типизацию можно проверить (т.е. существует алгоритм проверки). 
<BR>
<P>&nbsp;&nbsp;3. В общем случае, восстановить типы по нетипизируемой программе невозможно. Достаточно того, что любую рефальскую функцию можно доопределить до всюду определенной с помощью предложения &quot;e.x=e.x&quot; -- и такое предложение часто используется в реальных программах &quot;не по делу&quot;. Однако кажется, что по достаточно богатой частичной типизации восстановить полную типизацию можно. Вопрос: можно ли разумным способом определить понятие &quot;минимальной типизации&quot;, по которой можно однозначно восстановить полную типизацию? 
<BR>
<P>&nbsp;&nbsp;4. Можно представить себе реализацию, в которой каждый терм хранит при себе тип, и программа должна быть полностью типизирована. В такой реализации отождествление будет происходить по-другому: например, образец &quot;e.x s.1 ey&quot; в стандартной реализации отождествляется с выражением &quot;1'A'&quot; (целое и литера) как e.x=пусто, s.1=1, e.y='A'; типизированный же образец &quot;e:Any.x s:char.1 e:Any.y&quot; как e.x=1, s.1='A', e.y=пусто. Но, может быть, это и лучше? 
<BR>
<P>&nbsp;&nbsp;Другой пример (где встречаются открытые переменные) -- слегка модифицированная функция Next из примера &quot;Paths in graph&quot; книги по Рефалу-5: 
<BR>
<P>&nbsp;&nbsp;Next 
<BR>
&nbsp;&nbsp;{ 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.V e.x s.V(e.N) e.y = e.N 
<BR>
&nbsp;&nbsp;}; 
<BR>
<P>&nbsp;&nbsp;Типизированный вариант: 
<BR>
<P>&nbsp;&nbsp;datatype 
<BR>
&nbsp;&nbsp;Vx =&gt; char;    /* Vertex */ 
<BR>
&nbsp;&nbsp;Vxs =&gt; Vx*;    /* Vertices */ 
<BR>
&nbsp;&nbsp;T1 =&gt; (Vxs):vxs;    /* List of vertices in parentheses */ 
<BR>
&nbsp;&nbsp;T2 =&gt; Vx T1;        /* Vertex with a list of successors */ 
<BR>
&nbsp;&nbsp;Gr =&gt; T2*;     /* Graph */ 
<BR>
&nbsp;&nbsp;Arg =&gt; Vx Gr   /* Argument of Next function */ 
<BR>
&nbsp;&nbsp;enddatatype; 
<BR>
<P>&nbsp;&nbsp;Next : Arg -&gt; Vxs 
<BR>
&nbsp;&nbsp;{ 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:Vx.V e:Gr.x s:Vx.V(e:Vxs.N):T1 e:Gr.y = e:Vxs.N 
<BR>
&nbsp;&nbsp;}; 
<BR>
<P>&nbsp;&nbsp;Кстати, последний пример показывает, что для проверки правильности типизации требуется распознавать эквивалентность регулярных выражений (что является разрешимой задачей, но сложной). 
<BR>
<P>&nbsp;&nbsp;Оба примера не очень хороши, поскольку в первом нет открытых переменных, а во втором -- не рекурсивная структура данных. Не знает ли кто-нибудь хорошего примера, в котором есть все? 
<BR>
<P>&nbsp;&nbsp;Очень хотелось бы услышать ваше мнение. Если это кажется интересным, можно было бы рассмотреть формализацию этого подхода. 
<BR>
<P><P>АРК:
<BR>
С учетом замечания выше об XML это может иметь практический смысл (нужно еще добавить в такой язык средства обработки атрибутов).
<BR>
<P>А в более широком контексте (развитие рефала?) это тоже очень интересно. В принципе это направлено на то же, что обсуждается в моем письме в группу refal двухгодичной давности (от 11 августа 1999 года, Subj=&quot;Refal weak typing&quot;). Только решение здесь предлагается несколько иное. Кажется, более общее (то есть система типов помощнее). Если она по-прежнему столь же &quot;разрешима&quot;, то наверно, она предпочтительнее. У меня система более ограничена: допускаются не любые регулярные выражения, а непересекающиеся объединения выражений, составленных из конкатенаций и не более одного итератора - L-выражений. (Впрочем, может быть с учетом композиций, соотношение между нашими системами и более сложное. Надо изучить все это внимательнее.) Я исходил из действующей практики: &quot;разумные&quot; программисты строят только такие структуры. Твое &quot;обобщение&quot; выглядит очень симпатично, и если не слишком зарубается разрешимость разных задач, то я готов за него голосовать. 
<BR>
<P>&nbsp;&nbsp;P.S. Представление графа в последнем примере, конечно, является &quot;ужасным&quot; с точки зрения времени исполнения функции: имея вершину, мы каждый раз ищем связанную с ней информацию -- вместо того, чтобы связать ее один раз при построении графа. В рефале одним из разумных способов представить граф является использование ящиков. Однако образцы не могут заглядывать в ящики, что усложняет программирование. 
<BR>
<P>АРК:
<BR>
Но можно &quot;заглядывать&quot; с помощью условий рефала-5/6/+. Это может показаться громоздким, так как должно быть вынесено из выражения, но на практике вполне удобоваримо.
<BR>
<P>&nbsp;&nbsp;Были ли какие-нибудь интересные мысли по этому поводу? -- 
<BR>
&nbsp;&nbsp;Best regards, 
<BR>
<P>&nbsp;&nbsp;Mikhail 
<BR>
&nbsp;&nbsp;&nbsp;
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0224.html">Mike Potanin: "Re: О типизации рефальских выражений"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0222.html">Mikhail Kovtun: "О типизации рефальских выражений"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0222.html">Mikhail Kovtun: "О типизации рефальских выражений"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0224.html">Mike Potanin: "Re: О типизации рефальских выражений"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0222.html">Arkady Klimov: "Re: О типизации рефальских выражени"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
