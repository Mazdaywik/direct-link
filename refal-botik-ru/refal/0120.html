<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (Arkady.Klimov@supercompilers.com)">
<META NAME="Subject" CONTENT="Re: XML, &quot;holes&quot; and programming styles in R5 and R+">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: XML, &quot;holes&quot; and programming styles in R5 and R+</H1>
<HR>
<P>
<!-- received="Sat Jun 10 23:04:15 2000" -->
<!-- isoreceived="20000610190415" -->
<!-- sent="Mon, 5 Jun 2000 05:42:39 -0400" -->
<!-- isosent="20000605094239" -->
<!-- name="Arkady Klimov" -->
<!-- email="Arkady.Klimov@supercompilers.com" -->
<!-- subject="Re: XML, &quot;holes&quot; and programming styles in R5 and R+" -->
<!-- id="02a101bfced2$65eedc30$2e00a8c0@scpwks02" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="013301bfcdc5$9330bf00$2b460618@cc411095c" -->
<STRONG>Subject: </STRONG>Re: XML, "holes" and programming styles in R5 and R+<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>Arkady.Klimov@supercompilers.com</EM>)<BR>
<STRONG>Date: </STRONG>Mon Jun 05 2000 - 13:42:39 MSD
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#120">[ date ]</A>
<A HREF="index.html#120">[ thread ]</A>
<A HREF="subject.html#120">[ subject ]</A>
<A HREF="author.html#120">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0121.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0119.html">Andrei Klimov: "XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0119.html">Andrei Klimov: "XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0121.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0119.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Добрый день всем!
<BR>
<P>Хочу поделиться некоторыми замечаниями.
<BR>
<P>Сначала обще-философские.
<BR>
<P>У нас уже имеется несколько видов реализаций одного (грубо говоря) и того же
<BR>
языка, а в будущем ожидаются и новые (Рефал-Java, например). И к сожалению
<BR>
(а может, и к счастью) в разных реализациях очень сильно различаются времена
<BR>
исполнения элементарных операций: то , что в одной делается быстро, в другой
<BR>
выполняется медленно и наоборот. Отсюда возникает соблазн переписывания кода
<BR>
под специфику конкретной реализации. Высказывается мнение, что это нужно,
<BR>
чтобы в конретных условиях программа работала as fast as possible.
<BR>
Но я хотел бы заметить, что это вообще говоря, не единственная цель. И
<BR>
действуя в угоду ей, мы возможно, что-то теряем (и не столько скорость на
<BR>
других реализациях, сколько, возможно качество самих программ -
<BR>
идейную чистоту, читабельность и т.п.
<BR>
Я не призываю отказыватся от переписывания, но призываю помнить, чем за это
<BR>
приходится платить, и соразмерять выигрыш с этими возможными потерями.
<BR>
<P>Далее - технические.
<BR>
<P>----- Original Message -----
<BR>
From: &quot;Andrei Klimov&quot; &lt;Andrei.Klimov@supercompilers.com&gt;
<BR>
To: &lt;refal@botik.ru&gt;
<BR>
Sent: Saturday, June 03, 2000 9:37 PM
<BR>
Subject: XML, &quot;holes&quot; and programming styles in R5 and R+
<BR>
<P><P><EM>&gt; Добрый день!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Направляю в refal@botik.ru письмо Сергея Абрамова
</EM><BR>
<EM>&gt; о &quot;дырках&quot; (есть такое понятие в реализации Рефала Плюс) и
</EM><BR>
<EM>&gt; различиях в стиле программирования в Рефале-5 и Рефале Плюс.
</EM><BR>
<EM>&gt; Он написал его в ответ на мой мелкий вопрос Андрею Слепухину и ему,
</EM><BR>
<EM>&gt; нет ли под рукой описания &quot;дырок&quot;. Этот текст, на мой взгляд,
</EM><BR>
<EM>&gt; заслуживает общего внимания и я попросил разрешения Сергея
</EM><BR>
<EM>&gt; форварднуть его всем.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Это обсуждение возникло в таком контексте:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Сейчас активно проводятся работы по проверки рабочей гипотезы,
</EM><BR>
<EM>&gt; что Рефал конкурентоспособен в мире обработки XML-документов.
</EM><BR>
<EM>&gt; Если это так, мы имеем прекрасную возможность продемонстрировать
</EM><BR>
<EM>&gt; миру, что можно дешево производить практически пригодные компиляторы
</EM><BR>
<EM>&gt; с языков для обработки XML-я в Рефал, пользуясь суперкомпилятором Рефала.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Александр Корлюков написал интерпретатор подмножества
</EM><BR>
<EM>&gt; XSLT (XML Style Sheet Transformations), который успешно
</EM><BR>
<EM>&gt; специализируется Рефал-суперкомпилятором Андрея Немытых.
</EM><BR>
<EM>&gt; Таким образом (подмножество) XSLT компилируется в Рефал-5.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Прогон небольших программ на XSLT показал обнадеживающие
</EM><BR>
<EM>&gt; результаты по сравнению со скоростью исполнения на некоторых
</EM><BR>
<EM>&gt; известных реализациях XSLT. Окончательное заключение сделаем,
</EM><BR>
<EM>&gt; когда будут прогнаны большие тестовые программы и выяснено,
</EM><BR>
<EM>&gt; какие наилучшие реализации XSLT имеются в мире, чтобы
</EM><BR>
<EM>&gt; сравниваться именно с ними.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Из реализаций Рефала мы, конечно, должны выбрать ту, которая
</EM><BR>
<EM>&gt; покажет лучший результат на этой задаче. Для этого нужно
</EM><BR>
<EM>&gt; сделать отображение выхода суперкомпилятора в другие Рефалы,
</EM><BR>
<EM>&gt; в частности, Рефал Плюс, максимально учтя его особенности.
</EM><BR>
<EM>&gt; (Этой задачей сейчас занимаются Юрий Климов и Антон Орлов.)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Время работы программы на Рефале Плюс зависит от ряда параметров,
</EM><BR>
<EM>&gt; в частности, от так называемых &quot;дырок&quot;, которые были реализованны
</EM><BR>
<EM>&gt; в переславль-залесской версии Рефала Плюс. По этому поводу и был
</EM><BR>
<EM>&gt; задан невинный вопрос о том, что можно о них почитать.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Определение для тех, кто не знаком с идеей &quot;дырок&quot;:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Def. Параметры &quot;левая и правая дырки&quot; задаются в процентах.
</EM><BR>
<EM>&gt;         Они указывают какое свободное место надо оставлять
</EM><BR>
<EM>&gt;         при размещении нового выражение в свободной памяти:
</EM><BR>
<EM>&gt;         &quot;левая дырка&quot; -- это объем памяти в % от длины этого выражения,
</EM><BR>
<EM>&gt;         который надо оставить свободным перед этим выражением,
</EM><BR>
<EM>&gt;         &quot;правая дырка&quot; -- после него.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;         Дырки используются при конкатенации выражений:
</EM><BR>
<EM>&gt;         если у одного из них имеется соответствующая дырка,
</EM><BR>
<EM>&gt;         вмещающая второе выражение, то копируется только оно
</EM><BR>
<EM>&gt;         (в эту дырку).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Перед тем, как передать слово Сергею, хочу обратиться к Рефал-сообществу
</EM><BR>
<EM>&gt; с призывом к желающим принять участие в теме &quot;Рефал и XML&quot;:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Присоединяйтесь!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Андрей (К).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; PS. Это письмо придет также членам рабочей группы &quot;Рефал-XML&quot;,
</EM><BR>
<EM>&gt; не подписанным на refal@botik.ru. Их адреса не видны, так как я их задал
</EM><BR>
<EM>&gt; в BCC (&quot;blind carbon copy&quot;). Из-за этого их не будет в списке рассылки
</EM><BR>
ответов.
<BR>
<EM>&gt; При желании они смогут проследить за дальнейшей дискуссией в архиве:
</EM><BR>
<EM>&gt; <A HREF="http://www.botik.ru/mail-archive/plus/">http://www.botik.ru/mail-archive/plus/</A>
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; А если хотите подписаться на refal@botik.ru -- обращайтесь ко мне.
</EM><BR>
Спасибо!
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; ----- Original Message -----
</EM><BR>
<EM>&gt; From: Sergei M. Abramov (at home)
</EM><BR>
<EM>&gt; To: Andrei Klimov ; Andrei Slepuhin
</EM><BR>
<EM>&gt; Cc: Yura Klimov
</EM><BR>
<EM>&gt; Sent: Saturday, June 03, 2000 01:41
</EM><BR>
<EM>&gt; Subject: Re: Description of holes wanted
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; День добрый, всем!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; AK&gt; Андрей (С), добрый день!
</EM><BR>
<EM>&gt; AK&gt;
</EM><BR>
<EM>&gt; AK&gt;Я заглянул в Вашу поставку Рефала Плюс и не нашел там объяснений про
</EM><BR>
дырки.
<BR>
<EM>&gt; AK&gt;Есть только упоминание при перечислении параметров. Но мне кажется, что
</EM><BR>
<EM>&gt; AK&gt;несколько лет назад я видел текст про дырки. Он до Вас из Переславля не
</EM><BR>
дошел?
<BR>
<EM>&gt; AK&gt;Или лежит так, что я не заметил?
</EM><BR>
<EM>&gt; AK&gt;
</EM><BR>
<EM>&gt; AK&gt;Сергей, ведь правда, что существовала страничка текста с описанием, что
</EM><BR>
<EM>&gt; AK&gt;такое дырки, да? Или мне мерещится. :-)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Андрей (К), такой текст существовал, но я не думаю, что стоит тратить
</EM><BR>
время на
<BR>
<EM>&gt; его поиски (если он только не лежит в МГУ &quot;под руками&quot;), вот почему:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =1= понимание и реализация дырок убежали вперед того текста;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =2= написать актуальный правильный текст &quot;с нуля&quot; -- дело получаса
</EM><BR>
(которого,
<BR>
<EM>&gt;     конечно не так легко найти в загруженном графике, но все-таки...)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; То есть, я &quot;ЗА&quot; написание нового правильного текста, а не за поиски
</EM><BR>
старого.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Позволю дать Outline:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; ==================8&lt;===================
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; о   Постановка проблемы (описание додырочной эпохи РПлюса):
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- Пояснить о реализации операции конкатенации.  Разные случаи при
</EM><BR>
<EM>&gt;        выполнении конкатенации:
</EM><BR>
<EM>&gt;         *1 ни один из участников не копируется (один из них пустой, они
</EM><BR>
лежат
<BR>
<EM>&gt;            рядом);
</EM><BR>
<EM>&gt;         *2 только один участник копируется (рядом с другим, с нужной
</EM><BR>
стороны
<BR>
<EM>&gt;            есть СВОБОДНОЕ пространство ДОСТАТОЧНОГО размера);
</EM><BR>
<EM>&gt;         *3 оба участника копируются.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- Пример программы (реверс?  побайтное чтение файла?), которая
</EM><BR>
работает
<BR>
<EM>&gt;        К*(К-1)/2 времени.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; о    Понятие дырок, параметры управления дырочным механизмом.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; о    Рекомендации по подбору оптимальных параметров дырок (на примере
</EM><BR>
программы
<BR>
<EM>&gt;      из раздела 1)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- описание ключика, который дает по завершению статистику по
</EM><BR>
использованию
<BR>
<EM>&gt;        памяти и по статистике (частотам) различных случаев при исполнении
</EM><BR>
<EM>&gt;        конкатенации в run-time:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- пример поиска оптимальных значений параметров для программки,
</EM><BR>
описанной в
<BR>
<EM>&gt;        разделе &quot;о1&quot;.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; ==================8&lt;===================
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Юра!  Я вам в вашей борьбе с плохим временем работы той самой программы не
</EM><BR>
<EM>&gt; подсказал хороших дырочных параметров, вот почему:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =1= не бывает универсальных правильных дырочных параметров;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =2= подбирать оптимальные дырочные параметры надо по задаче (а иногда и по
</EM><BR>
<EM>&gt; данным к ней:) -- это процесс не сложный и он базируется на идее
</EM><BR>
минимизации
<BR>
<EM>&gt; выпуклых функций методом подбора шага с адаптивным выбором шага (делим
</EM><BR>
последний
<BR>
<EM>&gt; шак или умножаем его на 2).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; В большинстве случаев важны только два дырочных параметра (левая и правая
</EM><BR>
<EM>&gt; процентная длина дырки--х, у), при этом на время работы программы можно
</EM><BR>
смотреть
<BR>
<EM>&gt; как на выпуклую функцию Т(х,у).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Берете данныем, на которых программа работает существенное но не
</EM><BR>
изматывающее
<BR>
<EM>&gt; вас время и замеряете время: Т(0,0), Т(100,0), Т(0,100), Т(100,100),
</EM><BR>
Т(100,100),
<BR>
<EM>&gt; Т(200,0), Т(0,200), Т(200,200), то бишь в углах сетки:
</EM><BR>
<EM>&gt;
</EM><BR>
<P>АРК:
<BR>
Было бы неплохо, если бы можно было получить грубую оценку уже по одному
<BR>
прогону. Для этого  можно и нужно выдавать статистику не просто о событиях
<BR>
(было копирование или нет) а вообще о плотности распределения исполнявшихся
<BR>
конкатенаций по длинам аргументов (с некоторым шагом в логарифмической
<BR>
шкале). Эта информация не зависит от установленной &quot;дырочности&quot;, а
<BR>
определяется исключительно алгоритмом. Пользуясь ею, я уверен, можно с
<BR>
достаточной точностью прогнозировать относительное ускорение при тех или
<BR>
иных значениях &quot;левой и правой
<BR>
дырочности&quot;. (Совсем точно, к сожалению, не получится, поскольку мы теряем
<BR>
информацию о последовательных конкатенациях.) При этом возможно
<BR>
автоматизировать выбор оптимального решения. И, как подсказал Андрей К.,
<BR>
даже автоматически выполнять этот выбор на лету, постепенно меняя параметры
<BR>
&quot;дырочности&quot; динамически.
<BR>
А качество алгоритмов выбора оценивать затем повторными просчетами при
<BR>
различных фиксированных параметрах &quot;дырочности&quot;.
<BR>
Думаю, это уже потянет на довольно интересную дипломную.
<BR>
<P><EM>&gt;         *   *   *
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;         *   *   *
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;         *   *   *
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Смотря на получившиеся значения и предполагая, что Т выпуклая,
</EM><BR>
соображаете, в
<BR>
<EM>&gt; какой стороне у вас может жить минимум Т, и соответственно с этим:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- либо бьете мелкий квадратик на более мелкие части и измеряете
</EM><BR>
<EM>&gt;        (недостающие) точки, чтобы иметь Т в 9 точках этого квадрата;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;         *   * + *
</EM><BR>
<EM>&gt;             + + +
</EM><BR>
<EM>&gt;         *   * + *
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;         *   *   *
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     -- либо строите (недостающие) 9 точек квадрата 400х400.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Наверное, можно для красоты ненаглядной 3D-сплайнами рисовать поверхность
</EM><BR>
в
<BR>
<EM>&gt; Екселе Т(х,у)... ;-)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Маленькая, симпатичная лабораторка, не правда-ли?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Удачи
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Сергей
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; П.С. =================================================
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; И еще, Юра!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Ту задачу (признаюсь, я не смотрел на Ваш Рефал Плюс текст) считаю очень
</EM><BR>
важной
<BR>
<EM>&gt; для судьбы Рефала Плюс и для судьбы Scp4/Refal-5: разобраться с нею очень
</EM><BR>
нужно.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; При этом, важно не только подобрать дырки и на этом успокоиться... Нет,
</EM><BR>
важно
<BR>
<EM>&gt; сделать от нее (от кусков написанных в стиле Refal-5) сделать несколько
</EM><BR>
шагов
<BR>
<EM>&gt; к Рефалу Плюс.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Да, я не смотрел _Вашу_ программу (и сейчас она у меня не под руками), но
</EM><BR>
я
<BR>
<EM>&gt; смотрел программу, которую мне предоставил А.Конышев (спасибо!).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; И я думаю, что мы говорим про одну и ту же программу (результат
</EM><BR>
суперкомпиляции
<BR>
<EM>&gt; некой обработки XML-я).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Так вот, первый же взгляд на эту программу показывает, что она состоит из
</EM><BR>
<EM>&gt; нескольких (главных) фаз:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;     фаза 1 == считать текстовый файл в память;
</EM><BR>
<EM>&gt;     фаза 2 == перевести XML во внутреннее представление (спарить скобки,
</EM><BR>
тэги
<BR>
<EM>&gt;               представить словами, разобраться с &quot; --&gt; &amp;quote; &amp; --&gt;
</EM><BR>
&amp;amp;)
<BR>
<EM>&gt;     фаза 3 == собственно преобразование;
</EM><BR>
<EM>&gt;     фаза 4 == вывод.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; При этом:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =1= пятерошные фазы:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Функции реализующие 1, 2, 4 -- не суперкомпилировались: как они были
</EM><BR>
написаны на
<BR>
<EM>&gt; Рефале-5 программистом пятерошником, такими они и остались.  Эти функции
</EM><BR>
написаны
<BR>
<EM>&gt; в пятерошном стиле и они могут оказаться ОЧЕНЬ КРИВЫМИ для &quot;прямого&quot;
</EM><BR>
переноса
<BR>
<EM>&gt; в Рефал Плюс.  Их надо бы переписать заново (см. также Сноску (1) в конце
</EM><BR>
<EM>&gt; письма).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; =2= плюсные фазы:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Результатом суперкомпиляции является функция фазы 3.  То есть, была
</EM><BR>
<EM>&gt; некоторая рефал-5-функция, написанная программистом пятерошником, ее
</EM><BR>
<EM>&gt; засунули в суперкомпилятор (с частично заданными данными) и Scp4 эту
</EM><BR>
<EM>&gt; пятерошную программу ПОЛНОСТЬЮ ЗАНОВО переписал.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Общий лозунг: Scp4 на самом деле ХОРОШИЙ ПЛЮСНЫЙ ПРОГРАММИСТ, из под &quot;его
</EM><BR>
рук&quot;
<BR>
<EM>&gt; выходят вполне плюсовые (по стилю и духу) программы.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Фаза 3 (результат работы суперкомпилятора)--это ХОРОШАЯ Рефал Плюс
</EM><BR>
программа
<BR>
<EM>&gt; (как мне показалось).  В ней только осталось раскомментировать описание
</EM><BR>
входного
<BR>
<EM>&gt; формата функций (они есть уже) и, неплохо бы, посчитать еще выходные
</EM><BR>
форматы--и
<BR>
<EM>&gt; вполне сносный код на Рефале Плюс.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Те программы, которые написали программисты-пятерешники и которые не были
</EM><BR>
затем
<BR>
<EM>&gt; переписаны суперкомпилятором (Scp4 по своей природе является хорошим
</EM><BR>
<EM>&gt; РефалаПлюс-программистом), так вот эти программы можно и нужно переписать
</EM><BR>
на
<BR>
<EM>&gt; рефале плюс.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Когда я смотрел, какою техникой делается фаза 2 -- это чисто
</EM><BR>
Рефал-5-стрикт
<BR>
<EM>&gt; техника.  Такой стиль написания поперек горлу Рефалу Плюс и на Рефале Плюс
</EM><BR>
<EM>&gt; открытыми и откатными функциями это все делается лучше и пуще!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Переписывать, переписывать и переписывать!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Чтобы было ясно, о чем это я талдычу, я Вам напишу любимую замену A на B
</EM><BR>
(на
<BR>
<EM>&gt; всех скобочных уровнях) дважды:  как ее могли бы написать
</EM><BR>
программист-пятерешник
<BR>
<EM>&gt; и плюсный-программист.  Итак, маленькая &quot;жемчужинка&quot;...
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /* пример не надуманный, именно так примерно написана
</EM><BR>
<EM>&gt;    по стилю программистом-пятерешником фаза 2
</EM><BR>
<EM>&gt; */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /* рефала-плюс под руками нету, посему, пардон, возможны
</EM><BR>
<EM>&gt;    синт-неточности, но идея, я надеюсь, понятна.
</EM><BR>
<EM>&gt; */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; программист-пятерешник =========================
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; $func ZamenaAB e = e;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; ZamenaAB eX =
</EM><BR>
<EM>&gt;     eX:{
</EM><BR>
<EM>&gt;         'A'   eX--  = 'B' &lt;ZamenaAB eX--&gt;;
</EM><BR>
<EM>&gt;         sY    eX--  = sY  &lt;ZamenaAB eX--&gt;;
</EM><BR>
<EM>&gt;         (eY)  eX--  = (&lt;ZamenaAB eY--&gt;) &lt;ZamenaAB eX--&gt;;
</EM><BR>
<EM>&gt;         /* empty */ = /* empty */;
</EM><BR>
<EM>&gt;     }
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; плюсный-программист =========================
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; $func  RepAB! e = e; /* безоткатная главная функция */
</EM><BR>
<EM>&gt; $func? RepAB? e = e;
</EM><BR>
<EM>&gt; $func? RepTermAB? t = t;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /*  Откатные функции: если замена A -&gt; B _меняет_ аргумент,
</EM><BR>
<EM>&gt;     тогда удача и мы строим измененный аргумент.  Если не
</EM><BR>
<EM>&gt;     изменяет -- тогда просто неудача.
</EM><BR>
<EM>&gt; */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; RepAB! eX = {  &lt;RepAB? eX&gt;;
</EM><BR>
<EM>&gt;                eX;
</EM><BR>
<EM>&gt;             };
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /* Что есть изменяемое выражение и на что оно изменяется? */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; RepAB? eX tA eY,                   /* -- найти первый     */
</EM><BR>
<EM>&gt;             &lt;RepTermAB? tA&gt;::tB,   /*    изменяемый терм? */
</EM><BR>
<EM>&gt;             &lt;RepAB! eY&gt;    ::eZ,   /* -- изменить хвост!  */
</EM><BR>
<EM>&gt;                     eX tB eZ;      /* -- результат        */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /* Что есть изменяемый терм и на что он изменяется? */
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; RepTermAB?  \{ 'A',      'B';
</EM><BR>
<EM>&gt;                (eA),     (&lt;RepAB? eA&gt;);
</EM><BR>
<EM>&gt;             };
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; /////////////////////////////////////////////////////////////
</EM><BR>
<P>АРК:
<BR>
Есть предложения думать о том, можно ли и как такие преобразования
<BR>
осуществлять автоматически. В данном случае речь идет о том, чтобы умный
<BR>
компилятор догадался о двух разных моментах:
<BR>
1. Что терм можно не строить заново, если в нем не было замен.
<BR>
2. Что можно использовать повторно куски выражений; при этом они копируются,
<BR>
но быстро, поскольку может использоваться специальная команда.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; Сноска (1)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Под словами переписать под рефал плюс, я подразумеваю, в том числе и
</EM><BR>
<EM>&gt; возможное (если оно потребуется) расширение рефал-плюс библиотеки.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Например, функцией, которая одним чохом читает ВЕСЬ файл (а не по
</EM><BR>
<EM>&gt; одному символу):
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; $func ReadChars! s.Channel s.Length = e.Chars;
</EM><BR>
<EM>&gt; /* считать s.Length (или до конца файла) символов из файла.
</EM><BR>
<EM>&gt;    Если s.Length &lt; 0 -- считать от текущей позиции до конца
</EM><BR>
<EM>&gt;    файла...
</EM><BR>
<EM>&gt;  */
</EM><BR>
АРК:
<BR>
Я думаю, будет полезнее, если такая функция будет строить не выражение
<BR>
(где на каждый символ уходит 8 байтов), а символ-строку.
<BR>
Такую штуку я когда-то сделал в Рефале-6, назвав ее, кажется, ReadBlock.
<BR>
Оказалось полезным в программках типа форматной печати.
<BR>
(Однако, должен признать, что эта &quot;оптимизация&quot; тоже идет в ущерб
<BR>
идейной чистоте).
<BR>
<P><EM>&gt;
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0121.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0119.html">Andrei Klimov: "XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0119.html">Andrei Klimov: "XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0121.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0119.html">Arkady Klimov: "Re: XML, &quot;holes&quot; and programming styles in R5 and R+"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
