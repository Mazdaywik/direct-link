<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Savtchenko Maxim (savmaxru@gcnet.ru)">
<META NAME="Subject" CONTENT="Conditions in Refal-5.">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Conditions in Refal-5.</H1>
<HR>
<P>
<!-- received="Sat Feb 07 01:50:54 2004" -->
<!-- isoreceived="20040206225054" -->
<!-- sent="Fri, 6 Feb 2004 12:56:59 +0300" -->
<!-- isosent="20040206095659" -->
<!-- name="Savtchenko Maxim" -->
<!-- email="savmaxru@gcnet.ru" -->
<!-- subject="Conditions in Refal-5." -->
<!-- id="002901c3ec97$97a69740$2322140a@home37h2h4mjct" -->
<!-- charset="koi8-r" -->
<STRONG>Subject: </STRONG>Conditions in Refal-5.<BR>
<STRONG>From: </STRONG>Savtchenko Maxim (<EM>savmaxru@gcnet.ru</EM>)<BR>
<STRONG>Date: </STRONG>Fri Feb 06 2004 - 12:56:59 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#424">[ date ]</A>
<A HREF="index.html#424">[ thread ]</A>
<A HREF="subject.html#424">[ subject ]</A>
<A HREF="author.html#424">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0425.html">Anton Orlov: "Re: Conditions in Refal-5."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0423.html">Andrei Klimov: "Установлен фильтр &quot;только от подписчиков&quot;"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0425.html">Anton Orlov: "Re: Conditions in Refal-5."</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Вашему вниманию предлагается краткое изложение одной мыслишки. Идея
<BR>
вобщем-то тривиальная и совершенно не принципиальная. Вполне возможно она
<BR>
уже использовалась в каком-то из диалектов пятого рефала. Дальнейший текст я
<BR>
постарался подготовить в форме статьи, чтобы отдать в какой-нибудь
<BR>
факультетский сборник, если идея окажется свежей и стоящей.
<BR>
<P>Поехали...
<BR>
<P>Новый взгляд на структуру предложений в языке Рефал-5.
<BR>
<P>Традиционно принято считать, что расширенный Рефал (Рефал-5) отличается от
<BR>
базисного Рефала (Рефал-2) наличием where-конструкций (условий) и
<BR>
with-конструкций (блоков). Я предлагаю взглянуть на семантику предложений
<BR>
Рефала-5 иначе.
<BR>
<P>По определению данному В. Ф. Турчиным:
<BR>
<P>&quot;... where-конструкция ... накладывает дополнительное условие на
<BR>
применимость предложения&quot;.
<BR>
<P>&quot;Условие является сопоставляемой парой, где образцом (правым операндом)
<BR>
может служить любое выражение-образец, а аргументом (левым операндом) может
<BR>
являться любое РЕФАЛ-выражение; единственным ограничением для аргумента
<BR>
является то, что он должен включать только те переменные, которые имеют
<BR>
определенные значения на момент проверки условия (связанные переменные). Для
<BR>
условия, которое непосредственно следует за левой частью предложения, это
<BR>
требование означает, что в его аргументе могут использоваться только те
<BR>
переменные, которые появляются в левой части предложения. Выражение-образец
<BR>
в правой части условия может включать как связанные переменные, так и
<BR>
свободные переменные, которые еще не были определены и получают значения в
<BR>
процессе сопоставления.
<BR>
<P>В предложении могут встретиться несколько последовательных
<BR>
where-конструкций. Условия, введенные таким образом, будут вычисляться
<BR>
(проверяться) в заданной последовательности.
<BR>
<P>Пусть задано условие Е : P. Оно вычисляется следующим образом. Во-первых,
<BR>
РЕФАЛ-машина порождает новое поле зрения, помещает Е в это поле и заменяет
<BR>
переменные из Е их значениями. Затем машина работает, как обычно, над этим
<BR>
полем зрения до тех пор, пока его содержимое пассивно. В процессе вычислений
<BR>
могут порождаться дополнительные поля зрения. Когда процесс завершается,
<BR>
результат сопоставляется с образцом Р. При этом сопоставлении те переменные
<BR>
в Р, которые являются уже связанными, заменяются на свои значения, в то
<BR>
время как свободные переменные принимают значения в процессе сопоставления.
<BR>
Если сопоставление является успешным, вычисляется следующее условие; если
<BR>
больше нет условий, имеет место замена левой части предложения на правую его
<BR>
часть. Если сопоставление терпит неудачу, объявляется тупиковая ситуация в
<BR>
предшествующем сопоставлении, (которое могло относиться как к условию, так и
<BR>
к левой части сопоставления с образцом). В этом случае открытые переменные в
<BR>
образце будут удлиняться до тех пор, пока это возможно. Если больше не
<BR>
остается переменных, подлежащих удлинению, тупиковая ситуация снова
<BR>
переносится на предшествующее сопоставление; если это происходит при
<BR>
сопоставлении в левой части, предложение неприменимо, как и в базисном
<BR>
РЕФАЛе, и испытывается следующее предложение. После того как проверка
<BR>
условия завершается успехом либо неудачей, временное поле зрения, созданное
<BR>
для Е, уничтожается, и РЕФАЛ-машина возвращается  к полю зрения, из которого
<BR>
вызывалось Е.
<BR>
<P>Таким образом, каждый образец в последовательности условий может присваивать
<BR>
значения новым переменным, которые становятся связанными в последующих
<BR>
условиях. В конце концов, все эти переменные получат значения и смогут быть
<BR>
использованы в правой части предложения&quot;.
<BR>
<P>В таком же духе описана БНФ предложений в справочнике по Рефалу-5:
<BR>
<P>block ::= sentence
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sentence ;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sentence ;  block
<BR>
<P>sentence ::= left-side  conditions  =   right-side
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left-side  conditions  ,  block-ending
<BR>
<P>left-side ::= pattern
<BR>
<P>conditions ::= empty
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, arg : pattern conditions
<BR>
<P>arg ::= expression
<BR>
<P>right-side ::= expression
<BR>
<P>block-ending ::= arg : { block }
<BR>
<P>То есть, нам предлагается видеть предложения без with-конструкций таким
<BR>
образом:
<BR>
<P>left-side [, arg : pattern] ... [, arg : pattern] = right-side
<BR>
<P>А предложения с with-конструкцией таким образом:
<BR>
<P>left-side [, arg : pattern] ... [, arg : pattern] , arg : { block }
<BR>
<P>Квадратными скобками я выделил &quot;смысловые атомы&quot;. Однако предложения можно
<BR>
разбивать на простые составляющие и по-другому. Я предлагаю в качестве
<BR>
&quot;смысловых атомов&quot; выделять не &quot;условия&quot;, как это делается традиционно, а
<BR>
&quot;базовые предложения&quot;:
<BR>
<P>[pattern , arg] : ... : [pattern , arg] : [pattern = right-side]
<BR>
<P>или
<BR>
<P>[pattern , arg] : ... : [pattern , arg] : { block }
<BR>
<P>Такое разбиение является вполне осмысленным, если термин &quot;базовое
<BR>
предложение&quot; определить следующим образом:
<BR>
<P>Базовое предложение (БП) - вычислитель над пространством полей зрения с
<BR>
одним входом и потенциально бесконечным (N0) числом выходов. Под полем
<BR>
зрения понимается объектное выражение плюс множество всех связанных
<BR>
переменных с их значениями. БП определяется парой &lt;P, A&gt;, где P -
<BR>
выражение-образец, а A - общее выражение. БП работает так:
<BR>
<P>На выходе 0 - результат подстановки в A переменных связанных во входном поле
<BR>
зрения, а так же связанных в результате сопоставления P с входным полем
<BR>
зрения.
<BR>
<P>Результат на выходе N получается из результата на выходе N-1 удлинением
<BR>
открытых переменных в процессе сопоставления. Если больше не остаётся
<BR>
переменных подлежащих удлинению, то на выходе N - неудача.
<BR>
<P>Пример:
<BR>
<P>БП - &lt;e.1 s.X e.2 s.X e.3, e.1 e.2 e.3&gt;
<BR>
<P>Вход - &lt;'diffident', {}&gt;
<BR>
<P>Выходы: 0 - &lt;'iffient', {s.X='d', e.1='', e.2='iffi', e.3='ent'}&gt;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 - &lt;'dffdent', {s.X='i', e.1='d', e.2='ff', e.3='dent'}&gt;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 - &lt;'diident', {s.X='f', e.1='di', e.2='', e.3='ident'}&gt;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 - Fail
<BR>
<P>Легко видеть, что результат применения простого предложения (без where- и
<BR>
with-конструкций) к строке равен результату на выходе 0 применения
<BR>
соответствующего БП к полю зрения, составленному из исходной строки и
<BR>
пустого множества связанных переменных. Для описания более сложных
<BR>
предложений (с условиями и блоками) составим такую БНФ:
<BR>
<P>transformer ::= sentence
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ block }
<BR>
<P>block ::= sentence
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sentence ;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sentence ;  block
<BR>
<P>sentence ::= base-sentence (*)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base-sentence : transformer
<BR>
<P>base-sentence ::= pattern , expression
<BR>
<P>(*) - из соображений совместимости здесь должен быть вариант &quot;pattern =
<BR>
right-side&quot;, однако в нашем случае последнее БП функционально ничем не
<BR>
отличается от остальных, и поэтому его не стоит выделять синтаксически.
<BR>
<P>В полученной модели предложения бывают двух видов: простые (рассмотрены
<BR>
выше) и составные. Алгоритм работы составных предложений описывает следующий
<BR>
псевдокод:
<BR>
<P>Применить base-sentence к входному полю зрения;
<BR>
if (результат на выходе 0 base-sentence - неудача)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Вернуть неудачу;
<BR>
I = 0;
<BR>
while (неудачно применение transformer к результату на выходе I
<BR>
base-sentence)
<BR>
{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;I = I + 1;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (результат на выходе I base-sentence - неудача)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вернуть неудачу;
<BR>
}
<BR>
Вернуть результат transformer;
<BR>
<P>Приведённый выше алгоритм рассматривает предложение как простую рекурсивную
<BR>
структуру (похожую на плоские ЛИСП-списки) и поэтому имеет ряд преимуществ
<BR>
по сравнению с традиционным алгоритмом. Он значительно уменьшает число
<BR>
сущностей (достаточно сравнить старую и новую БНФ) и поэтому более прост для
<BR>
программирования. Он более универсален, так как ему нет нужды различать
<BR>
предложения с with-конструкцией и без неё. По этой же причине он
<BR>
обеспечивает прозрачность блоков для неуспехов (одно из свойств Рефала-6 и
<BR>
Рефала+) чем расширяет функциональность языка.
<BR>
<P>По изложенным причинам я считаю, что эта модель представления предложений
<BR>
является предпочтительной при программировании интерпретаторов Рефала-5 и
<BR>
его диалектов. Я собираюсь использовать её для создания диалекта Рефала-5 в
<BR>
рамках проекта Intelib.
<BR>
<P>Конец статьи.
<BR>
<P>Благодарю за внимание.
<BR>
<P>Andrei Klimov &lt;klimov@keldysh.ru&gt; wrote:
<BR>
<P><EM>&gt; А по существу (если я правильно понял, что Вы имеете в виду),
</EM><BR>
<EM>&gt; я могу только заметить, что подобная работа по &quot;регуляризации&quot;
</EM><BR>
<EM>&gt; синтаксиса Рефала была проделана на рубеже 80-х и 90-х
</EM><BR>
<EM>&gt; при разработке Рефала Плюс, а затем шлифовалась дальше
</EM><BR>
<EM>&gt; в Рефале-6 (теперь это Refal-J -- Рефал над Явой).
</EM><BR>
<P>Андрей, вы наверное обратили основное внимание на фразу:
<BR>
<P>&quot;... в нашем случае последнее БП функционально ничем не отличается от
<BR>
остальных, и поэтому его не стоит выделять синтаксически.&quot;
<BR>
<P>Вопрос синтаксиса в моей идее наименее существенен, замеченное вами имело
<BR>
целью просто чуть-чуть упростить БНФ и никакой смысловой нагрузки не несло.
<BR>
Мне интересно иное - пробовал ли кто-нибудь взглянуть на СЕМАНТИКУ
<BR>
предложений немного с другой стороны. Рассмотреть работу предложения не как
<BR>
&quot;сопоставляем вход с левой частью и заменяем на правую, если выполняются все
<BR>
условия&quot;, а как на работу соединённых в последовательную цепочку &quot;базовых
<BR>
предложений&quot;. По-моему, получается довольно красивая модель мышления, чем-то
<BR>
напоминающая Пролог. Признаюсь в том, что я долго пытался придумать
<BR>
осмысленный пример предложения, которое в новой семантике проще чем в
<BR>
традиционной, но увы, видимо я слишком привык думать по старому :-(. Может
<BR>
вы чем поможете.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0425.html">Anton Orlov: "Re: Conditions in Refal-5."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0423.html">Andrei Klimov: "Установлен фильтр &quot;только от подписчиков&quot;"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0425.html">Anton Orlov: "Re: Conditions in Refal-5."</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
