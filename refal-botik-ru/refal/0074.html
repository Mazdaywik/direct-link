<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Andrey Slepuhin (pooh@msu.ru)">
<META NAME="Subject" CONTENT="Re: Refal+ abstract syntax">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Refal+ abstract syntax</H1>
<HR>
<P>
<!-- received="Fri Dec 17 20:11:59 1999" -->
<!-- isoreceived="19991217171159" -->
<!-- sent="Fri, 17 Dec 1999 18:55:33 +0300" -->
<!-- isosent="19991217155533" -->
<!-- name="Andrey Slepuhin" -->
<!-- email="pooh@msu.ru" -->
<!-- subject="Re: Refal+ abstract syntax" -->
<!-- id="385A5CF5.8D2B9449@msu.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="002601bf489a$5e6209b0$97925bc3@bagirra.rinet.ru" -->
<STRONG>Subject: </STRONG>Re: Refal+ abstract syntax<BR>
<STRONG>From: </STRONG>Andrey Slepuhin (<EM>pooh@msu.ru</EM>)<BR>
<STRONG>Date: </STRONG>Fri Dec 17 1999 - 18:55:33 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#74">[ date ]</A>
<A HREF="index.html#74">[ thread ]</A>
<A HREF="subject.html#74">[ subject ]</A>
<A HREF="author.html#74">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0075.html">Arkady Klimov: "Re: Announce: Refal+ v1.8.1 and future plans"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0073.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0073.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0073.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Arkady Klimov wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Андрей, спасибо, это уже почти то, что надо.
</EM><BR>
<EM>&gt; &quot;У целом&quot; принимается.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; А теперь перейдем к постатейному обсуждению.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Но сначала одно общефилософское замечание.
</EM><BR>
<P>[note snipped]
<BR>
<P>С моей точки зрения главное в АС - это 
<BR>
1) Общий синтаксис для всех рефалов.
<BR>
2) Самодостаточное описание модуля, не требующее никакой дополнительной
<BR>
&nbsp;&nbsp;&nbsp;информации для его компиляции.
<BR>
<P>Во всех своих утверждениях я исхожу именно из этого.
<BR>
<P><EM>&gt; А теперь перейдем к обсуждению по пунктам.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Сначала по изменениям.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; ----- Original Message -----
</EM><BR>
<EM>&gt; From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
</EM><BR>
<EM>&gt; To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
</EM><BR>
<EM>&gt; Cc: Sergei M. Abramov &lt;abram@botik.ru&gt;; &lt;refal@botik.ru&gt;
</EM><BR>
<EM>&gt; Sent: Thursday, December 16, 1999 6:11 AM
</EM><BR>
<EM>&gt; Subject: Re: Refal+ abstract syntax
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; Добрый день всем!
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Извиняюсь за некоторую паузу в дискуссии.
</EM><BR>
<EM>&gt; &gt; Я еще раз внимательно посмотрел на проект абстрактного синтаксиса
</EM><BR>
<EM>&gt; &gt; и сделал свой вариант. Он лежит на
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; <A HREF="http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html">http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html</A>
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; На самом деле принципиальных различий практически нет, так что
</EM><BR>
<EM>&gt; &gt; я думаю, что утверждение окончательного варианта не за горами.
</EM><BR>
<EM>&gt; &gt; Что я изменил (по порядку):
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; 1) t.ProgramFile заменено на t.Module (чисто косметическая замена :-))
</EM><BR>
<EM>&gt; &gt; 2) t.Source удалено - вместо этого нужно использовать прагмы
</EM><BR>
<EM>&gt; &gt;    (тем более, что абстрактный синтаксис не обязательно может
</EM><BR>
<EM>&gt; &gt;    иметь какой-то исходный текст)
</EM><BR>
<EM>&gt; ОК
</EM><BR>
<EM>&gt; &gt; 3) t.Import удалено - на уровне абстрактного синтаксиса нельзя ничего
</EM><BR>
<EM>&gt; &gt;    вытащить из других модулей, т.к. их представление в АС может и не
</EM><BR>
<EM>&gt; &gt;    существовать. Вместо этого каждый объект имеет свой описатель
</EM><BR>
<EM>&gt; &gt;    IMPORT/EXPORT/LOCAL. Если нужно сохранить информацию о том,
</EM><BR>
<EM>&gt; &gt;    из каких модулей импортировались объекты - можно использовать прагмы.
</EM><BR>
<EM>&gt; Это, конечно же, нужно, поэтому непонятно,
</EM><BR>
<EM>&gt; почему для этого надо прибегать к прагмам.
</EM><BR>
<EM>&gt; Причем это нужно будет сохранять не только в АС, но и в загрузочном модуле.
</EM><BR>
<EM>&gt; Нам наконец пора иметь возможность (не обязательно в любой реализации,
</EM><BR>
<EM>&gt; но хотя бы в некоторых) обеспечить цивилизованную динамическую загрузку.
</EM><BR>
<EM>&gt; Цивилизованной я называю такую, когда при загрузке модуля автоматически
</EM><BR>
<EM>&gt; могут быть подзагружены все используемые в нем модули, если они еще
</EM><BR>
<EM>&gt; не загружены. При этом также не нужно будет перечислять имена всех
</EM><BR>
<EM>&gt; модулей для начальной загрузки. (Сейчас в рефале-6 загрузка не является
</EM><BR>
<EM>&gt; цивилизованной)
</EM><BR>
<EM>&gt; Поэтому предлагаю.
</EM><BR>
<EM>&gt; а) Оставить список (USE e.ModuleNames).
</EM><BR>
<EM>&gt; б) В имени функции (REF s.name) разрешить использовать полные имена для
</EM><BR>
<EM>&gt; внешних функций: (REF s.ModuleName s.Name). Имена таких функций s.Name
</EM><BR>
<EM>&gt; могут безболезненно пересекаться с другими локальными или внешними
</EM><BR>
<EM>&gt; фунциями. Можно ввести стадию разрешения, которая будет пополнять все
</EM><BR>
<EM>&gt; ссылки (REF s.Name) до полных.
</EM><BR>
<EM>&gt; в) В s.ModuleName можно использовать точку, которая при превращении в имя
</EM><BR>
<EM>&gt; файла переходит в слеш.
</EM><BR>
<EM>&gt; г) Считать ошибкой, если есть простая ссылка с именем, которое не
</EM><BR>
<EM>&gt; определено
</EM><BR>
<EM>&gt; ни локально, ни в одном из USEd модулей.
</EM><BR>
<EM>&gt; д) Декларации внешних функций пополнить именем модуля, где обнаружено
</EM><BR>
<EM>&gt; определение функции. Эти декларации вставляются на стадии разрешения,
</EM><BR>
<EM>&gt; а изначально могут отсутствовать (см.ниже).
</EM><BR>
<P>На самом деле я уже давно хотел (но боялся) предложить следующее:
<BR>
все имена в момент использования (и разрешить это в исходном синтаксисе
<BR>
-
<BR>
вроде бы ограничений нет) представлять в виде
<BR>
<P>&lt;name&gt; ::= &lt;simple_name&gt; | &lt;module_name&gt;.&lt;simple_name&gt;
<BR>
&lt;module_name&gt; ::= &lt;level_name&gt; | &lt;module_name&gt;.&lt;level_name&gt;
<BR>
<P>При этом алгоритм следующий: если парсер встретил объявление имени -
<BR>
то имя полностью раскрывается со всеми префиксами модулей и помещается в
<BR>
таблицу. Если же имя встретилось в момент использования, то оно ищется
<BR>
в таблице, но не по полному совпадению, а по совпадению с &quot;хвостом&quot;.
<BR>
Если таких совпадений несколько - то ругаться, что имя слабо
<BR>
специфицировано. Получается как в Java или C++... Тогда если в
<BR>
абстрактном синтаксисе оставить только полностью специфицированные имена
<BR>
(а оно так и должно быть), то в принципе можно обойтись и без USE
<BR>
(а также и без linkage-спецификаторов - ведь для каждого имени будет
<BR>
известен модуль, где оно определено).
<BR>
А при компиляции в какой-то формат для динамической загрузки можно,
<BR>
если что, создавать хэш-таблицу нужных модулей. Кроме того так мы не
<BR>
потянем за собой никаких ненужных модулей если кто-то по ошибке
<BR>
подключил их с помощью $use.
<BR>
<P><EM>&gt; &gt; 4) Описания определений всех объектов изменены в соответствии с 3).
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Вспомним философское замечание в начале письма. Данное изменение
</EM><BR>
<EM>&gt; предполагает, что поиск внешних определений произведен на стадии
</EM><BR>
<EM>&gt; до формирования АС, то есть парсером. Я не уверен, что это правильно.
</EM><BR>
<EM>&gt; Можно ли услышать аргументацию за это?
</EM><BR>
<EM>&gt; Мне лично кажется, что парсеру следовало поручить только обработку
</EM><BR>
<EM>&gt; отдельного файла,
</EM><BR>
<EM>&gt; а разрешение внешних имен выполнить как этап обработки в рамках АС.
</EM><BR>
<P>Дело то в том, что модуль может и не существовать в виде АС,
<BR>
а например будет только в откомпилированном виде + include file.
<BR>
И что тогда делать? Парсер абстрактного синтаксиса не должен иметь
<BR>
дело с синтаксисом include file'а конкретного рефала. Здесь есть некая
<BR>
аналогия с .class-файлами в той же Java - там все имена уже полностью
<BR>
специфицированы.
<BR>
<P><EM>&gt; При разрешении имен ведь нужно будет обращаться к интерфейсам других
</EM><BR>
<EM>&gt; модулей, то есть опять же к парсеру от них. (А если интерфейсы не отделены,
</EM><BR>
<EM>&gt; то и к парсеру от самих модулей). А что разрешатель будет иметь
</EM><BR>
<EM>&gt; как исходый материал для своей работы?
</EM><BR>
<EM>&gt; Если же парсер сделать только считывающим один файл, то разрешение имен
</EM><BR>
<EM>&gt; тогда
</EM><BR>
<EM>&gt; формализуется как этап обработки АС-терма, пополняющий его информацией.
</EM><BR>
<EM>&gt; Для некоторых реализаций (компиляторов) он будет не нужен (как например
</EM><BR>
<EM>&gt; для Рефала-6, с учетом его виртуального кода).
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; 5) Добавлен оператор FLUSH - см. мое письмо от 26 ноября в 16:14.
</EM><BR>
<EM>&gt; &gt;    В принципе возможна альтернатива - результаты по умолчанию
</EM><BR>
<EM>&gt; &gt; замещаются,  но есть оператор CONC.
</EM><BR>
<EM>&gt; Я не понимаю, зачем он нужен. Давайте лучше введем расширение для
</EM><BR>
<EM>&gt; t.ResultTerm:
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; t.ResultTerm    ::=    ...
</EM><BR>
<EM>&gt;                             |    t.Block
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; А Flush пусть всегда присутствует &quot;по умолчанию&quot;. Если же нужно
</EM><BR>
<EM>&gt; сконкатенировать
</EM><BR>
<EM>&gt; предыдущий результат со следующим t.Result или t.Block, то сделать это надо
</EM><BR>
<EM>&gt; явно.
</EM><BR>
<P>Можно и так - я абсолютно не возражаю, наверное так даже лучше.
<BR>
<P><EM>&gt; (Возникает вопрос, а как вставить непрозрачный блок? Ответ: поставить
</EM><BR>
<EM>&gt; NOFAIL,
</EM><BR>
<EM>&gt; но не перед блоком, а перед всем результатным выражением.)
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; 6) NOT и ITER сохранены как есть. С моей точки зрения их раскрытие
</EM><BR>
<EM>&gt; &gt;    слишком далеко двигает нас в сторону виртуального кода и может
</EM><BR>
<EM>&gt; &gt;    привести к менее удобному представлению при компиляции в
</EM><BR>
<EM>&gt; &gt;    императивные языки.
</EM><BR>
<EM>&gt; Это нормально. Но не отменяет возможности на ранней стадии компиляции
</EM><BR>
<EM>&gt; устранить NOT и ITER путем их раскрытия в АС же. Я не вижу почему эти
</EM><BR>
<EM>&gt; раскрытия специфичны для какого-то одного типа реализации. Полагаю,
</EM><BR>
<EM>&gt; они универсальны.
</EM><BR>
<P>Я не против возможных расширений, но мне существенно не нравится
<BR>
использование
<BR>
LABEL в раскрытии ITER. Я бы еще согласился на
<BR>
<P>t.Label ::= (LABEL s.LabelName e.Sentence)
<BR>
<P>чтобы получились помеченные предложения, но не LABEL как
<BR>
абстрактная метка.
<BR>
<P><P><EM>&gt; &gt; 7) Немного изменены прагмы - но это не существенно.
</EM><BR>
<EM>&gt; &gt; 8) В конце приведен вариант синтаксиса, в котором есть нераскрытые
</EM><BR>
<EM>&gt; &gt; константы.
</EM><BR>
<EM>&gt; Это хорошо. Неясно теперь, как используются константы в теле программы.
</EM><BR>
<EM>&gt; Например, можно как (REF name), имея в виду, что такая конструкция всегда
</EM><BR>
<EM>&gt; подразумевает ее замену на значение константы по имени name. В случае
</EM><BR>
<EM>&gt; фукнций
</EM><BR>
<EM>&gt; и объектов следует считать, что строятся автоматически определения
</EM><BR>
<EM>&gt; констант,
</EM><BR>
<EM>&gt; значениями которых являются настоящие символы-ссылки.
</EM><BR>
<EM>&gt; Однако, обращаю внимание, что значением константы в общем случае будет
</EM><BR>
<EM>&gt; не обязательно символ, и даже не обязательно терм. Но всегда - объектное
</EM><BR>
<EM>&gt; (в смысле - ground) выражение, которое может быть всюду, включая жесткий
</EM><BR>
<EM>&gt; образец.
</EM><BR>
<P>Как я уже писал - я бы ограничил константы до терма и ввел define'ы,
<BR>
которые раскрываются сразу - на самом деле этого хватает для всего.
<BR>
Я думаю, на первых порах можно константы сразу раскрывать, а позже
<BR>
эту часть синтаксиса довести до ума.
<BR>
<P><EM>&gt; Да, это расширение из Рефала-6. Он означает, что выражение должно быть
</EM><BR>
<EM>&gt; вычислено в момент загрузки. Вычисляется ради побочного эффекта,
</EM><BR>
<EM>&gt; значение игнорируется. Есть одна тонкость: момент вычисления определяется
</EM><BR>
<EM>&gt; положением среди других элементов. При этом нет гарантии, что нижеследующие
</EM><BR>
<EM>&gt; определения функций уже загружены и могут выполняться. Также уже должны
</EM><BR>
<EM>&gt; быть загружены целиком другие модули, которые используются из данного.
</EM><BR>
<EM>&gt; А это, в частности, означает, что в графе использований модулями друг друга
</EM><BR>
<EM>&gt; не должно быть циклов.
</EM><BR>
<EM>&gt; Вообще, я думаю, это полезная конструкция, посколку позволяют делать
</EM><BR>
<EM>&gt; модули,
</EM><BR>
<EM>&gt; которые содержат в себе свою инициализацию (содержимого ящиков, например),
</EM><BR>
<EM>&gt; и не требуют от пользователя вызывать инициализацию явно.
</EM><BR>
<EM>&gt; Кроме того, такие модули могут представлять самодостаточные программы, не
</EM><BR>
<EM>&gt; требующие указывать их входные точки (GO, Main, и т.п.).
</EM><BR>
<P>Это все понятно и хорошо, правда проблем - не оберешься (см. мое
<BR>
следующее
<BR>
письмо).
<BR>
<P><EM>&gt; А теперь несколько новых замечаний-дополнений.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; 1. Для объектов типов BOX, STRING, VECTOR и, возможно, TABLE - вести
</EM><BR>
<EM>&gt; понятие начального значения:
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; t.Object        ::= (s.Linkage s.ObjectType s.ObjectName e.InitialValue)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; e.InitialValue    ::= e.ResultExpression
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; (ограничения - те же, что и для initializer'а.
</EM><BR>
<P>Я уже думал над этим. Только непонятно, кто будет проверять, что
<BR>
начальное значение, скажем для VECTOR имеет корректный формат?
<BR>
И еще - начальное значение возможно только для s.IntLinkage.
<BR>
<P><EM>&gt; 2. PragmaTrace. Отсутствует traceAll. Преднамеренно?
</EM><BR>
<P>Да. TraceAll - это Trace с пустым списком.
<BR>
<P><EM>&gt; 3. В последнем письме от 17.12 ты предлагаешь разделить декларацию и
</EM><BR>
<EM>&gt; определения.
</EM><BR>
<EM>&gt; Мне кажется, это тоже можно вводить как стадию обработки в рамках АС. Но
</EM><BR>
<EM>&gt; может
</EM><BR>
<EM>&gt; компилятору это и не требуется?
</EM><BR>
<P>Компилятору в момент использования функции надо знать ее форматы.
<BR>
Если не разносить декларацию и определение, то потребуется два прохода.
<BR>
<P><EM>&gt; Надеюсь, не слишком утомил?
</EM><BR>
<P>Конечно, нет :-))
<BR>
<P>Всего доброго,
<BR>
Андрей.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0075.html">Arkady Klimov: "Re: Announce: Refal+ v1.8.1 and future plans"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0073.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0073.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0073.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
