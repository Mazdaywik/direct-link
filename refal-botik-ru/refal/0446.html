<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="A.A.Vladimirov (vladimi@mech.math.msu.su)">
<META NAME="Subject" CONTENT="Re: Сравнение по производительности Рефала  другим языкам">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Сравнение по производительности Рефала  другим языкам</H1>
<HR>
<P>
<!-- received="Wed Feb 25 17:42:34 2004" -->
<!-- isoreceived="20040225144234" -->
<!-- sent="Tue, 24 Feb 2004 13:04:25 +0300" -->
<!-- isosent="20040224100425" -->
<!-- name="A.A.Vladimirov" -->
<!-- email="vladimi@mech.math.msu.su" -->
<!-- subject="Re: Сравнение по производительности Рефала  другим языкам" -->
<!-- id="200402241304.25381.vladimi@mech.math.msu.su" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.53L.0402221502590.5287@book.intranet" -->
<STRONG>Subject: </STRONG>Re: Сравнение по производительности Рефала  другим языкам<BR>
<STRONG>From: </STRONG>A.A.Vladimirov (<EM>vladimi@mech.math.msu.su</EM>)<BR>
<STRONG>Date: </STRONG>Tue Feb 24 2004 - 13:04:25 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#446">[ date ]</A>
<A HREF="index.html#446">[ thread ]</A>
<A HREF="subject.html#446">[ subject ]</A>
<A HREF="author.html#446">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0447.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0445.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0444.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0444.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Раз начался разбор идеологических вопросов, влезу.
<BR>
<P><P><EM>&gt;
</EM><BR>
<P><EM>&gt; Мммм... я бы сказал, что в моей фразе ключевым моментом была
</EM><BR>
<P><EM>&gt; событийно-ориентированность. Tcl/Tk позволяет построить GUI,
</EM><BR>
<P><EM>&gt; но я бы не сказал, что результат получается
</EM><BR>
<P><EM>&gt; событийно-ориентированным. Достаточно вспомнить ухищрения, к
</EM><BR>
<P><EM>&gt; которым приходится там прибегать, если нужно выполнить некую
</EM><BR>
<P><EM>&gt; длинную (хотя бы несколько секунд) операцию. Обычно на
</EM><BR>
<P><EM>&gt; ухищрения идти не хочется, в результате чего на время
</EM><BR>
<P><EM>&gt; выполнения операции сам GUI &quot;замирает&quot;, перестает реагировать
</EM><BR>
<P><EM>&gt; на внешние раздражители и даже не хочет отрисовываться. Это
</EM><BR>
<P><EM>&gt; само по себе вполне понятно, и ОО-программа, если не
</EM><BR>
<P><EM>&gt; предпринять специальных мер, поведет себя точно так же. Просто
</EM><BR>
<P><EM>&gt; в ОО-программе принятие соответствующих мер несколько проще
</EM><BR>
<P><EM>&gt; для осмысления (хотя бы потому, что &quot;завершение длинной
</EM><BR>
<P><EM>&gt; операции&quot; - это тоже событие, с точки зрения ОО ничем
</EM><BR>
<P><EM>&gt; принципиально не отличающееся от всяких keypress'ов и
</EM><BR>
<P><EM>&gt; mouseclick'ов).
</EM><BR>
<P><EM>&gt;
</EM><BR>
<P><EM>&gt; Почему Tcl/Tk, тем не менее, действительно применяется для GUI
</EM><BR>
<P><EM>&gt; -- imho, ответ тут в команде pack (ну ооооочень удобно
</EM><BR>
<P><EM>&gt; диалоговые окошки генерировать ;-) В остальном эта штука
</EM><BR>
<P><EM>&gt; действительно для построения GUI подходит очень условно. Или
</EM><BR>
<P><EM>&gt; можно даже так сказать: GUI на Tcl/Tk строится замечательно, а
</EM><BR>
<P><EM>&gt; приложение с GUI - едва-едва. Не более удобно, чем на
</EM><BR>
<P><EM>&gt; практически любом не-ОО языке. То есть можно, но противно.
</EM><BR>
<P><P>Объясните, пожалуйста, почему нельзя, скажем, ввести
<BR>
<P>в Рефале выражение e.spisok_sobytiev и интерпретировать
<BR>
<P>наличие/отсутствие события nechto как 
<BR>
<P>сопоставимость/несопоставимость выражения e.spisok_sobytiev
<BR>
<P>с образцом e.1 ('nechto') e.2 ? 
<BR>
<P><P><P><EM>&gt;
</EM><BR>
<P><EM>&gt; Вот есть язык Лисп. Совершенно ясно, что существует множество
</EM><BR>
<P><EM>&gt; задач, на которых Лисп просто великолепен. Теперь посмотрим на
</EM><BR>
<P><EM>&gt; Common Lisp the Language, ed.2. 1029 страниц. Чего там только
</EM><BR>
<P><EM>&gt; нет, в язык проникли не только откровенно императивные
</EM><BR>
<P><EM>&gt; элементы, но даже ОО-составляющая (CLOS). Наличествуют
</EM><BR>
<P><EM>&gt; массивы, структуры и прочие совершенно нелисповские средства.
</EM><BR>
<P><EM>&gt;
</EM><BR>
<P><EM>&gt; Откуда они там взялись? Возможно, кто-то из более опытных
</EM><BR>
<P><EM>&gt; коллег укажет иные причины, но мне основная причина видится в
</EM><BR>
<P><EM>&gt; стремлении писать на Лиспе целиком сложные программы. В том
</EM><BR>
<P><EM>&gt; числе и программы с пресловутыми GUI, и т.п. Т.е.
</EM><BR>
<P><EM>&gt; позиционировать Лисп как универсальный язык программирования.
</EM><BR>
<P><EM>&gt; В итоге и язык оказывается засорен непойми чем, и до роли
</EM><BR>
<P><EM>&gt; универсального средства он так и не дотягивает, ибо просто по
</EM><BR>
<P><EM>&gt; закону больших чисел в серьезном проекте не может оказаться
</EM><BR>
<P><EM>&gt; достаточного количества задач, на которых оный Lisp удобен.
</EM><BR>
<P><EM>&gt;
</EM><BR>
<P><EM>&gt; Аналогия тут просматривается, пожалуй, с (извините) кухонной
</EM><BR>
<P><EM>&gt; утварью. Существуют, как известно, весьма хитрые и очень
</EM><BR>
<P><EM>&gt; удобные разновидности ножиков: для разделки рыбы, для чистки
</EM><BR>
<P><EM>&gt; овощей, для открывания консервов, для ... (etc.) Однако если
</EM><BR>
<P><EM>&gt; рассматривать каждый из существующих ножей не в контексте
</EM><BR>
<P><EM>&gt; вопроса &quot;удобен для&quot;, а в контексте вопроса &quot;удобен вообще&quot;,
</EM><BR>
<P><EM>&gt; ничего удобнее самого обычного (только качественного) ножа не
</EM><BR>
<P><EM>&gt; найдется. Попытки же приделать к какому-нибудь ножу для устриц
</EM><BR>
<P><EM>&gt; еще и дополнительные лезвия для осуществления остальных
</EM><BR>
<P><EM>&gt; операций приведут к появлению непонятной абракадабры, которая
</EM><BR>
<P><EM>&gt; займет достойное место на полке рядом с моделями вечных
</EM><BR>
<P><EM>&gt; двигателей и прочих &quot;изобретений&quot;.
</EM><BR>
<P><P>Встречный вопрос: а C++ описан на тетрадном листке?
<BR>
<P><P>Описанный вами пример Common Lisp'а, (от себя добавлю
<BR>
<P>Рефал-плюс, да простят меня его поклонники ) --- это не более чем 
<BR>
<P>_извращение_, что Вы и сами признаёте. А в мире C, Pascal и т.д. 
<BR>
<P>сие есть _правило_.  В связи с этим предлагаю совершить
<BR>
<P>небольшой экскурс в историю математики. Когда сформировалось
<BR>
<P>в математике понятие рекурсивной функции (идеологическая
<BR>
<P>основа Pascal'ей)? Правильно - к концу 1930-х годов. Когда 
<BR>
<P>появилось понятие нормального алгорифма? Тоже правильно -
<BR>
<P>к концу 1940-х, когда определение рекурсивных функций и машин
<BR>
<P>Тьюринга у всех уже в зубах навязло. Что - скажете, у Маркова
<BR>
<P>была мания величия, и ему патологически не хотелось
<BR>
<P>использовать чужие конструкции? Как известно, нет - просто
<BR>
<P>рекурсивные функции плохо справляются с _математическими_
<BR>
<P>задачами, да и определение у них корявое.
<BR>
<P><P><P>Засорение языков происходит, ИМХО, именно потому, что
<BR>
<P>использование C приучает к мысли, что тысячестраничные фолианты 
<BR>
<P>спецификаций - это &quot;типа круто&quot;.
<BR>
<P><P><EM>&gt; Это не совсем то, что я имел в виду. То есть и это тоже,
</EM><BR>
<P><EM>&gt; разумеется. Но, на мой взгляд, следует также четко озвучить,
</EM><BR>
<P><EM>&gt; что Лиспу, Рефалу и Прологу _не_подходит_ роль основного языка
</EM><BR>
<P><EM>&gt; в подавляющем большинстве проектов (сразу скажу, что не имею в
</EM><BR>
<P><EM>&gt; виду узкоспециальные проекты - такие, безусловно, бывают; но
</EM><BR>
<P><EM>&gt; исключения лишь подтверждают общее правило). Вместе с тем, в
</EM><BR>
<P><EM>&gt; роли дополнительного языка вся троица очень хорошо будет
</EM><BR>
<P><EM>&gt; смотреться практически в любом проекте.
</EM><BR>
<P><EM>&gt;
</EM><BR>
<P><EM>&gt; Это именно тот тезис, неприятие которого со стороны
</EM><BR>
<P><EM>&gt; сторонников соответствующих языков, с моей точки зрения,
</EM><BR>
<P><EM>&gt; приводит к неприятным последствиям для оных языков. Хотя бы
</EM><BR>
<P><EM>&gt; потому, что в итоге начинают _сравнивать_ Lisp и C++ (сам
</EM><BR>
<P><EM>&gt; наблюдал на студенческом форуме). Не в контексте конкретных
</EM><BR>
<P><EM>&gt; задач, а _вообще_. И такого сравнения Lisp, естественно, не
</EM><BR>
<P><EM>&gt; выдерживает. Потому что если рассматривать _все_ задачи,
</EM><BR>
<P><EM>&gt; решаемые с помощью языков программирования, C++ оказывается
</EM><BR>
<P><EM>&gt; для подавляющего их большинства более удобен, нежели тот же
</EM><BR>
<P><EM>&gt; Lisp. Несмотря на все (чуждые!) возможности, которые в этот
</EM><BR>
<P><EM>&gt; язык воткнули.
</EM><BR>
<P><P>Религия - от первого до последнего слова. Утверждение,
<BR>
<P>будто нормальные алгорифмы менее универсальны, чем
<BR>
<P>рекурсивные функции, отлично смотрелось бы на экзамене
<BR>
<P>по математической логике!
<BR>
<P><P>Далее - к чему ссылки на студенческий (!) форум? Многие 
<BR>
<P>крестьяне, например, считали, что тракторы и комбайны в сельском 
<BR>
<P>хозяйстве не нужны, так как &quot;на лошадке оно способнее&quot;. Что этим 
<BR>
<P>доказано, кроме отсталости самих крестьян?
<BR>
<P><P><P><EM>&gt; Иначе говоря, на каждом языке следует решать те ПОДзадачи,
</EM><BR>
<P><EM>&gt; которые на нем удобно решать. Задача &quot;быть головным языком
</EM><BR>
<P><EM>&gt; проекта&quot; в подавляющем большинстве случаев не подходит для
</EM><BR>
<P><EM>&gt; альтернатывных языков, это ниша императивных и ОО-языков.
</EM><BR>
<P><P>Только потому, что так _привыкли_.
<BR>
<P><P><EM>&gt; Стремление писать все на одном языке - это тоже, на самом
</EM><BR>
<P><EM>&gt; деле, идея из императивного мира; пытаясь играть по этим
</EM><BR>
<P><EM>&gt; правилам, альтернативные языки проигрывают. Что я хочу всем
</EM><BR>
<P><EM>&gt; этим сказать - так это то, что, по моему глубокому убеждению,
</EM><BR>
<P><EM>&gt; играть по этим правилам (пытаться из своего любимого языка
</EM><BR>
<P><EM>&gt; сделать
</EM><BR>
<P><EM>&gt; универсальный) -- совершенно ни к чему и вредно для здоровья
</EM><BR>
<P><P>Да, это вредно для здоровья поклонников C++.
<BR>
<P><P><EM>&gt;
</EM><BR>
<P><EM>&gt;
</EM><BR>
<P><EM>&gt; С наилучшими,
</EM><BR>
<P><EM>&gt; Андрей Столяров
</EM><BR>
<P><P>И Вам того же.
<BR>
<P>Антон Владимиров.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0447.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0445.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0444.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0444.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
