<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Mike Potanin (potanin@mccme.ru)">
<META NAME="Subject" CONTENT="Re: Сравнение по производительности Рефла с другими языкам">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Сравнение по производительности Рефла с другими языкам</H1>
<HR>
<P>
<!-- received="Wed Feb 25 19:01:26 2004" -->
<!-- isoreceived="20040225160126" -->
<!-- sent="Wed, 25 Feb 2004 18:43:33 +0300 (MSK)" -->
<!-- isosent="20040225154333" -->
<!-- name="Mike Potanin" -->
<!-- email="potanin@mccme.ru" -->
<!-- subject="Re: Сравнение по производительности Рефла с другими языкам" -->
<!-- id="Pine.LNX.4.58.0402251804320.1807@mccme.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.53L.0402251705120.1761@book.intranet" -->
<STRONG>Subject: </STRONG>Re: Сравнение по производительности Рефла с другими языкам<BR>
<STRONG>From: </STRONG>Mike Potanin (<EM>potanin@mccme.ru</EM>)<BR>
<STRONG>Date: </STRONG>Wed Feb 25 2004 - 18:43:33 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#449">[ date ]</A>
<A HREF="index.html#449">[ thread ]</A>
<A HREF="subject.html#449">[ subject ]</A>
<A HREF="author.html#449">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0450.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0447.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0451.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0447.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
On Wed, 25 Feb 2004 crocodil@croco.net wrote:
<BR>
<P><EM>&gt; В ООП основное - это смена состояний (об`екта) в ответ на события
</EM><BR>
<EM>&gt; (сообщения). Основа императивного стиля - это смена состояний
</EM><BR>
<EM>&gt; (всей программы или как минимум модуля, поскольку инкапсуляции
</EM><BR>
<EM>&gt; нету) в результате отработки инструкций. И там, и там есть
</EM><BR>
<EM>&gt; понятие состояния. А в логическом и функциональном
</EM><BR>
<EM>&gt; программировании понятия состояния вообще нет. Если оно
</EM><BR>
<EM>&gt; появляется - это уже проникновение императивщины.
</EM><BR>
<P>Инкапсуляция - вопрос скорее дисциплины, нежели парадигмы.
<BR>
А состояние в функциональных и логических языках может быть вырадено
<BR>
адекватно. Наиболее простой способ - уникальные типы Clean и Mercury
<BR>
(состояние внешней среды передается в функцию и возвращается новое
<BR>
состояние, а компилятор следит что бы не появилось двух таких состояний).
<BR>
С помощью некоторого синтаксического сахара программисту не приходится
<BR>
самому передавать такое состояние. Несколько более сложный механизм -
<BR>
монады в Haskell. Но и там можно было бы разработать эффективные
<BR>
инструменты и приемы, если уделить этому хоть часть ресурсов, которые
<BR>
сейчас вкладываются в ООП.
<BR>
Кроме того состояние может хранить параллельный процесс, как это
<BR>
реальзовано в функциональном Erlangе и легко делается на логических
<BR>
языках.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; Что касается событийно-ориентированности, то объектный стиль здесь
</EM><BR>
<EM>&gt; &gt; является скорее костылем. Обрабатывать события и сообщения прекрасно могут
</EM><BR>
<EM>&gt; &gt; процессы или модули без всякого ООПа.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Конечно могут. А можно, например, писать в машинных кодах. Что
</EM><BR>
<EM>&gt; касается удобства ООП для событийно-управляемых архитектур, то
</EM><BR>
<EM>&gt; косвенным подтверждением этого является, например, то, что
</EM><BR>
<EM>&gt; появление первого ОО-языка совпало с появлением первого оконного
</EM><BR>
<EM>&gt; (текстового, естественно) интерфейса пользователя. И, насколько
</EM><BR>
<P>А первые летательные аппараты были с подвижным крылом (птицы). Однако
<BR>
скорость звука они приодолеть так и не смогли, в отличии от жесткого
<BR>
крыла.
<BR>
<P><EM>&gt; мне известно, именно оконный интерфейс был изначальной целью
</EM><BR>
<EM>&gt; проекта Smalltalk, а первый в мире об`ектно-ориентированный язык
</EM><BR>
<EM>&gt; оказался побочным эффектом. Как говорится, что выросло, то
</EM><BR>
<EM>&gt; выросло.
</EM><BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt;    Что бы сами события удобно было
</EM><BR>
<EM>&gt; &gt; представлять ввиде объектов, требуются мультиметоды, а они (из известных
</EM><BR>
<EM>&gt; &gt; мне языков) реалилованы только в Comman Lisp. Без мультиметодов события
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Если я только правильно помню, что такое мультиметод (такая
</EM><BR>
<EM>&gt; виртуальная операция, которая выбирается не по одному аргументу,
</EM><BR>
<EM>&gt; а по двум и больше), то, ей-богу, оно требует слишком больших
</EM><BR>
<EM>&gt; усилий при описании, не говоря уже о понимании. Я, честно говоря,
</EM><BR>
<EM>&gt; сомневаюсь, что смог бы кому-то об`яснить, как этим пользоваться.
</EM><BR>
<P>Основные сложности в событийно-управляемых системах совсем не в реализации
<BR>
обработки события. Событие еще надо доставить обработчику. В результате
<BR>
появляются сложные схемы маршрутизации событий и обработчики часто
<BR>
вынуждены обрабатывать события многих типов. Это приводит к раздутым
<BR>
интерфейсам этих обработчиков. Мультиметоды бы позвоили описать обработку
<BR>
конкретного события конкретным обработчиком не усложняя дизайн системы.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; удобнее представлять ввиде прологовских термов (обычная структура данных
</EM><BR>
<EM>&gt; &gt; в современных декларативных языках, правильное название я не помню).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; _Правильно_ события вообще не представлять данными. Событие - это
</EM><BR>
<EM>&gt; событие. В ООП оно так и есть (событие есть получение об`ектом
</EM><BR>
<EM>&gt; сообщения, или, иначе говоря, вызов метода об`екта; при этом
</EM><BR>
<EM>&gt; событие совершенно не обязано нести на себе какие-то данные, хотя
</EM><BR>
<EM>&gt; это и возможно -- сообщение может иметь параметры, иначе
</EM><BR>
<EM>&gt; говоря, метод может иметь аргументы).
</EM><BR>
<P>Событие еще нужно доставить обработчику. А по дороге оно является не более
<BR>
чем данными.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt;                                                            Для
</EM><BR>
<EM>&gt; &gt; обработки таких структур данных во всех функциональных языках (кроме Lisp)
</EM><BR>
<EM>&gt; &gt; есть очень удобные средства.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; В функциональном языке _не_может_быть_ средства обработки
</EM><BR>
<EM>&gt; события. Потому что нет ни понятия состояния, ни понятия
</EM><BR>
<EM>&gt; побочного эффекта. Кое-как интерактивность сделать в рамках FP
</EM><BR>
<EM>&gt; можно, если ввести ленивые вычисления, но, ей-богу, у меня сия
</EM><BR>
<EM>&gt; концепция в мозгах укладывается с неким трудом.
</EM><BR>
<P>Концепции не сложные. Если не смотреть на них сквозь объектные шоры.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt;               Есть даже императивные (Cyclone) и ОО (Pizza)
</EM><BR>
<EM>&gt; &gt; языки, содержащие это расширения.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; От того, что в языке есть какие-то &quot;средства&quot;, ничего не
</EM><BR>
<EM>&gt; меняется. Определяющим является не общее количество возможностей
</EM><BR>
<EM>&gt; конкретного языка, а тот стиль мышления, который означенный язык
</EM><BR>
<EM>&gt; стимулирует. О событиях мыслить проще в ОО-стиле. И сложнее всего
</EM><BR>
<EM>&gt; - в функциональном, за отсутствием адекватных терминов и по
</EM><BR>
<EM>&gt; причине необходимости прибегать либо к императивным подпоркам,
</EM><BR>
<EM>&gt; либо к совсем уже нетривиальной эмуляции через ленивость.
</EM><BR>
<P>Проще/сложнее - вопрос привычки.
<BR>
<P><EM>&gt; &gt; Раздельная компиляция частей программной системы написаных на разных
</EM><BR>
<EM>&gt; &gt; языках - давно существующая технология. Если есть желание, написать часть
</EM><BR>
<EM>&gt; &gt; программы на Lisp часть на C++ и собрать это в одину систему не сложно.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Ага. И как будут представлены те же S-выражения на C++? Какие там
</EM><BR>
Как указатель на структуру.
<BR>
<P><EM>&gt; будут соглашения о вызовах и данных? Etc. К тому же мы получаем
</EM><BR>
Автоматически генерируемые stabы преобразуют соглашения из одного языка в
<BR>
другой.
<BR>
<P><EM>&gt; использование в одном проекте двух и более систем
</EM><BR>
<EM>&gt; программирования, что тоже не слишком удобно.
</EM><BR>
А для описания граматики yacc использовать неудобно, потому что к нему еще
<BR>
что-то писать приходится.
<BR>
Удобство определяется исключительно желанием/нежеланием осваивать новые
<BR>
инструменты.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; Как показывает практика, этого всего оказывается достаточно,
</EM><BR>
<EM>&gt; чтобы отказаться от идеи многоязычного проекта. Лично я, как
</EM><BR>
<EM>&gt; можно заметить, писать на Лиспе умею и даже неоднократно страдал
</EM><BR>
<EM>&gt; от невозможности вставить кусок на Лиспе в проект на C++, однако
</EM><BR>
<EM>&gt; же трудности многоязычия меня каждый раз останавливали.
</EM><BR>
Практика показывает что очень мало систем пишется в срок и без большого
<BR>
числа ошибок. И язык C++ здесь сыграл не последнюю роль.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; Для этого куча готовых инструментов, от монстров типа CORBA, до
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Трудозатраты на поддержку корбовских об`ектов оказываются больше,
</EM><BR>
<EM>&gt; чем экономия на написании некой части на альтернативном языке.
</EM><BR>
Не такие уж они и большие. Написать и откомпилировать описание интерфейса.
<BR>
Поддерживать репозитарии интерфейсов и реализаций и прочие сервися в
<BR>
болшенстве проектов не обязательно.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; простинького swigа или специализированного GreenCard. И неделают это по
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Конкретно эти не видел. Ссылочки можно, pls, а то на слово
</EM><BR>
<EM>&gt; GreenCard в-основном проблемы иммиграции в Америку вылезают ;-)
</EM><BR>
<P><A HREF="http://www.swig.org/">http://www.swig.org/</A> - для разных языков, в том числе для OCaml и двух
<BR>
Scheme.
<BR>
<A HREF="http://www.haskell.org/greencard/">http://www.haskell.org/greencard/</A> - для взаимодействия Haskell и C.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; тем же причинам, что и не пишут проекты целиком на функциональных языках.
</EM><BR>
<EM>&gt; &gt; Причина - банальное непонимение концепций отличных от ООП-расширения
</EM><BR>
<EM>&gt; &gt; императивной парадигмы.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Вот уж это - совсем вряд ли. Из тех программистов, с которыми мне
</EM><BR>
<EM>&gt; приходилось работать, примерно каждый второй прекрасно знает, что
</EM><BR>
<EM>&gt; такое Лисп и как на нем писать.
</EM><BR>
<P>Знать и уметь - две больших разницы.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0450.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0447.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0451.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0447.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
