<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="crocodil@croco.net (crocodil@croco.net)">
<META NAME="Subject" CONTENT="Re: Сравнение по производительности Рефла с другими языкам">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Сравнение по производительности Рефла с другими языкам</H1>
<HR>
<P>
<!-- received="Wed Feb 25 17:42:37 2004" -->
<!-- isoreceived="20040225144237" -->
<!-- sent="Wed, 25 Feb 2004 17:41:29 +0300 (MSK)" -->
<!-- isosent="20040225144129" -->
<!-- name="crocodil@croco.net" -->
<!-- email="crocodil@croco.net" -->
<!-- subject="Re: Сравнение по производительности Рефла с другими языкам" -->
<!-- id="Pine.LNX.4.53L.0402251705120.1761@book.intranet" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.58.0402241200590.9689@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Сравнение по производительности Рефла с другими языкам<BR>
<EM>crocodil@croco.net</EM><BR>
<STRONG>Date: </STRONG>Wed Feb 25 2004 - 17:41:29 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#447">[ date ]</A>
<A HREF="index.html#447">[ thread ]</A>
<A HREF="subject.html#447">[ subject ]</A>
<A HREF="author.html#447">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0446.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0445.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0449.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0445.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
On Tue, 24 Feb 2004, Mike Potanin wrote:
<BR>
<P><EM>&gt; И вообще, что есть объектно-ориентированность? Классические
</EM><BR>
<EM>&gt; &quot;наследование, полиморфизм, инкапсуляция&quot;? Но все это ни как не связано с
</EM><BR>
<EM>&gt; императивным стилем.
</EM><BR>
<P>В ООП основное - это смена состояний (об`екта) в ответ на события
<BR>
(сообщения). Основа императивного стиля - это смена состояний
<BR>
(всей программы или как минимум модуля, поскольку инкапсуляции
<BR>
нету) в результате отработки инструкций. И там, и там есть
<BR>
понятие состояния. А в логическом и функциональном
<BR>
программировании понятия состояния вообще нет. Если оно
<BR>
появляется - это уже проникновение императивщины.
<BR>
<P><EM>&gt; Что касается событийно-ориентированности, то объектный стиль здесь
</EM><BR>
<EM>&gt; является скорее костылем. Обрабатывать события и сообщения прекрасно могут
</EM><BR>
<EM>&gt; процессы или модули без всякого ООПа.
</EM><BR>
<P>Конечно могут. А можно, например, писать в машинных кодах. Что
<BR>
касается удобства ООП для событийно-управляемых архитектур, то
<BR>
косвенным подтверждением этого является, например, то, что
<BR>
появление первого ОО-языка совпало с появлением первого оконного
<BR>
(текстового, естественно) интерфейса пользователя. И, насколько
<BR>
мне известно, именно оконный интерфейс был изначальной целью
<BR>
проекта Smalltalk, а первый в мире об`ектно-ориентированный язык
<BR>
оказался побочным эффектом. Как говорится, что выросло, то
<BR>
выросло.
<BR>
<P><EM>&gt;    Что бы сами события удобно было
</EM><BR>
<EM>&gt; представлять ввиде объектов, требуются мультиметоды, а они (из известных
</EM><BR>
<EM>&gt; мне языков) реалилованы только в Comman Lisp. Без мультиметодов события
</EM><BR>
<P>Если я только правильно помню, что такое мультиметод (такая
<BR>
виртуальная операция, которая выбирается не по одному аргументу,
<BR>
а по двум и больше), то, ей-богу, оно требует слишком больших
<BR>
усилий при описании, не говоря уже о понимании. Я, честно говоря,
<BR>
сомневаюсь, что смог бы кому-то об`яснить, как этим пользоваться.
<BR>
<P><EM>&gt; удобнее представлять ввиде прологовских термов (обычная структура данных
</EM><BR>
<EM>&gt; в современных декларативных языках, правильное название я не помню).
</EM><BR>
<P>_Правильно_ события вообще не представлять данными. Событие - это
<BR>
событие. В ООП оно так и есть (событие есть получение об`ектом
<BR>
сообщения, или, иначе говоря, вызов метода об`екта; при этом
<BR>
событие совершенно не обязано нести на себе какие-то данные, хотя
<BR>
это и возможно -- сообщение может иметь параметры, иначе
<BR>
говоря, метод может иметь аргументы).
<BR>
<P><EM>&gt;                                                            Для
</EM><BR>
<EM>&gt; обработки таких структур данных во всех функциональных языках (кроме Lisp)
</EM><BR>
<EM>&gt; есть очень удобные средства.
</EM><BR>
<P>В функциональном языке _не_может_быть_ средства обработки
<BR>
события. Потому что нет ни понятия состояния, ни понятия
<BR>
побочного эффекта. Кое-как интерактивность сделать в рамках FP
<BR>
можно, если ввести ленивые вычисления, но, ей-богу, у меня сия
<BR>
концепция в мозгах укладывается с неким трудом.
<BR>
<P><EM>&gt;               Есть даже императивные (Cyclone) и ОО (Pizza)
</EM><BR>
<EM>&gt; языки, содержащие это расширения.
</EM><BR>
<P>От того, что в языке есть какие-то &quot;средства&quot;, ничего не
<BR>
меняется. Определяющим является не общее количество возможностей
<BR>
конкретного языка, а тот стиль мышления, который означенный язык
<BR>
стимулирует. О событиях мыслить проще в ОО-стиле. И сложнее всего
<BR>
- в функциональном, за отсутствием адекватных терминов и по
<BR>
причине необходимости прибегать либо к императивным подпоркам,
<BR>
либо к совсем уже нетривиальной эмуляции через ленивость.
<BR>
<P><P><EM>&gt; &gt; Откуда они там взялись? Возможно, кто-то из более опытных коллег
</EM><BR>
<EM>&gt; &gt; укажет иные причины, но мне основная причина видится в стремлении
</EM><BR>
<EM>&gt; &gt; писать на Лиспе целиком сложные программы. В том числе и
</EM><BR>
<EM>&gt; &gt; программы с пресловутыми GUI, и т.п. Т.е. позиционировать Лисп
</EM><BR>
<EM>&gt; &gt; как универсальный язык программирования. В итоге и язык
</EM><BR>
<EM>&gt; &gt; оказывается засорен непойми чем, и до роли универсального
</EM><BR>
<EM>&gt; &gt; средства он так и не дотягивает, ибо просто по закону больших
</EM><BR>
<EM>&gt; &gt; чисел в серьезном проекте не может оказаться достаточного
</EM><BR>
<EM>&gt; &gt; количества задач, на которых оный Lisp удобен.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Раздельная компиляция частей программной системы написаных на разных
</EM><BR>
<EM>&gt; языках - давно существующая технология. Если есть желание, написать часть
</EM><BR>
<EM>&gt; программы на Lisp часть на C++ и собрать это в одину систему не сложно.
</EM><BR>
<P>Ага. И как будут представлены те же S-выражения на C++? Какие там
<BR>
будут соглашения о вызовах и данных? Etc. К тому же мы получаем
<BR>
использование в одном проекте двух и более систем
<BR>
программирования, что тоже не слишком удобно.
<BR>
<P>Как показывает практика, этого всего оказывается достаточно,
<BR>
чтобы отказаться от идеи многоязычного проекта. Лично я, как
<BR>
можно заметить, писать на Лиспе умею и даже неоднократно страдал
<BR>
от невозможности вставить кусок на Лиспе в проект на C++, однако
<BR>
же трудности многоязычия меня каждый раз останавливали.
<BR>
<P><EM>&gt; Для этого куча готовых инструментов, от монстров типа CORBA, до
</EM><BR>
<P>Трудозатраты на поддержку корбовских об`ектов оказываются больше,
<BR>
чем экономия на написании некой части на альтернативном языке.
<BR>
<P><EM>&gt; простинького swigа или специализированного GreenCard. И неделают это по
</EM><BR>
<P>Конкретно эти не видел. Ссылочки можно, pls, а то на слово
<BR>
GreenCard в-основном проблемы иммиграции в Америку вылезают ;-)
<BR>
<P><EM>&gt; тем же причинам, что и не пишут проекты целиком на функциональных языках.
</EM><BR>
<EM>&gt; Причина - банальное непонимение концепций отличных от ООП-расширения
</EM><BR>
<EM>&gt; императивной парадигмы.
</EM><BR>
<P>Вот уж это - совсем вряд ли. Из тех программистов, с которыми мне
<BR>
приходилось работать, примерно каждый второй прекрасно знает, что
<BR>
такое Лисп и как на нем писать.
<BR>
<P><P><P>С наилучшими,
<BR>
Андрей Столяров
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0448.html">crocodil@croco.net: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0446.html">A.A.Vladimirov: "Re: Сравнение по производительности Рефала  другим языкам"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0445.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0449.html">Mike Potanin: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0445.html">crocodil@croco.net: "Re: Сравнение по производительности Рефла с другими языкам"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
