<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Mike Potanin (potanin@mccme.ru)">
<META NAME="Subject" CONTENT="Re: Ядро Рефал">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Ядро Рефал</H1>
<HR>
<P>
<!-- received="Mon Nov  5 15:01:09 2001" -->
<!-- isoreceived="20011105120109" -->
<!-- sent="Mon, 5 Nov 2001 14:51:49 +0300 (MSK)" -->
<!-- isosent="20011105115149" -->
<!-- name="Mike Potanin" -->
<!-- email="potanin@mccme.ru" -->
<!-- subject="Re: Ядро Рефал" -->
<!-- id="Pine.LNX.4.21.0111051414570.16203-100000@mccme.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="20011103014534.A3320@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Ядро Рефал<BR>
<STRONG>From: </STRONG>Mike Potanin (<EM>potanin@mccme.ru</EM>)<BR>
<STRONG>Date: </STRONG>Mon Nov 05 2001 - 14:51:49 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#261">[ date ]</A>
<A HREF="index.html#261">[ thread ]</A>
<A HREF="subject.html#261">[ subject ]</A>
<A HREF="author.html#261">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0262.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0260.html">dmsidorov@mtu-net.ru: "Refal6 для Linux скомпилирован"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0259.html">Anton Yu. Orlov: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Reply:</STRONG> <A HREF="0259.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
On Sat, 3 Nov 2001, Anton Yu. Orlov wrote:
<BR>
<P><EM>&gt; Имеются в виду проблемы с переносимостью с одного диалекта на
</EM><BR>
<EM>&gt; другой? Но ведь именно с целью решения этих проблем и был
</EM><BR>
Не только. Здесь уже обсуждались сложности сборки Рефала 6 на Linux.
<BR>
У меня были трудности с Рефал+ на FreeBSD. И объщее в этих проблемах было
<BR>
то, что при обработке ошибок транслятор пользовался системно-зависимыми
<BR>
вещами. В Рефал+ например в конструкции языка $trap перехватывается ошибка
<BR>
ввода/вывода, хотя она по идее должна относится к библиотеке и язык про
<BR>
нее знать не должен. Подобная связяность не способствует переносимости.
<BR>
В частности по этому хочется иметь просто реализуемое ядро (хорошо бы,
<BR>
описаное в рамках AS).
<BR>
<EM>&gt; разработан абстрактный синтаксис (AS), в который легко
</EM><BR>
<EM>&gt; компилируются все современные варианты Рефала. Уже давно Андреем
</EM><BR>
<EM>&gt; Слепухиным написан такой компилятор для Рефала+. С компиляцией в
</EM><BR>
<EM>&gt; AS Рефала-5 вообще нет никаких проблем (ну, разве что повышатель
</EM><BR>
<EM>&gt; арности было бы неплохо иметь :), с Рефалом-6 чуть сложнее
</EM><BR>
<EM>&gt; (скажется разница с Рефалом+ в семантике знака &quot;=&quot;, возможно, ещё
</EM><BR>
<EM>&gt; какие-то тонкости), но это тоже должно делаться достаточно
</EM><BR>
<EM>&gt; прямолинейно.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Соответственно предполагается, что отныне все реализации будут
</EM><BR>
<EM>&gt; работать именно с AS - человеку достаточно один раз написать
</EM><BR>
<EM>&gt; программу на любимом диалекте Рефала, после чего он будет иметь
</EM><BR>
<EM>&gt; возможность запустить её на разных рантаймах: списочном,
</EM><BR>
<EM>&gt; векторном, ленивом с мемоизацией, параллельном...
</EM><BR>
<EM>&gt; Абстрактный синтаксис (правда, без комментариев) можно посмотреть
</EM><BR>
<EM>&gt; здесь: <A HREF="http://glade.nmd.msu.ru/~pooh/abstract_syntax.txt">http://glade.nmd.msu.ru/~pooh/abstract_syntax.txt</A>
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; А вот смысла в выделении ядра, которое поддерживалось бы
</EM><BR>
<EM>&gt; суперкомпилятором я не вижу. Каким суперкомпилятором?
</EM><BR>
<EM>&gt; Суперкомпиляторов Рефала уже было не мало, и хочется надеяться,
</EM><BR>
<EM>&gt; что их число будет увеличиваться ;-). И в каждом конкретном
</EM><BR>
<EM>&gt; случае автору суперкомпилятора, конечно, видней над каким именно
</EM><BR>
<EM>&gt; подмножеством Рефала работать. Т.е. автор может сказать, что
</EM><BR>
<EM>&gt; программы на таком подмножестве (ядре) будут данным
</EM><BR>
<EM>&gt; суперкомпилятором отлично обрабатываться, на более широком
</EM><BR>
<EM>&gt; подмножестве не ждите блестящих результатов, а с полным AS данный
</EM><BR>
<EM>&gt; суперкомпилятор, к примеру, вообще не работает. На мой взгляд, не
</EM><BR>
<EM>&gt; стоит выкидывать из языка какие бы то ни было конструкции,
</EM><BR>
<EM>&gt; руководствуясь тем, что это мол никакой суперкомпилятор никогда
</EM><BR>
<EM>&gt; не съест. Ведь теория развивается...
</EM><BR>
Будем ждать и надеятся :-). Только обидно что scp4 не самоприменим....
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; Ленивость я давно предлагою ввести в язык (в моей haskellной реализации
</EM><BR>
<EM>&gt; &gt; была ленивость термов и правого хвоста, для более сложной надо придумывать
</EM><BR>
<EM>&gt; &gt; сложное представление строк). Мемоизация тоже там к месту - при
</EM><BR>
<EM>&gt; &gt; программировании в функциональном стиле на семантику она не влияет, а
</EM><BR>
<EM>&gt; &gt; эффективность может поднять.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Точно также, как и посадить, вплоть до полной неработоспособности
</EM><BR>
<EM>&gt; программы. Уверен, что для любого способа мемоизации, намертво
</EM><BR>
<EM>&gt; заделанного в реализацию, найдётся задача, которая без этой
</EM><BR>
<EM>&gt; мемоизации работала бы на порядок быстрее. Возьмём, к примеру,
</EM><BR>
Уточню что я хотел сказать. Ленивость и мемоизация &quot;почти&quot; не меняет
<BR>
семантики. По этому значительную часть операций с программой (вплодь до
<BR>
суперкомпиляции) в принципе можно было бы производить ни чего не зная про
<BR>
эти особенности реализации. Если реализовывать мемоизацию через ящики, то
<BR>
суперкомпилятору придется не сладко. И не зависимо от развития теории -
<BR>
программу без побочных эфектов всегда анализировать будет легче.
<BR>
По этому и хочется очистить код от не относящемуся к сути программы.
<BR>
Принципиальных проблем я в этом не вижу.
<BR>
<EM>&gt; те же гены - надо работать с выражением огромной длины,
</EM><BR>
<EM>&gt; итеративно изменяя его небольшие куски. Если мы будем
</EM><BR>
<EM>&gt; запоминать всё это выражение после очередной операции, то на
</EM><BR>
<EM>&gt; поддержание списка мемоизированных значений мы угрохаем огромное
</EM><BR>
<EM>&gt; время и очень быстро - всю имеющуюся в наличии память. А при
</EM><BR>
<EM>&gt; заданном наперёд способе мемоизации такое всегда можно
</EM><BR>
<EM>&gt; организовать ;-). Однако, если нет ящиков, то подобная задача
</EM><BR>
<EM>&gt; всё-равно скорей всего окажется не под силу существующим
</EM><BR>
<EM>&gt; рантаймам, хотя они и не ленивы и в них нет встроенной
</EM><BR>
<EM>&gt; мемоизации. Поэтому придётся либо действительно писать рантайм
</EM><BR>
<EM>&gt; спецефически под эту задачу, либо использовать библиотеку на
</EM><BR>
<EM>&gt; C/C++, либо вообще писать на более подходящем языке, чем Рефал.
</EM><BR>
<EM>&gt; Но при наличии ящиков можно легко организовать и своё собственное
</EM><BR>
<EM>&gt; представление выражений и работу с ними, и соответствующую задаче
</EM><BR>
<EM>&gt; мемоизацию. А при наличии в Рефале инструментов, позволяющих
</EM><BR>
Можно конечно поддерживать 2 версии библиотек - эффективную и
<BR>
эффективно суперкомпилируемую (как сейчас делается для Java).
<BR>
Но хорошо бы иметь средство эту задачу упрощающее, типа аннотации
<BR>
программы, что эта функция предпологается мемоизованной, а эта ленивой.
<BR>
При этом реализацию мемоизации и ленивости от самих функций отделить.
<BR>
<EM>&gt; решать задачу с приемлемой эффективностью, меня в сторону С, а
</EM><BR>
<EM>&gt; тем более С++ и силком не затащишь ;-). Ящики - это необходимый
</EM><BR>
<EM>&gt; инструмент при решении задач, где требуется использовать данные,
</EM><BR>
<EM>&gt; для которых рантайм не даёт эффективного представления. Ведь не
</EM><BR>
<EM>&gt; писать же под каждую задачу свой рантайм. Конечно, интерфейс с
</EM><BR>
<EM>&gt; другими языками программирования (С/С++ в первую очередь) - ещё
</EM><BR>
<EM>&gt; более гибкий инструмент и он, безусловно, нужен. В принципе,
</EM><BR>
<EM>&gt; можно и ящики считать просто внешней библиотекой, равноправной с
</EM><BR>
<EM>&gt; теми, которые может написать пользователь. Но на мой взгляд, то
</EM><BR>
<EM>&gt; что они входят именно в Рефал имеет большой плюс: всякие
</EM><BR>
<EM>&gt; программы-метавычислители могут понимать, что имеют дело именно с
</EM><BR>
<EM>&gt; ящиками, а не с произвольными внешними вызовами, и действовать,
</EM><BR>
<EM>&gt; исходя из свойств ящиков. Простейшее, что приходит в голову:
</EM><BR>
<EM>&gt; программу, использующую только явно указанные ссылки на
</EM><BR>
<EM>&gt; глобальные ящики, можно скомпилировать в аналогичную программу
</EM><BR>
<EM>&gt; без ящиков ;-).
</EM><BR>
Интересна более общая задача - с библиотекой связывать описание ее свойств
<BR>
для метавычислителя. Тогда и ящики, и арифменику можно было бы вынести в
<BR>
библиотеку.
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt;                                             Антон.
</EM><BR>
<EM>&gt; 
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0262.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0260.html">dmsidorov@mtu-net.ru: "Refal6 для Linux скомпилирован"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0259.html">Anton Yu. Orlov: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Reply:</STRONG> <A HREF="0259.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
