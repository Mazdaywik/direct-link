<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klark@bagirra.net)">
<META NAME="Subject" CONTENT="Re: Ядро Рефал">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Ядро Рефал</H1>
<HR>
<P>
<!-- received="Fri Nov  2 14:36:56 2001" -->
<!-- isoreceived="20011102113656" -->
<!-- sent="Fri, 2 Nov 2001 14:17:33 +0300" -->
<!-- isosent="20011102111733" -->
<!-- name="Arkady Klimov" -->
<!-- email="klark@bagirra.net" -->
<!-- subject="Re: Ядро Рефал" -->
<!-- id="004801c16390$14b744c0$110d040a@Bagirra" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.21.0111021320080.24289-100000@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Ядро Рефал<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klark@bagirra.net</EM>)<BR>
<STRONG>Date: </STRONG>Fri Nov 02 2001 - 14:17:33 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#254">[ date ]</A>
<A HREF="index.html#254">[ thread ]</A>
<A HREF="subject.html#254">[ subject ]</A>
<A HREF="author.html#254">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0255.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0253.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0253.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0255.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0253.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
----- Original Message -----
<BR>
From: Mike Potanin &lt;potanin@mccme.ru&gt;
<BR>
To: refal &lt;refal@botik.ru&gt;
<BR>
Sent: Friday, November 02, 2001 1:54 PM
<BR>
Subject: Re: Ядро Рефала
<BR>
<P><P>| On Fri, 2 Nov 2001, Arkady Klimov wrote:
<BR>
|
<BR>
| &gt;
<BR>
| &gt; Простота рефала обманчива: в его реализации приходится опираться
<BR>
| &gt; на совершенно специфичиский &quot;рантайм&quot;, включающий особую модель
<BR>
| &gt; данных со своими механизмами сборки мусора и т.п. Понятия рефала уж
<BR>
| &gt; очень оторваны от понятий архитектуры компьютера. Идея массивного
<BR>
| &gt; представления выражений - важный шаг на пути сближения этих двух
<BR>
| &gt; миров.
<BR>
| Представление строк - вопрос второстеменный. В Рефале+ пошли по пути
<BR>
| отделения представления от компилятора. Это создает возможность
<BR>
| использования специольного представления, оптимального для конкретной
<BR>
| задачи.
<BR>
| (Например возьмем биологию - для обработки какого-нибудь гена придется
<BR>
| работать со строками в несколько тысяч символов. В то же время операции
<BR>
| будут ограниченые - вставка/вырезание небольшой подстроки. И массивное и
<BR>
| списковое представление этого не вынесут. В тоже время можно сделать
<BR>
| строки, хорошо с этим работают. Например строка кодируется указателями на
<BR>
| начало и конец и строкой специальных точек, которые обозначают разрыв в
<BR>
| строке или вставку специального элемента - терма, спецсимвола или
<BR>
| ленивого вызова. Это позволит кодировать часто встречающиеся символы одним
<BR>
| байтом и сделает большинство операций дешевыми, но сделает невозможной
<BR>
| сборку мусора.
<BR>
| При желании можно поиграться с представлением служебной строки - например
<BR>
| сделать ее аналогичной основной (чем не метосистемный переход :-)), что
<BR>
| может быть позволит расширить область применения.)
<BR>
| &gt;
<BR>
| &gt; Аккуратный перехват ошибок и весьма осмысленная диагностика всегда
<BR>
| &gt; считались ценнейшим качеством рефала, за которое, не в последнюю
<BR>
| &gt; очередь, его и любили программисты. Типизации же в рефале просто нет,
<BR>
| &gt; что тоже в некотором смысле ценность, и потому на run-time диагностику
<BR>
| &gt; возлагаются задачи, обычно решаемые компиляторами при проверке типов.
<BR>
| &gt; А программирование на рефале в стиле &quot;не порождающих ошибки функций&quot;
<BR>
| &gt; будет только затруднять отладку.
<BR>
| Давайте разделять средства отладки и средства языка. Отладчик может себе
<BR>
| позволить сколь угодно неэффективное представление, лишь бы оно было
<BR>
| удобно для анализа. Отладчик - внешняя по отношению к языку сущьность, и
<BR>
| то что он (отладчик) умеет перехватывать ошибки языку знать не обязятельно
<BR>
| (а по моему даже не желательно).
<BR>
| &gt;
<BR>
| &gt; То, о чем пишет Кондратьев - возможность возбудить перехват
<BR>
| &gt; с осмысленным дампом при зацикливании программы - тоже ценнейшая
<BR>
| &gt; штука, к большому сожалению отстутвующая в большинстве реализаций
<BR>
| &gt; рефала (о других языках и не говорю). А в нынешнем рефале-6 это не
<BR>
| &gt; только диагностика, но и возможность вмешаться в процесс, продолжить
<BR>
| &gt; его по тому или иному пути и т.п. И совсем это не дорого: при опросе
<BR>
| &gt; &quot;датчика&quot; раз на 50-100 шагов замедление не превышает и 1%.
<BR>
| Может это все-таки оставить отладчику? Врядли кто захочит прервать
<BR>
| отлаженую программу, считающюю в течении месяца.
<BR>
<P>Замечу только, что все, что до сих пор называлось &quot;реализациями рефала&quot; -
<BR>
это были в том или ином смысле интерпретаторы (исполнители буквально),
<BR>
то есть отладчики. Эффективная компиляция возникает только
<BR>
как отображение после суперкомпилятора. И там (и только там) об удобствах
<BR>
отладки речи уже не идет.
<BR>
<P>| &gt;
<BR>
| &gt; Ящики? Да без них рефал никто не станет использовать, хотя это и внешняя
<BR>
| &gt; по отношению к языку сущность. В рефале-6, на мой взгляд, они доведены до
<BR>
| &gt; некоторой завершенности. Суперкомпилятору они, конечно, мешают, но
<BR>
| &gt; объектно-ориентированная парадигма &quot;мешает&quot; куда больше, тем не менее
<BR>
| &gt; отбрасывать ее - значит уклоняться от решения проблем, которые ставит
<BR>
| &gt; сама жизнь.
<BR>
| Кто-нибудь занимался анализом использования ящиков? Наверняка есть
<BR>
| небольшое число ситуаций, в которых они полезны. И разработав методологию
<BR>
| их обхождения можно обойтись и без ящиков. Здесь аналогия скорее не с ОО,
<BR>
| а с GOTO. Когда-то казалось что без него ни как - пока Дейкстра не показал
<BR>
| обратное.
<BR>
<P>Если кто-то когда-то использовал &quot;ящики&quot; не по существу, - это еще не повод
<BR>
для их изгнания из языка. Насчет GOTO тоже не все так просто. В результате
<BR>
суперкомпиляции например, как и специализации, получаются существенно
<BR>
&quot;goto-ориентированные&quot; программы, и еще неизвестно, во что нам обойдется
<BR>
отсутствие GOTO в базовом языке их отображения (Яве).
<BR>
<P>| &gt;
<BR>
| &gt; Согласен, что ввод-вывод и прочие внешние операции спорно встраивать в сам язык.
<BR>
| &gt; Но возможность вызывать рефал из чего-то другого здесь не лекарство, так как
<BR>
| &gt; оставляет неудовлетворенной потребность вызывать ИЗ РЕФАЛА что-то другое.
<BR>
| &gt; Наверно, правильнее был бы грамотный интерфейс по вызову из рефала функций
<BR>
| &gt; написанных на других языках (Яве, например), и наоборот.
<BR>
| Да, было бы полезно разработать что то типа Haskellовского ffi. По моему в
<BR>
| Рефал+ этим тоже занимались.
<BR>
| &gt;
<BR>
| &gt; Аркадий.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0255.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0253.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0253.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0255.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0253.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
