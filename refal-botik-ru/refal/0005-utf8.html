<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klimovark@mail.ru)">
<META NAME="Subject" CONTENT="Refal weak typing">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Refal weak typing</H1>
<HR>
<P>
<!-- received="Thu Aug 12 21:08:33 1999" -->
<!-- isoreceived="19990812170833" -->
<!-- sent="Wed, 11 Aug 1999 16:14:06 +0400" -->
<!-- isosent="19990811121406" -->
<!-- name="Arkady Klimov" -->
<!-- email="klimovark@mail.ru" -->
<!-- subject="Refal weak typing" -->
<!-- id="004e01bee3f3$03f8d5f0$97925bc3@bagirra.rinet.ru" -->
<!-- charset="koi8-r" -->
<STRONG>Subject: </STRONG>Refal weak typing<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klimovark@mail.ru</EM>)<BR>
<STRONG>Date: </STRONG>Wed Aug 11 1999 - 16:14:06 MSD
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#5">[ date ]</A>
<A HREF="index.html#5">[ thread ]</A>
<A HREF="subject.html#5">[ subject ]</A>
<A HREF="author.html#5">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0006.html">Leonid F. Belous: "Re: официальный РЕФАЛ сайт"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0004.html">Arkady Klimov: "Refal-6 on the WEB"</A>
<!-- nextthread="start" -->
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
На вчерашнем Рефал-семинаре в ИПМ Виктор К. затронул вопрос о типизации
<BR>
рефала как теоретической проблемы:
<BR>
<P>Необходимость типизации ощущается  как желание иметь твердую почву под
<BR>
ногами при написании больших программ. Но рефал - изначально
<BR>
нетипизированный язык, который этим дает большую свободу, и в этом также его
<BR>
преимущество перед такими изначально строго типизированными языками как
<BR>
языки ML, Haskel и тп. Хотелось бы эту свободу не потерять. Поэтому подход к
<BR>
типизации Рефала должен отличаться от подхода в ML. Типизатор должен уметь:
<BR>
1. Выводить типы насколько это возможно и сообщать о них программисту. В
<BR>
крайних случаях оставлять все как есть (то есть что все перменные могут
<BR>
принимать любые допустимые значения).
<BR>
2. Допускать описания типов некоторых функций и их аргументов на некотором
<BR>
языке (аннотаций) и проверять их состоятельность, предупреждая о
<BR>
несоответствиях..
<BR>
<P>Далее я высказываю свое видение этой проблемы, точнее ее конкретизацию.
<BR>
<P>Я не буду говорить о типизации типа Хиндли-Милнера (параметрический
<BR>
полиморфизм для функций высших порядков). Возможно этот вопрос можно будет
<BR>
поставить после. Сейчас меня интересует типизация данных, когда тип можно
<BR>
понимать просто как ограничение на множество допустимых значений. Такая
<BR>
задача также вытекает из практики: многим приходилось описывать в
<BR>
комментариях что-то входе синтаксисов для обрабатываемых данных и мечтать о
<BR>
том, чтобы компилятор проверял, что функции применяются к правильным данным.
<BR>
<P>Я решил это написать, имея несколько целей:
<BR>
1. Сверить свое понимание проблемы с пониманим других.
<BR>
2. Подтолкнуть молодых, дав по возможности более точную постановку.
<BR>
3. Облегчить свою голову.
<BR>
<P>Продолжаю.
<BR>
Чтобы задачи о типизации можно было решать, надо договориться о системе
<BR>
типов (языке описания типов). Этот вопрос может решаться по разному. Есть
<BR>
два общих требованиея к его решению:
<BR>
1. Система типов должна быть достаточно богатой (детальной), чтобы
<BR>
удовлетворить практические потребности.
<BR>
2. Она должна быть достаточно бедной (грубой), чтобы можно было надеяться с
<BR>
ней алгоритмически совладать (в частности,  эффективно разрешать равенство,
<BR>
включение и т.п.).
<BR>
Как всегда, требования противоречивы и наша задача - найти удачный
<BR>
компромисс.
<BR>
<P>Первый пункт можно конкретизировать так: хочется, чтобы система типов была
<BR>
замкнутой относительно некоторых операций, в частности:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- объединение: T1 | T2
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- произведение (для нас - конкатенация): T1 T2
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- заключение в скобки (T)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;- рекурсия - разрешимость системы уравнений
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(T1, ..., Tn) = F(T1, ...,Tn),
<BR>
&nbsp;где F- типовое выражение, использующее вышеприведенные операции.
<BR>
<P>Однако, если все это разрешить то система получится явно неподъемной. Она
<BR>
включает КС-языки, для которых включение, если я не ошибаюсь, неразрешимо. В
<BR>
любом случае, работать с такими широкими типами будет непросто. Поэтому, и
<BR>
так мне казалось всегда, возможность выполнения названных операций надо
<BR>
как-то ограничить, но не слишком сильно. И вот вчера, когда я уже ехал в
<BR>
метро,  мне пришла в голову идея наложить некоторое довольно элегантное
<BR>
ограничение, которое и разрешимость восстановит и необходимую свободу
<BR>
сохранит.
<BR>
<P>Формулировка очень простая: используем понятие L-образца - образец, в
<BR>
котором нет открытых e-переменных и нет повторных. (Повторные символы тоже
<BR>
запретим.) Такие образцы можно записывать без индексов переменных, например:
<BR>
A s (t e t) e. Вспомним теорему В.Турчина (1974), о том, что пересечение
<BR>
L-образца L с любым образцом P представимо в виде конечного объединения
<BR>
образцов Pi, где каждый Pi получается из P некоторой L- подстановкой Si,
<BR>
причем все Si попарно ортогональны (надеюсь, понятно, что это такое). В
<BR>
частности, предикаты непустоты пересечения, включения L-образцов легко
<BR>
разрешимы.
<BR>
<P>Теперь основная формулировка: описание набора типов { Ti }  есть система
<BR>
уравнений видa:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ti = определение-типа
<BR>
где правая часть - это система попарно непересекающихся L-образцов, в
<BR>
которых каждая переменная может быть аннотирована одним из Ti. Важно, что
<BR>
условие непересечения образцов проверяется без учета аннотирующих типов! Еще
<BR>
парочка естественных ограничений:
<BR>
1. Правая часть не может содержать (то есть состоять из единственного)
<BR>
образца e. (Такой тип легко исключить.)
<BR>
2. Если тип T аннотирует переменную терма (символа), то все образцы правой
<BR>
части описания T должны быть сужениями переменной терма (символа).
<BR>
Аннотацию e-переменной типом T будет записывать как e:T.
<BR>
<P>Примеры:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbols = &lt;empty&gt; | s e:symbols
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multibracket = '*' e | (e:multibracket) e
<BR>
<P>В качестве сахара, можно также разрешить в правых частях писать и выражения
<BR>
от типов, например: symbols | multibracket, но с условием: вхождение имени T
<BR>
(в отличие от переменной e:T) означает неободимость подставить определение T
<BR>
и раскрыть результат в объединение образцов, после чего должны получиться
<BR>
непересекающиеся образцы. В частности, приведенное выражение не выдерживает
<BR>
этой проверки, так как оно раскрывается в набор
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;empty&gt; | s e | '*' e | (e) e
<BR>
Видно, что второй и третий образцы пересекаются.
<BR>
И вообще, про операции объединения и конкатенации надо сказать, что они
<BR>
выполняются не всегда. Более точно:
<BR>
1. Объединение: объединяем определения, и если нет пересекающихся образцов,
<BR>
то ОК, иначе нельзя.
<BR>
2. Конкатенация: берутся все попарные конкатенации, и если получается набор
<BR>
непересекающихся L-образцов, то OK, иначе нельзя.
<BR>
Когда операцию точно выполнить нельзя, надо прибегать к обобщению (как его
<BR>
делать - отдельная задача).
<BR>
<P>Вот и все про определение. А теперь можно переходить к задачам.
<BR>
<P>1. Проверить включение: T1&lt;=T2. Уверен, что проблема разрешима. Проверяя
<BR>
включения в обе стороны, получаем равенство.
<BR>
Воможные трудности: один и тот же тип, например симовольная строка можно
<BR>
определить как слева направо, так и справа налево. Надо распознавать эти
<BR>
типы как равные.
<BR>
<P>2. Тип (типовое выражение) подается на произвольный образец P для
<BR>
отождествления. Надо получить типы для переменных образца P. Не знаю,
<BR>
разрешимо ли это точно. Надеюсь, что да. Возможны трудности с повторными
<BR>
переменными образца P - может от таковых придется отказаться (обобщая
<BR>
образец P).
<BR>
<P>3. Дана полная типизация программы, то есть для каждой функции указаны типы
<BR>
аргумента и результата. Проверить состоятельность.
<BR>
<P>4. Дана программа. Построить состоятельную типизацию, возможно более узкую.
<BR>
<P>5. Дана частичная типизация. Дополнить ее и проверить.
<BR>
<P>Не задачи, а конфетки! Особенно первая. Хорошо бы кто-то из молодых за это
<BR>
взялся. Какие мнения?
<BR>
<P>Аркадий.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0006.html">Leonid F. Belous: "Re: официальный РЕФАЛ сайт"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0004.html">Arkady Klimov: "Refal-6 on the WEB"</A>
<!-- nextthread="start" -->
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
