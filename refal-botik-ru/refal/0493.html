<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (arklimov@keldysh.ru)">
<META NAME="Subject" CONTENT="Re: Re[3]: параллельный РЕФА">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Re[3]: параллельный РЕФА</H1>
<HR>
<P>
<!-- received="Fri Apr 02 11:02:22 2004" -->
<!-- isoreceived="20040402070222" -->
<!-- sent="Wed, 31 Mar 2004 14:22:21 +0400" -->
<!-- isosent="20040331102221" -->
<!-- name="Arkady Klimov" -->
<!-- email="arklimov@keldysh.ru" -->
<!-- subject="Re: Re[3]: параллельный РЕФА" -->
<!-- id="002301c4170a$0db08300$8704000a@Swan" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="000d01c416cf$87dff7e0$07aee8c1@botik.ru" -->
<STRONG>Subject: </STRONG>Re: Re[3]: параллельный РЕФА<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>arklimov@keldysh.ru</EM>)<BR>
<STRONG>Date: </STRONG>Wed Mar 31 2004 - 14:22:21 MSD
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#493">[ date ]</A>
<A HREF="index.html#493">[ thread ]</A>
<A HREF="subject.html#493">[ subject ]</A>
<A HREF="author.html#493">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0494.html">Дмитрий Подкорытов: "предложение по составу дистрибутивов РЕФАЛ"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0492.html">Arkady Klimov: "Re: Re[2]: параллельный РЕФА"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0490.html">Sergei M. Abramov: "Re[3]: параллельный РЕФА"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0499.html">Sergei M. Abramov: "Re: Re[3]: параллельный РЕФА"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0490.html">Arkady Klimov: "Re: Re[3]: параллельный РЕФА"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
----- Original Message ----- 
<BR>
From: &quot;Sergei M. Abramov&quot; &lt;abram@botik.ru&gt;
<BR>
To: &lt;refal@botik.ru&gt;
<BR>
Sent: Wednesday, March 31, 2004 7:23 AM
<BR>
Subject: Re[3]: параллельный РЕФАЛ
<BR>
<P><P>| Дмитрий,
<BR>
|
<BR>
| &gt; Да простят меня люди, знающие английский.
<BR>
|
<BR>
| Аркадий им владеет в совершенстве.  Но вопрос в другом:
<BR>
|
<BR>
| # (2) Parallel use of sentences for matching,
<BR>
| ! Паралельное сопоставление выражений с образцом
<BR>
|
<BR>
| Что это значит?  Имеем правила:
<BR>
|
<BR>
| F   L1 = R1;
<BR>
|     L2 = R2;
<BR>
|     ...
<BR>
|     LN = RN;
<BR>
|
<BR>
| Имеем вызов &lt;F Oe&gt;
<BR>
|
<BR>
| В параллель запускаем вычисление N клэшей:
<BR>
|
<BR>
| pmK == ( Oe : LK --&gt; { substK | $fail } )
<BR>
|
<BR>
| Вопросы Алика безусловно правильные:
<BR>
|
<BR>
| &gt; имелось ли здесь в виду изменение семантики, а именно что сработает
<BR>
| произвольное
<BR>
| &gt; применимое предложение (скажем, которое раньше других вернет успешный
<BR>
| результат),
<BR>
| &gt; не обязательно самое первое по порядку написания из применимых(?).
<BR>
|
<BR>
| (вариант 1) Если pmK успешно (не $fail) завершилось раньше других, заменяем
<BR>
| ли мы &lt;F Oe&gt; на RK/substK (делая убиения всех иных pmJ)?
<BR>
|
<BR>
| (* О, как любилось в студентчестве каждую функцию завершать предложением:
<BR>
|
<BR>
|         eX = ...
<BR>
| *)
<BR>
|
<BR>
| (вариант 1+) Если pmK успешно (не $fail) завершилось раньше других, то мы
<BR>
| заменяем &lt;F Oe&gt; на RK/substK но не убиваем вычисления и всех остальных
<BR>
| веток? (ну, кто вспомнил функ-логическое программирование, XSG, справедливую
<BR>
| семантику и т.п.).
<BR>
|
<BR>
| Общее замечание про 1 и 1+: Алик!  Вспомним про ортогонализацию левых частей
<BR>
| предложений. Правда она делается таким приемем, что не ясно, что можно
<BR>
| параллелить в дереве отождествления (спуск по дереву выборов)?
<BR>
|
<BR>
| (вариант 2) Мы всегда ждем завершения ВСЕХ pmI (I=1..N), затем выбираем
<BR>
| K=min{ I : pmI =/= $fail } и заменяем &lt;F Oe&gt; на RK/substK.
<BR>
|
<BR>
| (вариант 2+) Мы всегда ждем завершения ВСЕХ pmI (I=1..N), затем выбираем
<BR>
| K=min{ I : pmI =/= $fail } и заменяем &lt;F Oe&gt; на RK/substK.  Однако в работе
<BR>
| pmI делаем усовершенствования: (a) приоритет (на захват процессоров) pmI
<BR>
| падает при росте I; (2) если некоторый pmI завершился с результатом не $fail
<BR>
| то он делает убивство всем незавершенным pmJ (I&lt;J&lt;=N).
<BR>
<P>Совершенно верно. По большому счет есть два семантически различных (!)
<BR>
варианта: 1 и 2. Вариант 2 семантически равносилен стандартному последовательному.
<BR>
Вариант 1 - нет. Более того, вариант 1 вносит в семантику недериминизм.
<BR>
(И это единственное место, где появляется недерминизм: результат зависит
<BR>
от взаимных скоростей исполнения разных веток).
<BR>
И вот я спрашиваю, хотим мы этого или нет? Вопрос не риторический,
<BR>
ответы могут быть разные.
<BR>
<P>А в варианте 2 еще много тонкостей. В частности, что считать
<BR>
&quot;завершением PmI? Окончание только отождествления?
<BR>
А если у нас рефал-5 или Плюс с условиями сложными?
<BR>
Тогда может это &quot;завершение блока/функции&quot;?
<BR>
То есть мы рождаем отдельный подпроцесс для каждого
<BR>
ветвления в теле функции - пока хотя бы один не дойдет
<BR>
до значения функции. Кто первый, тот и герой. Только тогда
<BR>
всех остальных (вычисляющих данный вызов функции/блок) - в утиль.
<BR>
Это называется &quot;ИЛИ-параллелизм&quot;. В отличие от &quot;И-параллелизма&quot;,
<BR>
предполагаемого в п.п. (1) и (3).
<BR>
(Кстати, важно, чтобы автор кода мог указать, какие ветвления могут
<BR>
так параллелиться. По умолчанию, чтобы все было по-стандартному.)
<BR>
В этом варианте ИЛИ-параллелиться могут не только &quot;мелкие&quot; операции PmI
<BR>
(это реплика на PS ниже), а возможно очень даже толстые ветки с вызовами
<BR>
других функций. То есть ценность в этом есть немалая.
<BR>
Особенно может быть полезно в задачах с перебором.
<BR>
Более того: ускорение теоретически может достигаться большее,
<BR>
чем количество наличных процессоров (если повезет).
<BR>
И все же, возвращаюсь к исходному вопросу - этого ли мы хотим?
<BR>
<P>|
<BR>
| Про варианты 2* Алик сказал:
<BR>
|
<BR>
| &gt; ... И тогда получается, что этот параллелизм здесь порождает
<BR>
| &gt; много лишней работы: нормально надо вычислять лишь образцы до первого
<BR>
| применимого,
<BR>
| &gt; а при параллелизме - всегда все.
<BR>
|
<BR>
| или почти все (см. 2+).  Алик!  В паралельном мире на это идут.  &quot;Если
<BR>
| процессоры все равно простаивают, почему бы не...&quot;  и т.д.  Называется
<BR>
| &quot;спекулятивные вычисления&quot;.  Эйсымонт их любит упоминать...
<BR>
<P>Да, идут, я понимаю. Но ты сам же написал оговорку
<BR>
&quot;если процессоры простаивают &quot;. А если не простаивают?
<BR>
Если мы уже накопали столько параллелизма, что проблемы
<BR>
простоя нет?
<BR>
<P>Аркадий
<BR>
<P>|
<BR>
| Удачи
<BR>
|
<BR>
| С.
<BR>
| PS.  По мне не в этом счастье.  Параллелить надо не мелкие операции -- pmI,
<BR>
| а вызовы функций.  Причем все, не обязательно те, у которых аргумент
<BR>
| &quot;готов&quot;.
<BR>
|
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0494.html">Дмитрий Подкорытов: "предложение по составу дистрибутивов РЕФАЛ"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0492.html">Arkady Klimov: "Re: Re[2]: параллельный РЕФА"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0490.html">Sergei M. Abramov: "Re[3]: параллельный РЕФА"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0499.html">Sergei M. Abramov: "Re: Re[3]: параллельный РЕФА"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0490.html">Arkady Klimov: "Re: Re[3]: параллельный РЕФА"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:25:00 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
