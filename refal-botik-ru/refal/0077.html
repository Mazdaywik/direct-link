<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Andrey Slepuhin (pooh@msu.ru)">
<META NAME="Subject" CONTENT="Re: Refal+ abstract syntax">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Refal+ abstract syntax</H1>
<HR>
<P>
<!-- received="Mon Dec 20 16:08:49 1999" -->
<!-- isoreceived="19991220130849" -->
<!-- sent="Mon, 20 Dec 1999 14:28:13 +0300" -->
<!-- isosent="19991220112813" -->
<!-- name="Andrey Slepuhin" -->
<!-- email="pooh@msu.ru" -->
<!-- subject="Re: Refal+ abstract syntax" -->
<!-- id="385E12CD.722E07B7@msu.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="002001bf494b$17a61b40$97925bc3@bagirra.rinet.ru" -->
<STRONG>Subject: </STRONG>Re: Refal+ abstract syntax<BR>
<STRONG>From: </STRONG>Andrey Slepuhin (<EM>pooh@msu.ru</EM>)<BR>
<STRONG>Date: </STRONG>Mon Dec 20 1999 - 14:28:13 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#77">[ date ]</A>
<A HREF="index.html#77">[ thread ]</A>
<A HREF="subject.html#77">[ subject ]</A>
<A HREF="author.html#77">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0078.html">Sergei M. Abramov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0084.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0076.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Добрый день всем!
<BR>
<P>Arkady Klimov wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Андрей,
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; ----- Original Message -----
</EM><BR>
<EM>&gt; From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
</EM><BR>
<EM>&gt; To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
</EM><BR>
<EM>&gt; Cc: &lt;refal@botik.ru&gt;
</EM><BR>
<EM>&gt; Sent: Friday, December 17, 1999 6:55 PM
</EM><BR>
<EM>&gt; Subject: Re: Refal+ abstract syntax
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; Arkady Klimov wrote:
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; Андрей, спасибо, это уже почти то, что надо.
</EM><BR>
<EM>&gt; &gt; &gt; &quot;У целом&quot; принимается.
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; А теперь перейдем к постатейному обсуждению.
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; Но сначала одно общефилософское замечание.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; [note snipped]
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; С моей точки зрения главное в АС - это
</EM><BR>
<EM>&gt; &gt; 1) Общий синтаксис для всех рефалов.
</EM><BR>
<EM>&gt; &gt; 2) Самодостаточное описание модуля, не требующее никакой дополнительной
</EM><BR>
<EM>&gt; &gt;    информации для его компиляции.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Во всех своих утверждениях я исхожу именно из этого.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; А я спорю с пунктом 2). См. ниже.
</EM><BR>
<P>Я не вижу, как можно выполнить 1) без 2). 
<BR>
<P><EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; На самом деле я уже давно хотел (но боялся) предложить следующее:
</EM><BR>
<EM>&gt; &gt; все имена в момент использования (и разрешить это в исходном синтаксисе
</EM><BR>
<EM>&gt; &gt; -
</EM><BR>
<EM>&gt; &gt; вроде бы ограничений нет) представлять в виде
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; &lt;name&gt; ::= &lt;simple_name&gt; | &lt;module_name&gt;.&lt;simple_name&gt;
</EM><BR>
<EM>&gt; &gt; &lt;module_name&gt; ::= &lt;level_name&gt; | &lt;module_name&gt;.&lt;level_name&gt;
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; При этом алгоритм следующий: если парсер встретил объявление имени -
</EM><BR>
<EM>&gt; &gt; то имя полностью раскрывается со всеми префиксами модулей и помещается в
</EM><BR>
<EM>&gt; &gt; таблицу. Если же имя встретилось в момент использования, то оно ищется
</EM><BR>
<EM>&gt; &gt; в таблице, но не по полному совпадению, а по совпадению с &quot;хвостом&quot;.
</EM><BR>
<EM>&gt; &gt; Если таких совпадений несколько - то ругаться, что имя слабо
</EM><BR>
<EM>&gt; &gt; специфицировано. Получается как в Java или C++... Тогда если в
</EM><BR>
<EM>&gt; &gt; абстрактном синтаксисе оставить только полностью специфицированные имена
</EM><BR>
<EM>&gt; &gt; (а оно так и должно быть), то в принципе можно обойтись и без USE
</EM><BR>
<EM>&gt; &gt; (а также и без linkage-спецификаторов - ведь для каждого имени будет
</EM><BR>
<EM>&gt; &gt; известен модуль, где оно определено).
</EM><BR>
<EM>&gt; &gt; А при компиляции в какой-то формат для динамической загрузки можно,
</EM><BR>
<EM>&gt; &gt; если что, создавать хэш-таблицу нужных модулей. Кроме того так мы не
</EM><BR>
<EM>&gt; &gt; потянем за собой никаких ненужных модулей если кто-то по ошибке
</EM><BR>
<EM>&gt; &gt; подключил их с помощью $use.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; С идеей разрешить составные имена, в том числе в исходном синтаксисе,
</EM><BR>
<EM>&gt; согласен.
</EM><BR>
<EM>&gt; Когда именно ругаться - надо уточнять. Искать &quot;по хвостам&quot; - тоже
</EM><BR>
<EM>&gt; сомнительный
</EM><BR>
<EM>&gt; принцип. Ява ищет от начал, другое дело, что некоторые модули могут быть
</EM><BR>
<EM>&gt; открыты
</EM><BR>
<EM>&gt; на использование их имен простым образом (предложением import, по-нашему -
</EM><BR>
<EM>&gt; use).
</EM><BR>
<P>Именно это я и имею в виду. И тогда сравнение происходит с &quot;хвостами&quot;.
<BR>
В целом я говорю о следующем: если у нас есть
<BR>
$use A.B.C.D X.Y.D;
<BR>
и в обоих модулях определена функция F, то мы ее в момент использования
<BR>
функции писать A.B.C.D.F, C.D.F, X.Y.F - все будет в порядке. Если же мы
<BR>
напишем просто F или D.F - нас должны обругать, что функция слабо
<BR>
специфицирована.
<BR>
<P><EM>&gt; Идея, что в АС следует оставить только полные имена тоже правильная, если
</EM><BR>
<EM>&gt; мы
</EM><BR>
<EM>&gt; договорились о том, что разрешение имен парсером исходного текста уже
</EM><BR>
<EM>&gt; сделано.
</EM><BR>
<P>Ага.
<BR>
<P><EM>&gt; Однако мне сам этот подход не вполне нравится. Альтернатива состоит в том,
</EM><BR>
<EM>&gt; что
</EM><BR>
<EM>&gt; собственно парсер использует только один исходный файл, а разрешение
</EM><BR>
<EM>&gt; имен приоизводится отдельно как следующая фаза. Я бы предложил попытаться
</EM><BR>
<EM>&gt; провести в жизнь оба подхода, то есть сделать как бы два АС: первичный и
</EM><BR>
<EM>&gt; вторичный.
</EM><BR>
<EM>&gt; Отличаться они будут только аспектами, связанными с именами и модулями.
</EM><BR>
<EM>&gt; Если в каком-то встретятся непреодолимые трудности - ну тогдо можно и
</EM><BR>
<EM>&gt; отказаться.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; По поводу тезиса 2), что компилятор из АС должен мочь все сделать на основе
</EM><BR>
<EM>&gt; информации об одном АС-модуле, у меня тоже есть сомнения, поскольку одному
</EM><BR>
<EM>&gt; компилятору (как нынешний Рефал-6) достаточно и исходного модуля,
</EM><BR>
<EM>&gt; Рефалу Плюс требуется кое-что от определений других модулей (форматы,
</EM><BR>
<EM>&gt; например),
</EM><BR>
<P>Вот-вот. Поэтому парсер и должен включать эту информацию в АС.
<BR>
<P><EM>&gt; а где гарантия, что новому компилятору не понадобится еще
</EM><BR>
<EM>&gt; какая-нибудь информация (например, о вызываемости функциями друг друга).
</EM><BR>
<P>Значит эта информация должна быть в будущем включена в АС. Изменять
<BR>
АС в сторону расширения никто не запрещает.
<BR>
<P><EM>&gt; Я бы хотел, чтобы еще кто-то высказался по этому вопросу. (Сережа Абрамов,
</EM><BR>
<EM>&gt; ау!).
</EM><BR>
<P>Присоединяюсь к пожеланию. И вообще, такое ощущение, что кроме нас троих
<BR>
дискуссия никому не интересна :-(((
<BR>
<P><EM>&gt; Коротко повторю:
</EM><BR>
<EM>&gt; Есть выбор из следующих вариантов:
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; A) Парсер использует как вход только один файл, выдает АС-модуль
</EM><BR>
<EM>&gt; с неразрешенными именами.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; B) Парсер использует данный файл и все его окружение и выдает
</EM><BR>
<EM>&gt; АС-модуль, в котором все имена разрешены и имеется вся информация
</EM><BR>
<EM>&gt; об их определениях, достаточная для (любого?) компилятора.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; C) Реализуются оба варианта, то есть реализуется вариант A), который затем
</EM><BR>
<EM>&gt; дополняется до B) написанием отдельной фазы (StaticElaboration), которая
</EM><BR>
<EM>&gt; соберет всю информацию, достаточную для дальнейшей компиляции.
</EM><BR>
<P>Проблема в том, что фаза StaticElaboration должна быть своя для каждого
<BR>
рефала. Зачем тогда принципиально нужен АС в варианте а) ???
<BR>
<P><EM>&gt; А суть варианта C) в том, чтобы сейчас выработать и опубликовать оба
</EM><BR>
<EM>&gt; стандартных
</EM><BR>
<EM>&gt; представления АС, как до StaticElaboration, так и после него. Как вы
</EM><BR>
<EM>&gt; понимете,
</EM><BR>
<EM>&gt; я за 3).
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; &gt; 4) Описания определений всех объектов изменены в соответствии с 3).
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; Вспомним философское замечание в начале письма. Данное изменение
</EM><BR>
<EM>&gt; &gt; &gt; предполагает, что поиск внешних определений произведен на стадии
</EM><BR>
<EM>&gt; &gt; &gt; до формирования АС, то есть парсером. Я не уверен, что это правильно.
</EM><BR>
<EM>&gt; &gt; &gt; Можно ли услышать аргументацию за это?
</EM><BR>
<EM>&gt; &gt; &gt; Мне лично кажется, что парсеру следовало поручить только обработку
</EM><BR>
<EM>&gt; &gt; &gt; отдельного файла,
</EM><BR>
<EM>&gt; &gt; &gt; а разрешение внешних имен выполнить как этап обработки в рамках АС.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Дело то в том, что модуль может и не существовать в виде АС,
</EM><BR>
<EM>&gt; &gt; а например будет только в откомпилированном виде + include file.
</EM><BR>
<EM>&gt; &gt; И что тогда делать? Парсер абстрактного синтаксиса не должен иметь
</EM><BR>
<EM>&gt; &gt; дело с синтаксисом include file'а конкретного рефала. Здесь есть некая
</EM><BR>
<EM>&gt; &gt; аналогия с .class-файлами в той же Java - там все имена уже полностью
</EM><BR>
<EM>&gt; &gt; специфицированы.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; Ну, class-файлы, это уже результат компиляции, а никак не AC.
</EM><BR>
<P>Это просто в качестве примера.
<BR>
<P><EM>&gt; А в целом
</EM><BR>
<EM>&gt; данный аргумент (&quot;что модуль может и не существовать в виде AC&quot; -
</EM><BR>
<EM>&gt; то есть в виде исходного текста, да?) говорит больше в пользу моего
</EM><BR>
<EM>&gt; подхода:
</EM><BR>
<EM>&gt; парсер работает только одним исходным файлом, тем, для которого его
</EM><BR>
<EM>&gt; попросили. Если компилятору понадобилась дополнительная информация - он
</EM><BR>
<EM>&gt; ее возьмет либо в ранее скомпилированных им структурах, которые этот
</EM><BR>
<EM>&gt; компилятор и понимает, либо запустит парсер для других исходных модулей.
</EM><BR>
<P>Да не знает компилятор ничего про этот парсер. На то и АС, чтобы быть
<BR>
общим для всех рефалов. Я могу вообще придумать свой собственный
<BR>
рефал-- или, скажем, сделать парсер, который генерирует рефальский АС
<BR>
из другого функционального языка 8-)). Откуда парсер будет браться,
<BR>
для каких файлов его вызывать?  Да и от исходных модулей - одни
<BR>
include'ы.
<BR>
<P><EM>&gt; &gt; &gt; &gt; 6) NOT и ITER сохранены как есть. С моей точки зрения их раскрытие
</EM><BR>
<EM>&gt; &gt; &gt; &gt;    слишком далеко двигает нас в сторону виртуального кода и может
</EM><BR>
<EM>&gt; &gt; &gt; &gt;    привести к менее удобному представлению при компиляции в
</EM><BR>
<EM>&gt; &gt; &gt; &gt;    императивные языки.
</EM><BR>
<EM>&gt; &gt; &gt; Это нормально. Но не отменяет возможности на ранней стадии компиляции
</EM><BR>
<EM>&gt; &gt; &gt; устранить NOT и ITER путем их раскрытия в АС же. Я не вижу почему эти
</EM><BR>
<EM>&gt; &gt; &gt; раскрытия специфичны для какого-то одного типа реализации. Полагаю,
</EM><BR>
<EM>&gt; &gt; &gt; они универсальны.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Я не против возможных расширений, но мне существенно не нравится
</EM><BR>
<EM>&gt; &gt; использование
</EM><BR>
<EM>&gt; &gt; LABEL в раскрытии ITER. Я бы еще согласился на
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; t.Label ::= (LABEL s.LabelName e.Sentence)
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; чтобы получились помеченные предложения, но не LABEL как
</EM><BR>
<EM>&gt; &gt; абстрактная метка.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; Какая, собственно, разница?
</EM><BR>
<P>Такая, что, скажем, в Java нельзя просто сказать goto на метку,
<BR>
а метка используется только в break и continue; для этого метка
<BR>
привязана к соответствующему блоку. В моем варианте помеченное
<BR>
предложение будет переходить в помеченный блок - компиляция будет
<BR>
проще. А метка сама по себе - ну что с ней делать?
<BR>
<P><EM>&gt;  А правильно ли я понимаю, что в твоем варианте
</EM><BR>
<EM>&gt; после t.Label не должно быть продолжения предложения? (То есть t.Label
</EM><BR>
<EM>&gt; тогда
</EM><BR>
<EM>&gt; должен относиться к так называемым терминирующим операторам, таким как
</EM><BR>
<EM>&gt; FAIL.)
</EM><BR>
<P>Если вопрос о о том, можно ли в этом случае снять с LABEL скобки -
<BR>
то ответ отрицательный.
<BR>
<P><EM>&gt; И тот же вопрос относительно Try и Iter (в последнем варианте).
</EM><BR>
<P>Ответ тот же самый. Конечно можно написать, скажем,
<BR>
TRY e.TrySentence CATCH e.CatchSentence ENDTRY но зачем??? А потом
<BR>
руками считать уровни вложенности? Другой вопрос, что можно написать
<BR>
(TRY e.TrySentence CATCH e.CatchSentence) или
<BR>
TRY t.TrySentence t.CatchSentence - это вопрос вкуса. Мне больше
<BR>
нравится
<BR>
выделять сложные операторы скобками и не использовать лишних тегов,
<BR>
но если есть принципиальные возражения - я не буду слишком сильно
<BR>
настаивать.
<BR>
<P><EM>&gt; Замечу, что в своем (предыдущем) варианте я старался минимизировать
</EM><BR>
<EM>&gt; количество таких операторов. Поэтому и у Error нет явного аргумента, его
</EM><BR>
<EM>&gt; аргумент - все окончание предложения.
</EM><BR>
<P>Ммм... Насколько я помню, в Рефале+ аргумент у ERROR - это объектное
<BR>
выражение,
<BR>
и если мы его только этим ограничим, то для ERROR надо бы ввести
<BR>
отдельный
<BR>
синтаксис. Если же мы допустим, что аргументом у ERROR может быть
<BR>
значение
<BR>
любого предложения, то тогда можно оставить все как есть (вопрос: что
<BR>
будет,
<BR>
если при вычислении аргумента ERROR возникнет новый ERROR? ;-) )
<BR>
<P><EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Как я уже писал - я бы ограничил константы до терма и ввел define'ы,
</EM><BR>
<EM>&gt; &gt; которые раскрываются сразу - на самом деле этого хватает для всего.
</EM><BR>
<EM>&gt; &gt; Я думаю, на первых порах можно константы сразу раскрывать, а позже
</EM><BR>
<EM>&gt; &gt; эту часть синтаксиса довести до ума.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; Я хотел сказать, что, если уж имена-константы определяются в АС, то надо
</EM><BR>
<EM>&gt; не забыть указать, как они там используются.
</EM><BR>
<P>Угу. И поэтому хотелось бы услышать мнения на эту тему. Лично меня,
<BR>
наверное, вполне бы устроило раскрытие констант парсером, а остальное
<BR>
можно и сэмулировать (тем более имея t.Initializer).
<BR>
<P><EM>&gt; &gt; &gt; 1. Для объектов типов BOX, STRING, VECTOR и, возможно, TABLE - вести
</EM><BR>
<EM>&gt; &gt; &gt; понятие начального значения:
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; t.Object        ::= (s.Linkage s.ObjectType s.ObjectName
</EM><BR>
<EM>&gt; e.InitialValue)
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; e.InitialValue    ::= e.ResultExpression
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; (ограничения - те же, что и для initializer'а.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Я уже думал над этим. Только непонятно, кто будет проверять, что
</EM><BR>
<EM>&gt; &gt; начальное значение, скажем для VECTOR имеет корректный формат?
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; В момент засылки, то есть при загрузке.
</EM><BR>
<P>Ну, если ни у кого возражений нет - я e.InitialValue введу.
<BR>
Вопрос: а не делает ли это t.Initializer слегка obsolete?
<BR>
<P><EM>&gt; &gt; &gt; 3. В последнем письме от 17.12 ты предлагаешь разделить декларацию и
</EM><BR>
<EM>&gt; &gt; &gt; определения.
</EM><BR>
<EM>&gt; &gt; &gt; Мне кажется, это тоже можно вводить как стадию обработки в рамках АС.
</EM><BR>
<EM>&gt; Но
</EM><BR>
<EM>&gt; &gt; &gt; может
</EM><BR>
<EM>&gt; &gt; &gt; компилятору это и не требуется?
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Компилятору в момент использования функции надо знать ее форматы.
</EM><BR>
<EM>&gt; &gt; Если не разносить декларацию и определение, то потребуется два прохода.
</EM><BR>
<EM>&gt; Арк:
</EM><BR>
<EM>&gt; А разве результат парсера не является объектным выражением, целиком
</EM><BR>
<EM>&gt; находящимся оперативной памяти? Тогда лишний проход не составляет
</EM><BR>
<EM>&gt; проблемы. А некоторые компиляторы все равно будут делать лишние проходы.
</EM><BR>
<EM>&gt; Например, компилятор в Яву может интересоваться графом вызовов для
</EM><BR>
<EM>&gt; оптимизации.
</EM><BR>
<P>Ну, если так... И если гарантировать, что _все_ компиляторы будут
<BR>
сразу загружать АС в память целиком - тогда можно и первый вариант
<BR>
(кстати, с эстетической точки зрения он мне нравится больше :-) ).
<BR>
<P>Всего доброго,
<BR>
Андрей.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0078.html">Sergei M. Abramov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0076.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0084.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0076.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
