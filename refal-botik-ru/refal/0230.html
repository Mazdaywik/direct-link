<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klark@bagirra.net)">
<META NAME="Subject" CONTENT="Re: Лямбда-исчисление в рефале">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Лямбда-исчисление в рефале</H1>
<HR>
<P>
<!-- received="Tue Aug 28 19:50:36 2001" -->
<!-- isoreceived="20010828155036" -->
<!-- sent="Tue, 28 Aug 2001 18:52:08 +0300" -->
<!-- isosent="20010828155208" -->
<!-- name="Arkady Klimov" -->
<!-- email="klark@bagirra.net" -->
<!-- subject="Re: Лямбда-исчисление в рефале" -->
<!-- id="001801c12fd9$d6461390$929943c2@Bagirra" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.21.0108271259440.23282-100000@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Лямбда-исчисление в рефале<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klark@bagirra.net</EM>)<BR>
<STRONG>Date: </STRONG>Tue Aug 28 2001 - 19:52:08 MSD
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#230">[ date ]</A>
<A HREF="index.html#230">[ thread ]</A>
<A HREF="subject.html#230">[ subject ]</A>
<A HREF="author.html#230">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0231.html">Sergei M. Abramov (at home): "Re: Лямбда-исчисление в рефале."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0229.html">Mike Potanin: "Re: Лямбда-исчисление в рефале"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0227.html">Mike Potanin: "Лямбда-исчисление в рефале"</A>
<!-- nextthread="start" -->
<LI><STRONG>Reply:</STRONG> <A HREF="0227.html">Arkady Klimov: "Re: Лямбда-исчисление в рефале"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
----- Original Message -----
<BR>
From: Mike Potanin &lt;potanin@mccme.ru&gt;
<BR>
To: &lt;refal@botik.ru&gt;
<BR>
Sent: Monday, August 27, 2001 12:38 PM
<BR>
Subject: Лямбда-исчисление в рефале.
<BR>
<P><P>|
<BR>
|  С моей точки зрения очень неестественно то что в функциональном языке
<BR>
| не поддерживается лямбда-исчисление. Может это вызладет как попытка
<BR>
| сделать из рефала haskell, но я решил расширить рефал в порядке
<BR>
| эксперемента. В общем то добавилась всего одна существенная конструкция (и
<BR>
| одна дополнительная для оптимизации) и расширилась семантика функции Mu.
<BR>
| Я добавил к существующим типам (символ, целое и терм) еще один -
<BR>
| замыкание (closure). Синтаксис естественный
<BR>
| Adder {
<BR>
|  s1 = { s2 = &lt;Add s1 s2&gt;; };
<BR>
| }
<BR>
<P>Как я понял, речь идет о введении лямбда-абстракции в рефал. Согласен с Сергеем
<BR>
Абрамовым, что нужно как-то синтаксически разнести ее с обычными блоками.
<BR>
В контесте рефала-6 я давно подумываю об аналогичном расширении со знаком '*'
<BR>
перед '{'.
<BR>
Правда, пример тут убогий. Фактически оно тут использовано лишь для закарривания.
<BR>
Это же самое в рефале выразимо гораздо проще:
<BR>
&nbsp;Adder {
<BR>
&nbsp;&nbsp;s1 = *Add s1 ;
<BR>
&nbsp;}
<BR>
<P>Я пишу как в рефале-6: звездочка перед именем делает его символом-ссылкой (в Р+ это знак '&amp;').
<BR>
Поскольку далее можно написать &lt;&lt;Adder 1&gt; 2&gt; и получить 3.
<BR>
[ Ежели желаемо в роли функции иметь всегда терм, то пишите
<BR>
<P>&nbsp;Adder {
<BR>
&nbsp;&nbsp;s1 = (*Add s1) ;
<BR>
&nbsp;}
<BR>
<P>Результат будет тот же, поскольку в рефале-6 &lt;(e1) e2&gt; вычисляется как &lt;e1 e2&gt;.]
<BR>
<P>Пример похитрее будет такой:
<BR>
<P>Map sf sx ey = &lt;sf ex&gt; &lt;Map sf ey&gt;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf =;
<BR>
<P>Halfs ex = &lt;Map *{ sd = &lt;DIV sd 2&gt; } ex&gt;;
<BR>
<P>| И с замыканием можно работать функцией Mu
<BR>
|  &lt;Mu &lt;Adder 1&gt; 2&gt;
<BR>
<P>А функцию Mu здесь не при чем. Она семантически как бы состоит из двух частей:
<BR>
1) разрешения имени (т.е. идентификатора) в контексте модуля - превращения его в
<BR>
(ссылку на) функцию и 2) последующего вызова этой функции.
<BR>
А поскольку результат &lt;Adder ...&gt; - замыкание, то есть сама функция, а не ее имя
<BR>
(идентификатор), то и писать надо просто &lt;&lt;Adder1&gt; 2&gt;. Правда в рефале-5 такая
<BR>
запись невозможна (в отличие от рефалов 6 и +).
<BR>
<P>| Второе расширение не принципиально - замыкания можно использовать вместо
<BR>
| имени функции
<BR>
|  &lt;{ s2 = &lt;Add 1 s2&gt;; } 2&gt;
<BR>
| эквивалентно
<BR>
|  &lt;Mu { s2 = &lt;Add 1 s2&gt;; } 2&gt;
<BR>
| но у меня реализованно немного эффективней (и на пол-часа раньше :-)).
<BR>
| Что же это дает?
<BR>
| Во первых это покрывает with-блок
<BR>
|  e1, e1 : { блок };
<BR>
| полностью эквивалентно
<BR>
|  e1 = &lt;{ блок } e1&gt;
<BR>
| и по моему немного естественней.
<BR>
<P>Это для кого как. Мне всегда было естественней то, что Вы назвали with-блок
<BR>
(для меня это похоже на let-терм).
<BR>
Потому что *сначала* вычисляется e1 (это может быть сложное выражение),
<BR>
а уж  *потом* к нему применяется функция { блок }. То есть порядок чтения
<BR>
слева направо соответствует логике вычислений (сначала аргумент,
<BR>
потом функция). [Обратный порядок может выглядеть естественным разве что
<BR>
в контексте ленивого языка].
<BR>
<P>| Во вторых функции - достаточно общий объект, и через него можно
<BR>
| реализовать произвольные структуры, например атрибутированный набор.
<BR>
| Person {
<BR>
|  (e1) (e2) = { 'name' = e1; 'secondname' = e2; };
<BR>
| }
<BR>
| Работать с такими объектами по моему удобнее, чем таскать за собой сложную
<BR>
| структуру. (В прочем это субъективно, возможно это привычка пришла из
<BR>
| scheme и была усилена haskell, а в рефале она лишняя).
<BR>
<P>Но это уже не структура, а функция от имени атрибута. Ее можно только
<BR>
применять к именам. Но, например, от нее уже никак не получишь
<BR>
&lt;ListAttrNames &lt;Person ...&gt; &gt;, ожидая что-то вроде ('name')('secondname') .
<BR>
<P>|
<BR>
| Хотя мне такое расширение нравится, все-таки возникли вопросы.
<BR>
| На сколько это усложнит суперкомпиляцию (мне кажется что в языке стоит
<BR>
| оставлять только те конструкции, для которых суперкомпиляция эффективна)?
<BR>
| Создает ли это проблемы для введения в рефал статической типизации?
<BR>
<P>Это расширение никак не усложнит суперкомпиляцию, поскольку
<BR>
оно легко выразимо в терминах рефала без этого расширения -
<BR>
через компиляцию в этот последний. Но осложнить может
<BR>
не замыкание, а использование его в контексте &lt;sf ex&gt;
<BR>
для определения &quot;функций высших порядков&quot; типа Map,
<BR>
когда sf - неизвестная функция.
<BR>
<P>Всего наилучшего
<BR>
Аркадий.
<BR>
<P>|
<BR>
| P.S. Исходный текст этой эксперементальной реализации лежит
<BR>
| <A HREF="http://pm.kmost.express.ru/~pm/hrefal.tgz">http://pm.kmost.express.ru/~pm/hrefal.tgz</A>
<BR>
| Слиль в них плохой (первая моя программа на haskell), но
<BR>
| поэксперементировать можно. Накоплю опыта, я ее с нуля перепишу.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0231.html">Sergei M. Abramov (at home): "Re: Лямбда-исчисление в рефале."</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0229.html">Mike Potanin: "Re: Лямбда-исчисление в рефале"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0227.html">Mike Potanin: "Лямбда-исчисление в рефале"</A>
<!-- nextthread="start" -->
<LI><STRONG>Reply:</STRONG> <A HREF="0227.html">Arkady Klimov: "Re: Лямбда-исчисление в рефале"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
