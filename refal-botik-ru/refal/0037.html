<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klimovark@mail.ru)">
<META NAME="Subject" CONTENT="Re: Refal+ abstract syntax">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Refal+ abstract syntax</H1>
<HR>
<P>
<!-- received="Fri Nov 26 13:57:02 1999" -->
<!-- isoreceived="19991126105702" -->
<!-- sent="Fri, 26 Nov 1999 12:43:12 +0300" -->
<!-- isosent="19991126094312" -->
<!-- name="Arkady Klimov" -->
<!-- email="klimovark@mail.ru" -->
<!-- subject="Re: Refal+ abstract syntax" -->
<!-- id="002b01bf37f2$ab149790$97925bc3@bagirra.rinet.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="383DA3DA.C97ADEC9@msu.ru" -->
<STRONG>Subject: </STRONG>Re: Refal+ abstract syntax<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klimovark@mail.ru</EM>)<BR>
<STRONG>Date: </STRONG>Fri Nov 26 1999 - 12:43:12 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#37">[ date ]</A>
<A HREF="index.html#37">[ thread ]</A>
<A HREF="subject.html#37">[ subject ]</A>
<A HREF="author.html#37">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0038.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0036.html">Sergei M. Abramov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0033.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0040.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0033.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Прошу прощения за RTF, действительно, надо было использовать плоский
<BR>
текст.
<BR>
Предлагаю ориентироваться на вариант моего предлложения, помещенный в
<BR>
ответе С.Абрамова. Спасибо, Сергей. С изменениями внизу вполне
<BR>
согласен, можно также убрать кавычки с &quot;Iter&quot; (это я виноват) и лишнее
<BR>
= (нижнее). Или оно преднамеренно?
<BR>
<P>Сразу постараюсь ответить на вопросы Андрея С.
<BR>
<P>----- Original Message -----
<BR>
From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
<BR>
To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
<BR>
Cc: Sergei M. Abramov &lt;abram@botik.ru&gt;; &lt;refal@botik.ru&gt;
<BR>
Sent: Friday, November 26, 1999 12:02 AM
<BR>
Subject: Re: Refal+ abstract syntax
<BR>
<P><P><EM>&gt; Arkady Klimov wrote:
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Посылаю attached свои замечания/предложения
</EM><BR>
<EM>&gt; &gt; Аркадий.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; День добрый!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Спасибо за предложения, я еще буду с ними подробно разбираться,
</EM><BR>
<EM>&gt; но сразу же несколько вопросов:
</EM><BR>
<EM>&gt; 1) Чего в исходном синтаксисе не хватает для отображения Рефала-6?
</EM><BR>
В рефале 6 допускается произвольная последовательность образцов и
<BR>
результатов, в частности образец после образца и предложение может
<BR>
оканчиваться на образец. Отсюда - пункты 5-6:
<BR>
<P>Пункт 7 - оператор типа NoFail нужен для отображения семантики знака =
<BR>
как она определена в Рефале-6. Не откат до верхнего уровня, как в Р+,
<BR>
а полная блокировка неуспеха.
<BR>
<P>Пункт 11 - В Рефале-6 расширен список предопределенных типов объектов
<BR>
и имеется возможность расширять их дальше (прямо на рефале).
<BR>
<P>Остальные изменения нацелены на общее улучшение и упрощение.
<BR>
<P>Приведу некоторые мотивировки.
<BR>
<P>&quot;)   1. Тело функции путь (не обязательно блок).
<BR>
Формально, путь можно свести к блоку, а блок к пути. По этому это
<BR>
вопрос скорее эстетический. Блок (или PAlt) - это ветвление. Поэтому,
<BR>
считать тело блоком означает считать существенным, что на самом
<BR>
верхнем уровне тело функции начинается с ветвления. Мне это не кажется
<BR>
правильным.
<BR>
<P>&quot;) 2. Путь последовательность операторов вытянут по-
<BR>
&quot;)      горизонтали через конкатенацию, а не через cons
<BR>
<P>Обидно не использовать возможность рефала вытягивать
<BR>
последовательности &quot;по-горизонтали&quot;. К тому же я некоторые операторы
<BR>
сознательно описал как e (а не как t), в частности для Not.
<BR>
<P>Впрочем, сейчас вижу, что тут я немного неправ: все-таки Not относится
<BR>
именно к одному action, а не ко всему хвосту. Надо исправить.
<BR>
Например, взять Not t.Action в скобки. Больше e-операторов нет, можно
<BR>
было бы и заменить здесь e на t. Но первый аргумент остается.
<BR>
<P>И еще: посмотрим на пункт 6. Видим, что последовательность из двух и
<BR>
более действий тоже имеет семантику того же вида, что и отдельное
<BR>
действие. Подозреваю, что семантику действия можно формально
<BR>
определить так, что композиция действий будет ассоциативна. А тогда
<BR>
использование конкатенации станет более чем оправданной.
<BR>
<P>&quot;) 3. Все скобки, включая образующие термы, имеют впереди теги.
<BR>
В прежнем AS скобки, образующие термы, были без тегов. Полагаю, это
<BR>
создало бы напряженность с однозначностью. Теперь же мы можем
<BR>
позволить себе роскошь символы изображать самими собой.
<BR>
<P>&quot;) 4. Я не стал здесь брать теги в кавычки.
<BR>
Вообще не понимаю, зачем были кавычки в прежнем варианте.
<BR>
<P>&quot;) 5. Сложные конструкции (перестройки, присваивания) разбиты на
<BR>
&quot;)        составляющие действия.
<BR>
<P>&quot;) 6. Семантика действия состоит в пополнении среды и выработке
<BR>
&quot;)        нового форматного значения (объектного выражения со
<BR>
&quot;)        статическим форматом). Действия бывают простые (образцы,
<BR>
&quot;)        результаты, форматы) и сложные (блоки).
<BR>
<P>Все это, на мой взгляд, привносит большое упрощение.
<BR>
<P>&quot;) 7. Есть отдельный оператор NoFail, непроницаемый для $Fail, и
<BR>
&quot;)        CUTALL, выражающий семантику равенства рефала +.
<BR>
&quot;)        Непрозрачный блок выражается так: NoFail
<BR>
&quot;)        (Block e.Branches).
<BR>
<P>NoFail как блокировка неуспеха позволяет обходиться без блока там, где
<BR>
не требуется ветвления. При этом блок как таковой считается
<BR>
прозрачным, а если нужен непрозрачный, надо поставить перед ним
<BR>
NoFail. Оператор CUTALL в принципе является избыточным, поскольку
<BR>
статически известно, скольким CUT он равносилен. Однако он введен для
<BR>
облегчения трансляции знака = Рефала Плюс.
<BR>
При этом знак = Рефала-6 транслируется в оператор NoFail с другой
<BR>
семантикой.
<BR>
Между прочим, отдельный оператор Fail тоже является избыточным: он
<BR>
эквивалентен пустому блоку:
<BR>
(Block).
<BR>
<P>&quot;)     8. $iter может быть разложен в более элементарные понятия
<BR>
&quot;)        (Label sl) и (Loop sl) см.ниже. В операторе Loop метка
<BR>
&quot;)        sl должна быть определенной (оператором Label) выше на
<BR>
&quot;)        пути от начала функции к данному оператору Loop.
<BR>
&quot;)        Ищется ближайшая точка Label с тем же символом-меткой.
<BR>
<P>Все-таки метка семантически более прозрачна, чем Iter, в определении
<BR>
которого задействованы аж два источника, одно жесткое выражение и один
<BR>
хвост.
<BR>
<P>&quot;)     9. Вместо трех понятий: Tail, Path, Source одно: e.Sentence.
<BR>
Наличие &quot;трех источников и составных частей&quot; еще оправдано во внешнем,
<BR>
конкретном синтаксиса, где идет борьба за однозначность распознавание.
<BR>
Здесь, в AS, это уже становится лишним.
<BR>
<P>&quot;)    10. Констант нет: они уже подставлены. Но вопрос: что такое
<BR>
&quot;)        имя функции? И как выглядит внутри выражения ссылка на
<BR>
&quot;)        функцию? Другие символы ссылки? Возможный ответ: как (Ref
<BR>
&quot;)        s.Word). Определяющие вхождения задаются просто как s.Word.
<BR>
В
<BR>
&quot;)        вызове функции используется (Ref s.Word)
<BR>
На мой взгляд, само понятие константы в Рефал Плюс введено главным
<BR>
образом для того, чтобы иметь механизм для введения символа-ссылки,
<BR>
который никак иначе нельзя изобразить. Если константы убраны, то
<BR>
проблема ссылок остается. Другой путь - оставить константы, а вместо
<BR>
(Ref X) писать более общее (Const X), которое последующий анализ
<BR>
должен заменять на соответствующее значение. При этом определения
<BR>
констант для функций и других определенных объектов должны генериться
<BR>
автоматически.
<BR>
<P>&quot;)    11. Определения символов-ссылок должна быть возможность
<BR>
&quot;)        расширять список типов ссылок.
<BR>
См.выше.
<BR>
<P>&quot;)    12. Объектные символы (в отличие от символов-ссылок)
<BR>
&quot;)        представляются сами собой, а не как (Symbol s)
<BR>
Не вижу необходимисти в дополнительном теге, с учетом того, что тег
<BR>
(Par... ) есть у скобочного терма и у всех остальных скобок в AS.
<BR>
<P>&quot;)    13. Операторы Error и Trap имеют неявный дополнительный
<BR>
&quot;)        аргумент продолжение справа от оператора.
<BR>
Это дело вкуса. Иначе нужно отдельно говорить, что после этих
<BR>
операторов продолжение игнорируется. Впрочем, возможны варианты. Уж
<BR>
все равно пришлось сказать, что
<BR>
<P>&quot;)    14. Остаток после операторов Fail и Loop игнорируется.
<BR>
<P>&quot;)    15. Конкретная реализация может не поддерживать какие-то
<BR>
&quot;)        элементы (или сочетания элементов) абстрактного синтаксиса.
<BR>
В
<BR>
&quot;)        этом случае должно выдаваться внятное сообщение.
<BR>
С учетом того, что сейчас у нас несколько рефалов и мы решаем задачу
<BR>
их унификации, считаю это важным на сегодня. Для того, чтобы сообщения
<BR>
можно было сделать действительно внятными, введены операторы (Line n
<BR>
m), отмечающие номер строки-позиции исходного текста.
<BR>
<P>КОНЕЦ некоторых мотивировок.
<BR>
<P><EM>&gt; 2) Предлагаемый синтаксис несколько ближе к виртуальному коду. По
</EM><BR>
<EM>&gt;    крайней мере конструкций типа &quot;Label s&quot; в абстрактном синтаксисе
</EM><BR>
<EM>&gt;    иметь не хотелось бы.
</EM><BR>
Вопрос спорный. Но это конечно же еще далеко не виртуальный код. Более
<BR>
того, предложение ввести метки в AS есть как бы заявка на возможность
<BR>
в будущем ввести их и в исходный язык. Например для генерации
<BR>
программ. Причем вопрос не чисто эстетический, поскольку метки,
<BR>
очевидно, шире чем Iter.
<BR>
<P><EM>&gt; 3) Есть ощущение (хотя не проверенное), что предлагаемый синтаксис
</EM><BR>
<EM>&gt;    позволяет описать конструкции, которые семантически некорректны.
</EM><BR>
<P>Замечу, что то же можно сказать и об исходном синтаксисе, в частности
<BR>
по форматам: должно ведь выполняться дополнительное семантическое
<BR>
условие по согласованию форматов. Если у меня и есть новые
<BR>
семантические недосказаннасти, то в основном они того же толка.
<BR>
Например, есть вопрос: должен ли блок быть либо образцовым (все ветви
<BR>
начинаются с образца), либо результатным (все ветви начинаются с
<BR>
результатного действия? Может ли ветвь начинаться с жесткого образца?
<BR>
Можно наложить ограничение, но можно ведь и не накладывать. Ведь если
<BR>
окажется, что в реализации они снимаются легко, то не будет смысла их
<BR>
накладывать. Да, они вытекают из внешнего синтаксиса - но это свойство
<BR>
и особенности именно внешнего синтаксиса, не более того. Что касается
<BR>
семантики, то в упомянутых случаях обобщение семантики выглядит
<BR>
достаточно прямолинейно.
<BR>
<P>А вот некоторые другие &quot;сомнительные&quot; места:
<BR>
<P>Некоторые сочетания, хотя и корректны, но бессмысленны. Например,
<BR>
применение Not к жесткому образцу. В принципе это легко можно
<BR>
исключить, модифировав абстрактный синтаксис.
<BR>
<P>Метки должны быть определены и не где-нибудь, а выше и на прямом пути
<BR>
от корня. (Вопрос: может ли этот путь входить внутрь Not и проходить
<BR>
через Trap?)
<BR>
<P>Среда после Not: думаю, надо считать ее нетронутой (такой же как и
<BR>
перед Not).
<BR>
<P>Впрочем, все недосказанности по части Not можно устранить, если
<BR>
избавиться от Not аналогично тому, как это сделано для Iter:
<BR>
<P>Repr (Not t.A) e.S =
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stake
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Block
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Branch &lt;Repr t.A&gt; Cut Fail)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Branch &lt;Repr e.S&gt;)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<BR>
<P>Кстати, чтобы данный перевод был всегда корректным, нужно, чтобы не
<BR>
было ограничения на то, что все ветви блока должны быть &quot;одного типа&quot;.
<BR>
Легко убедиться, что как и для Iter, этот перевод является
<BR>
прямолинейным, в том смысле, что после трансляции в виртуальный код
<BR>
результат будет таким же.
<BR>
<P>Убрав Not из AS, можно убрать и отдельное понятие action, которое есть
<BR>
частный случай statement. Оно использутся только для того, чтобы
<BR>
описание для Not сделать короче.
<BR>
<P>Если будут выявлены другие проблемы, буду рад услышать.
<BR>
<P>Всего наилучшего
<BR>
<P>Аркадий.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; Всего доброго,
</EM><BR>
<EM>&gt; Андрей.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; P.S. Убедительная просьба не присылать MS Word/RTF документы - у
</EM><BR>
меня
<BR>
<EM>&gt; нету Windows на компьютере :-).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
PS. Только что получил новые реплики от Андрея и Сергея. Это письмо
<BR>
писалось без учета этих реплик. Щас отвечу и на них.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0038.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0036.html">Sergei M. Abramov: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0033.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0040.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0033.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
