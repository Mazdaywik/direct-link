<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Mike Potanin (potanin@mccme.ru)">
<META NAME="Subject" CONTENT="Re: Ядро Рефал">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Ядро Рефал</H1>
<HR>
<P>
<!-- received="Fri Nov  2 14:19:35 2001" -->
<!-- isoreceived="20011102111935" -->
<!-- sent="Fri, 2 Nov 2001 13:54:46 +0300 (MSK)" -->
<!-- isosent="20011102105446" -->
<!-- name="Mike Potanin" -->
<!-- email="potanin@mccme.ru" -->
<!-- subject="Re: Ядро Рефал" -->
<!-- id="Pine.LNX.4.21.0111021320080.24289-100000@mccme.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="001a01c16387$4a023d00$110d040a@Bagirra" -->
<STRONG>Subject: </STRONG>Re: Ядро Рефал<BR>
<STRONG>From: </STRONG>Mike Potanin (<EM>potanin@mccme.ru</EM>)<BR>
<STRONG>Date: </STRONG>Fri Nov 02 2001 - 13:54:46 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#253">[ date ]</A>
<A HREF="index.html#253">[ thread ]</A>
<A HREF="subject.html#253">[ subject ]</A>
<A HREF="author.html#253">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0254.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0252.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0252.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0254.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0252.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
On Fri, 2 Nov 2001, Arkady Klimov wrote:
<BR>
<P><EM>&gt; 
</EM><BR>
<EM>&gt; Простота рефала обманчива: в его реализации приходится опираться
</EM><BR>
<EM>&gt; на совершенно специфичиский &quot;рантайм&quot;, включающий особую модель
</EM><BR>
<EM>&gt; данных со своими механизмами сборки мусора и т.п. Понятия рефала уж
</EM><BR>
<EM>&gt; очень оторваны от понятий архитектуры компьютера. Идея массивного
</EM><BR>
<EM>&gt; представления выражений - важный шаг на пути сближения этих двух
</EM><BR>
<EM>&gt; миров.
</EM><BR>
Представление строк - вопрос второстеменный. В Рефале+ пошли по пути
<BR>
отделения представления от компилятора. Это создает возможность
<BR>
использования специольного представления, оптимального для конкретной
<BR>
задачи.
<BR>
(Например возьмем биологию - для обработки какого-нибудь гена придется
<BR>
работать со строками в несколько тысяч символов. В то же время операции 
<BR>
будут ограниченые - вставка/вырезание небольшой подстроки. И массивное и
<BR>
списковое представление этого не вынесут. В тоже время можно сделать
<BR>
строки, хорошо с этим работают. Например строка кодируется указателями на
<BR>
начало и конец и строкой специальных точек, которые обозначают разрыв в
<BR>
строке или вставку специального элемента - терма, спецсимвола или
<BR>
ленивого вызова. Это позволит кодировать часто встречающиеся символы одним
<BR>
байтом и сделает большинство операций дешевыми, но сделает невозможной
<BR>
сборку мусора.
<BR>
При желании можно поиграться с представлением служебной строки - например
<BR>
сделать ее аналогичной основной (чем не метосистемный переход :-)), что
<BR>
может быть позволит расширить область применения.)
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Аккуратный перехват ошибок и весьма осмысленная диагностика всегда
</EM><BR>
<EM>&gt; считались ценнейшим качеством рефала, за которое, не в последнюю
</EM><BR>
<EM>&gt; очередь, его и любили программисты. Типизации же в рефале просто нет,
</EM><BR>
<EM>&gt; что тоже в некотором смысле ценность, и потому на run-time диагностику
</EM><BR>
<EM>&gt; возлагаются задачи, обычно решаемые компиляторами при проверке типов.
</EM><BR>
<EM>&gt; А программирование на рефале в стиле &quot;не порождающих ошибки функций&quot;
</EM><BR>
<EM>&gt; будет только затруднять отладку.
</EM><BR>
Давайте разделять средства отладки и средства языка. Отладчик может себе
<BR>
позволить сколь угодно неэффективное представление, лишь бы оно было
<BR>
удобно для анализа. Отладчик - внешняя по отношению к языку сущьность, и
<BR>
то что он (отладчик) умеет перехватывать ошибки языку знать не обязятельно
<BR>
(а по моему даже не желательно).
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; То, о чем пишет Кондратьев - возможность возбудить перехват
</EM><BR>
<EM>&gt; с осмысленным дампом при зацикливании программы - тоже ценнейшая
</EM><BR>
<EM>&gt; штука, к большому сожалению отстутвующая в большинстве реализаций
</EM><BR>
<EM>&gt; рефала (о других языках и не говорю). А в нынешнем рефале-6 это не
</EM><BR>
<EM>&gt; только диагностика, но и возможность вмешаться в процесс, продолжить
</EM><BR>
<EM>&gt; его по тому или иному пути и т.п. И совсем это не дорого: при опросе
</EM><BR>
<EM>&gt; &quot;датчика&quot; раз на 50-100 шагов замедление не превышает и 1%.
</EM><BR>
Может это все-таки оставить отладчику? Врядли кто захочит прервать
<BR>
отлаженую программу, считающюю в течении месяца.
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Ящики? Да без них рефал никто не станет использовать, хотя это и внешняя
</EM><BR>
<EM>&gt; по отношению к языку сущность. В рефале-6, на мой взгляд, они доведены до
</EM><BR>
<EM>&gt; некоторой завершенности. Суперкомпилятору они, конечно, мешают, но
</EM><BR>
<EM>&gt; объектно-ориентированная парадигма &quot;мешает&quot; куда больше, тем не менее
</EM><BR>
<EM>&gt; отбрасывать ее - значит уклоняться от решения проблем, которые ставит
</EM><BR>
<EM>&gt; сама жизнь.
</EM><BR>
Кто-нибудь занимался анализом использования ящиков? Наверняка есть
<BR>
небольшое число ситуаций, в которых они полезны. И разработав методологию
<BR>
их обхождения можно обойтись и без ящиков. Здесь аналогия скорее не с ОО,
<BR>
а с GOTO. Когда-то казалось что без него ни как - пока Дейкстра не показал
<BR>
обратное.
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Согласен, что ввод-вывод и прочие внешние операции спорно встраивать в сам язык.
</EM><BR>
<EM>&gt; Но возможность вызывать рефал из чего-то другого здесь не лекарство, так как
</EM><BR>
<EM>&gt; оставляет неудовлетворенной потребность вызывать ИЗ РЕФАЛА что-то другое.
</EM><BR>
<EM>&gt; Наверно, правильнее был бы грамотный интерфейс по вызову из рефала функций
</EM><BR>
<EM>&gt; написанных на других языках (Яве, например), и наоборот.
</EM><BR>
Да, было бы полезно разработать что то типа Haskellовского ffi. По моему в
<BR>
Рефал+ этим тоже занимались.
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Аркадий.
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0254.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0252.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0252.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0254.html">Arkady Klimov: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0252.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
