<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klimovark@mail.ru)">
<META NAME="Subject" CONTENT="Re: Refal+ abstract syntax">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Refal+ abstract syntax</H1>
<HR>
<P>
<!-- received="Fri Dec 17 18:56:22 1999" -->
<!-- isoreceived="19991217155622" -->
<!-- sent="Fri, 17 Dec 1999 17:24:01 +0300" -->
<!-- isosent="19991217142401" -->
<!-- name="Arkady Klimov" -->
<!-- email="klimovark@mail.ru" -->
<!-- subject="Re: Refal+ abstract syntax" -->
<!-- id="002601bf489a$5e6209b0$97925bc3@bagirra.rinet.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="3858584C.9CFC75CE@msu.ru" -->
<STRONG>Subject: </STRONG>Re: Refal+ abstract syntax<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klimovark@mail.ru</EM>)<BR>
<STRONG>Date: </STRONG>Fri Dec 17 1999 - 17:24:01 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#73">[ date ]</A>
<A HREF="index.html#73">[ thread ]</A>
<A HREF="subject.html#73">[ subject ]</A>
<A HREF="author.html#73">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0072.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0071.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0071.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Андрей, спасибо, это уже почти то, что надо.
<BR>
&quot;У целом&quot; принимается.
<BR>
<P>А теперь перейдем к постатейному обсуждению.
<BR>
<P>Но сначала одно общефилософское замечание.
<BR>
Я полагаю, что то, что мы сейчас называем АС - это наивозможно более раняя
<BR>
стадия
<BR>
обработки программы, где еще можно говорить об абстрактности и всеобщности.
<BR>
Исходя из этого, в частности, тобой были справедливо оставлены ITER и NOT.
<BR>
Однако сейчас я усматриваю некоторые моменты, где как бы произведена
<BR>
обработка,
<BR>
которая могла бы быть выражена и на более поздней стадии, над АС как над
<BR>
входом.
<BR>
В связи с этим будет один общий вопрос: разделяем ли мы эту точку зрения
<BR>
вообще,
<BR>
и затем исходя из ответа на него, по разным моментам конкретно будем
<BR>
решать,
<BR>
куда относить соотвествующую обработку - на этап получения АС или на этап
<BR>
последующей компиляции.
<BR>
Также думаю, что будет правильным, чтобы зря не плодить новые
<BR>
представления,
<BR>
производить первые этапы компиляции в рамках самого АС: например,
<BR>
разворачивая
<BR>
ITER и NOT. Для этого возможно придется определить его шире, чем требуется
<BR>
для
<BR>
предствления начального АС, например включить метки. Более того, я думаю,
<BR>
что
<BR>
обсуждавшийся АСАИЯ следует определить как легкую модификацию, возможно с
<BR>
ограничениями, нашего АС (но это уже отдельная тема).
<BR>
А теперь перейдем к обсуждению по пунктам.
<BR>
<P>Сначала по изменениям.
<BR>
<P>----- Original Message -----
<BR>
From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
<BR>
To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
<BR>
Cc: Sergei M. Abramov &lt;abram@botik.ru&gt;; &lt;refal@botik.ru&gt;
<BR>
Sent: Thursday, December 16, 1999 6:11 AM
<BR>
Subject: Re: Refal+ abstract syntax
<BR>
<P><P><EM>&gt; Добрый день всем!
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Извиняюсь за некоторую паузу в дискуссии.
</EM><BR>
<EM>&gt; Я еще раз внимательно посмотрел на проект абстрактного синтаксиса
</EM><BR>
<EM>&gt; и сделал свой вариант. Он лежит на
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; <A HREF="http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html">http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html</A>
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; На самом деле принципиальных различий практически нет, так что
</EM><BR>
<EM>&gt; я думаю, что утверждение окончательного варианта не за горами.
</EM><BR>
<EM>&gt; Что я изменил (по порядку):
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; 1) t.ProgramFile заменено на t.Module (чисто косметическая замена :-))
</EM><BR>
<EM>&gt; 2) t.Source удалено - вместо этого нужно использовать прагмы
</EM><BR>
<EM>&gt;    (тем более, что абстрактный синтаксис не обязательно может
</EM><BR>
<EM>&gt;    иметь какой-то исходный текст)
</EM><BR>
ОК
<BR>
<EM>&gt; 3) t.Import удалено - на уровне абстрактного синтаксиса нельзя ничего
</EM><BR>
<EM>&gt;    вытащить из других модулей, т.к. их представление в АС может и не
</EM><BR>
<EM>&gt;    существовать. Вместо этого каждый объект имеет свой описатель
</EM><BR>
<EM>&gt;    IMPORT/EXPORT/LOCAL. Если нужно сохранить информацию о том,
</EM><BR>
<EM>&gt;    из каких модулей импортировались объекты - можно использовать прагмы.
</EM><BR>
Это, конечно же, нужно, поэтому непонятно,
<BR>
почему для этого надо прибегать к прагмам.
<BR>
Причем это нужно будет сохранять не только в АС, но и в загрузочном модуле.
<BR>
Нам наконец пора иметь возможность (не обязательно в любой реализации,
<BR>
но хотя бы в некоторых) обеспечить цивилизованную динамическую загрузку.
<BR>
Цивилизованной я называю такую, когда при загрузке модуля автоматически
<BR>
могут быть подзагружены все используемые в нем модули, если они еще
<BR>
не загружены. При этом также не нужно будет перечислять имена всех
<BR>
модулей для начальной загрузки. (Сейчас в рефале-6 загрузка не является
<BR>
цивилизованной)
<BR>
Поэтому предлагаю.
<BR>
а) Оставить список (USE e.ModuleNames).
<BR>
б) В имени функции (REF s.name) разрешить использовать полные имена для
<BR>
внешних функций: (REF s.ModuleName s.Name). Имена таких функций s.Name
<BR>
могут безболезненно пересекаться с другими локальными или внешними
<BR>
фунциями. Можно ввести стадию разрешения, которая будет пополнять все
<BR>
ссылки (REF s.Name) до полных.
<BR>
в) В s.ModuleName можно использовать точку, которая при превращении в имя
<BR>
файла переходит в слеш.
<BR>
г) Считать ошибкой, если есть простая ссылка с именем, которое не
<BR>
определено
<BR>
ни локально, ни в одном из USEd модулей.
<BR>
д) Декларации внешних функций пополнить именем модуля, где обнаружено
<BR>
определение функции. Эти декларации вставляются на стадии разрешения,
<BR>
а изначально могут отсутствовать (см.ниже).
<BR>
<P><EM>&gt; 4) Описания определений всех объектов изменены в соответствии с 3).
</EM><BR>
<P>Вспомним философское замечание в начале письма. Данное изменение
<BR>
предполагает, что поиск внешних определений произведен на стадии
<BR>
до формирования АС, то есть парсером. Я не уверен, что это правильно.
<BR>
Можно ли услышать аргументацию за это?
<BR>
Мне лично кажется, что парсеру следовало поручить только обработку
<BR>
отдельного файла,
<BR>
а разрешение внешних имен выполнить как этап обработки в рамках АС.
<BR>
При разрешении имен ведь нужно будет обращаться к интерфейсам других
<BR>
модулей, то есть опять же к парсеру от них. (А если интерфейсы не отделены,
<BR>
то и к парсеру от самих модулей). А что разрешатель будет иметь
<BR>
как исходый материал для своей работы?
<BR>
Если же парсер сделать только считывающим один файл, то разрешение имен
<BR>
тогда
<BR>
формализуется как этап обработки АС-терма, пополняющий его информацией.
<BR>
Для некоторых реализаций (компиляторов) он будет не нужен (как например
<BR>
для Рефала-6, с учетом его виртуального кода).
<BR>
<P><EM>&gt; 5) Добавлен оператор FLUSH - см. мое письмо от 26 ноября в 16:14.
</EM><BR>
<EM>&gt;    В принципе возможна альтернатива - результаты по умолчанию
</EM><BR>
<EM>&gt; замещаются,  но есть оператор CONC.
</EM><BR>
Я не понимаю, зачем он нужен. Давайте лучше введем расширение для
<BR>
t.ResultTerm:
<BR>
<P>t.ResultTerm    ::=    ...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|    t.Block
<BR>
<P>А Flush пусть всегда присутствует &quot;по умолчанию&quot;. Если же нужно
<BR>
сконкатенировать
<BR>
предыдущий результат со следующим t.Result или t.Block, то сделать это надо
<BR>
явно.
<BR>
<P>(Возникает вопрос, а как вставить непрозрачный блок? Ответ: поставить
<BR>
NOFAIL,
<BR>
но не перед блоком, а перед всем результатным выражением.)
<BR>
<P><EM>&gt; 6) NOT и ITER сохранены как есть. С моей точки зрения их раскрытие
</EM><BR>
<EM>&gt;    слишком далеко двигает нас в сторону виртуального кода и может
</EM><BR>
<EM>&gt;    привести к менее удобному представлению при компиляции в
</EM><BR>
<EM>&gt;    императивные языки.
</EM><BR>
Это нормально. Но не отменяет возможности на ранней стадии компиляции
<BR>
устранить NOT и ITER путем их раскрытия в АС же. Я не вижу почему эти
<BR>
раскрытия специфичны для какого-то одного типа реализации. Полагаю,
<BR>
они универсальны.
<BR>
<EM>&gt; 7) Немного изменены прагмы - но это не существенно.
</EM><BR>
<EM>&gt; 8) В конце приведен вариант синтаксиса, в котором есть нераскрытые
</EM><BR>
<EM>&gt; константы.
</EM><BR>
Это хорошо. Неясно теперь, как используются константы в теле программы.
<BR>
Например, можно как (REF name), имея в виду, что такая конструкция всегда
<BR>
подразумевает ее замену на значение константы по имени name. В случае
<BR>
фукнций
<BR>
и объектов следует считать, что строятся автоматически определения
<BR>
констант,
<BR>
значениями которых являются настоящие символы-ссылки.
<BR>
Однако, обращаю внимание, что значением константы в общем случае будет
<BR>
не обязательно символ, и даже не обязательно терм. Но всегда - объектное
<BR>
(в смысле - ground) выражение, которое может быть всюду, включая жесткий
<BR>
образец.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Кроме того, он, мне кажется, красивее выглядит :-)))
</EM><BR>
<EM>&gt; Так что изменения лучше будет вносить туда.
</EM><BR>
Согласен.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Всего доброго,
</EM><BR>
<EM>&gt; Андрей.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; P.S. Вопрос: Что такое t.Initializer и с чем его едят? По смыслу это
</EM><BR>
<EM>&gt; похоже на конструкторы глобальных объектов в C++. Верно ли, что это
</EM><BR>
<EM>&gt; расширение из Рефала-6?
</EM><BR>
Да, это расширение из Рефала-6. Он означает, что выражение должно быть
<BR>
вычислено в момент загрузки. Вычисляется ради побочного эффекта,
<BR>
значение игнорируется. Есть одна тонкость: момент вычисления определяется
<BR>
положением среди других элементов. При этом нет гарантии, что нижеследующие
<BR>
определения функций уже загружены и могут выполняться. Также уже должны
<BR>
быть загружены целиком другие модули, которые используются из данного.
<BR>
А это, в частности, означает, что в графе использований модулями друг друга
<BR>
не должно быть циклов.
<BR>
Вообще, я думаю, это полезная конструкция, посколку позволяют делать
<BR>
модули,
<BR>
которые содержат в себе свою инициализацию (содержимого ящиков, например),
<BR>
и не требуют от пользователя вызывать инициализацию явно.
<BR>
Кроме того, такие модули могут представлять самодостаточные программы, не
<BR>
требующие указывать их входные точки (GO, Main, и т.п.).
<BR>
<P><EM>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</EM><BR>
<P>А теперь несколько новых замечаний-дополнений.
<BR>
<P>1. Для объектов типов BOX, STRING, VECTOR и, возможно, TABLE - вести
<BR>
понятие начального значения:
<BR>
<P>t.Object        ::= (s.Linkage s.ObjectType s.ObjectName e.InitialValue)
<BR>
<P>e.InitialValue    ::= e.ResultExpression
<BR>
<P>(ограничения - те же, что и для initializer'а.
<BR>
<P>2. PragmaTrace. Отсутствует traceAll. Преднамеренно?
<BR>
<P>3. В последнем письме от 17.12 ты предлагаешь разделить декларацию и
<BR>
определения.
<BR>
Мне кажется, это тоже можно вводить как стадию обработки в рамках АС. Но
<BR>
может
<BR>
компилятору это и не требуется?
<BR>
<P>Кажется все.
<BR>
<P>Надеюсь, не слишком утомил?
<BR>
<P>Наилучшие пожелания.
<BR>
Аркадий.
<BR>
<P>PS. В интернете я никаких изменений не делал, да наверно я и не вправе.
<BR>
Поэтому,
<BR>
все изменения, который сочтешь нужными, внеси, пожалуйста, сам.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0072.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0071.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0071.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
