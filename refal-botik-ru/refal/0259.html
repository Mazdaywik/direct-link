<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Anton Yu. Orlov (orlov@mccme.ru)">
<META NAME="Subject" CONTENT="Re: Ядро Рефал">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Ядро Рефал</H1>
<HR>
<P>
<!-- received="Mon Nov  5 10:52:50 2001" -->
<!-- isoreceived="20011105075250" -->
<!-- sent="Sat,  3 Nov 2001 01:45:34 +0300" -->
<!-- isosent="20011102224534" -->
<!-- name="Anton Yu. Orlov" -->
<!-- email="orlov@mccme.ru" -->
<!-- subject="Re: Ядро Рефал" -->
<!-- id="20011103014534.A3320@mccme.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="Pine.LNX.4.21.0111021507380.24289-100000@mccme.ru" -->
<STRONG>Subject: </STRONG>Re: Ядро Рефал<BR>
<STRONG>From: </STRONG>Anton Yu. Orlov (<EM>orlov@mccme.ru</EM>)<BR>
<STRONG>Date: </STRONG>Sat Nov 03 2001 - 01:45:34 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#259">[ date ]</A>
<A HREF="index.html#259">[ thread ]</A>
<A HREF="subject.html#259">[ subject ]</A>
<A HREF="author.html#259">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0260.html">dmsidorov@mtu-net.ru: "Refal6 для Linux скомпилирован"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0258.html">Sergei Romanenko: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0257.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0261.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0257.html">Anton Yu. Orlov: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Добрый вечер, всем!
<BR>
<P>On Fri, Nov 02, 2001 at 12:03:00 +0300, Mike Potanin wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt;  Рефал по сути язык очень просто, но конкретные реализации
</EM><BR>
<EM>&gt; навешивают на него столько, что возникают проблемы, например с
</EM><BR>
<EM>&gt; переносимостью. По моему стоит обсудить ядро языка, которое по
</EM><BR>
<EM>&gt; первых легко реализовывалось (с точностью до представления
</EM><BR>
<EM>&gt; строк), во вторых поддерживалось бы суперкомпилятором.
</EM><BR>
<EM>&gt; Остальное попытаться вынести в библиотеки или вообще выкинуть.
</EM><BR>
<P>Имеются в виду проблемы с переносимостью с одного диалекта на
<BR>
другой? Но ведь именно с целью решения этих проблем и был
<BR>
разработан абстрактный синтаксис (AS), в который легко
<BR>
компилируются все современные варианты Рефала. Уже давно Андреем
<BR>
Слепухиным написан такой компилятор для Рефала+. С компиляцией в
<BR>
AS Рефала-5 вообще нет никаких проблем (ну, разве что повышатель
<BR>
арности было бы неплохо иметь :), с Рефалом-6 чуть сложнее
<BR>
(скажется разница с Рефалом+ в семантике знака &quot;=&quot;, возможно, ещё
<BR>
какие-то тонкости), но это тоже должно делаться достаточно
<BR>
прямолинейно.
<BR>
<P>Соответственно предполагается, что отныне все реализации будут
<BR>
работать именно с AS - человеку достаточно один раз написать
<BR>
программу на любимом диалекте Рефала, после чего он будет иметь
<BR>
возможность запустить её на разных рантаймах: списочном,
<BR>
векторном, ленивом с мемоизацией, параллельном...
<BR>
Абстрактный синтаксис (правда, без комментариев) можно посмотреть
<BR>
здесь: <A HREF="http://glade.nmd.msu.ru/~pooh/abstract_syntax.txt">http://glade.nmd.msu.ru/~pooh/abstract_syntax.txt</A>
<BR>
<P>А вот смысла в выделении ядра, которое поддерживалось бы
<BR>
суперкомпилятором я не вижу. Каким суперкомпилятором?
<BR>
Суперкомпиляторов Рефала уже было не мало, и хочется надеяться,
<BR>
что их число будет увеличиваться ;-). И в каждом конкретном
<BR>
случае автору суперкомпилятора, конечно, видней над каким именно
<BR>
подмножеством Рефала работать. Т.е. автор может сказать, что
<BR>
программы на таком подмножестве (ядре) будут данным
<BR>
суперкомпилятором отлично обрабатываться, на более широком
<BR>
подмножестве не ждите блестящих результатов, а с полным AS данный
<BR>
суперкомпилятор, к примеру, вообще не работает. На мой взгляд, не
<BR>
стоит выкидывать из языка какие бы то ни было конструкции,
<BR>
руководствуясь тем, что это мол никакой суперкомпилятор никогда
<BR>
не съест. Ведь теория развивается...
<BR>
<P>On Fri, Nov 02, 2001 at 15:24:08 +0300, Mike Potanin wrote:
<BR>
<EM>&gt; On Fri, 2 Nov 2001, Arkady Klimov wrote:
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt; | &gt; Если кто-то когда-то использовал &quot;ящики&quot; не по существу, - это еще не повод
</EM><BR>
<EM>&gt; &gt; | Не ясно какое их использование будет &quot;по существу&quot;. Возможно то для чего
</EM><BR>
<EM>&gt; &gt; | нужны ящики проще запрограмировать на другом языке, а из него вызвать
</EM><BR>
<EM>&gt; &gt; | Рефал. Сам я на Рефале писал мало и мне ящики ни разу не понадобились.
</EM><BR>
<EM>&gt; &gt; | Задачи я выбирал простые и ориентированые на Рефал, и придумать случай в
</EM><BR>
<EM>&gt; &gt; | котором ящик уместен я не могу.
</EM><BR>
<EM>&gt; &gt; 
</EM><BR>
<EM>&gt; &gt; Одно из важных применений ящиков, где я не знаю, как обойтись без них - это
</EM><BR>
<EM>&gt; &gt; имитация &quot;ленивости&quot; = задержка + мемоизация. Вычисленные по первому
</EM><BR>
<EM>&gt; &gt; запросу значения затем помещаются в динамический, созданный заблаговременно,
</EM><BR>
<EM>&gt; &gt; ящик для последующих использований.
</EM><BR>
<EM>&gt; Ленивость я давно предлагою ввести в язык (в моей haskellной реализации
</EM><BR>
<EM>&gt; была ленивость термов и правого хвоста, для более сложной надо придумывать
</EM><BR>
<EM>&gt; сложное представление строк). Мемоизация тоже там к месту - при
</EM><BR>
<EM>&gt; программировании в функциональном стиле на семантику она не влияет, а
</EM><BR>
<EM>&gt; эффективность может поднять.
</EM><BR>
<P>Точно также, как и посадить, вплоть до полной неработоспособности
<BR>
программы. Уверен, что для любого способа мемоизации, намертво
<BR>
заделанного в реализацию, найдётся задача, которая без этой
<BR>
мемоизации работала бы на порядок быстрее. Возьмём, к примеру,
<BR>
те же гены - надо работать с выражением огромной длины,
<BR>
итеративно изменяя его небольшие куски. Если мы будем
<BR>
запоминать всё это выражение после очередной операции, то на
<BR>
поддержание списка мемоизированных значений мы угрохаем огромное
<BR>
время и очень быстро - всю имеющуюся в наличии память. А при
<BR>
заданном наперёд способе мемоизации такое всегда можно
<BR>
организовать ;-). Однако, если нет ящиков, то подобная задача
<BR>
всё-равно скорей всего окажется не под силу существующим
<BR>
рантаймам, хотя они и не ленивы и в них нет встроенной
<BR>
мемоизации. Поэтому придётся либо действительно писать рантайм
<BR>
спецефически под эту задачу, либо использовать библиотеку на
<BR>
C/C++, либо вообще писать на более подходящем языке, чем Рефал.
<BR>
Но при наличии ящиков можно легко организовать и своё собственное
<BR>
представление выражений и работу с ними, и соответствующую задаче
<BR>
мемоизацию. А при наличии в Рефале инструментов, позволяющих
<BR>
решать задачу с приемлемой эффективностью, меня в сторону С, а
<BR>
тем более С++ и силком не затащишь ;-). Ящики - это необходимый
<BR>
инструмент при решении задач, где требуется использовать данные,
<BR>
для которых рантайм не даёт эффективного представления. Ведь не
<BR>
писать же под каждую задачу свой рантайм. Конечно, интерфейс с
<BR>
другими языками программирования (С/С++ в первую очередь) - ещё
<BR>
более гибкий инструмент и он, безусловно, нужен. В принципе,
<BR>
можно и ящики считать просто внешней библиотекой, равноправной с
<BR>
теми, которые может написать пользователь. Но на мой взгляд, то
<BR>
что они входят именно в Рефал имеет большой плюс: всякие
<BR>
программы-метавычислители могут понимать, что имеют дело именно с
<BR>
ящиками, а не с произвольными внешними вызовами, и действовать,
<BR>
исходя из свойств ящиков. Простейшее, что приходит в голову:
<BR>
программу, использующую только явно указанные ссылки на
<BR>
глобальные ящики, можно скомпилировать в аналогичную программу
<BR>
без ящиков ;-).
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Антон.
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0260.html">dmsidorov@mtu-net.ru: "Refal6 для Linux скомпилирован"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0258.html">Sergei Romanenko: "Re: Ядро Рефал"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0257.html">Mike Potanin: "Re: Ядро Рефал"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0261.html">Mike Potanin: "Re: Ядро Рефал"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0257.html">Anton Yu. Orlov: "Re: Ядро Рефал"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:59 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
