<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>refal@botik.ru -- Discussing the Refal programming language, Re</TITLE>
<META NAME="Author" CONTENT="Arkady Klimov (klark@bagirra.rinet.ru)">
<META NAME="Subject" CONTENT="Re: Refal+ abstract syntax">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Refal+ abstract syntax</H1>
<HR>
<P>
<!-- received="Mon Dec 20 14:30:27 1999" -->
<!-- isoreceived="19991220113027" -->
<!-- sent="Sat, 18 Dec 1999 14:29:05 +0300" -->
<!-- isosent="19991218112905" -->
<!-- name="Arkady Klimov" -->
<!-- email="klark@bagirra.rinet.ru" -->
<!-- subject="Re: Refal+ abstract syntax" -->
<!-- id="002001bf494b$17a61b40$97925bc3@bagirra.rinet.ru" -->
<!-- charset="koi8-r" -->
<!-- inreplyto="385A5CF5.8D2B9449@msu.ru" -->
<STRONG>Subject: </STRONG>Re: Refal+ abstract syntax<BR>
<STRONG>From: </STRONG>Arkady Klimov (<EM>klark@bagirra.rinet.ru</EM>)<BR>
<STRONG>Date: </STRONG>Sat Dec 18 1999 - 14:29:05 MSK
<P>
<UL>
<LI><STRONG>sorted by:</STRONG> 
<A HREF="date.html#76">[ date ]</A>
<A HREF="index.html#76">[ thread ]</A>
<A HREF="subject.html#76">[ subject ]</A>
<A HREF="author.html#76">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0077.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0075.html">Arkady Klimov: "Re: Announce: Refal+ v1.8.1 and future plans"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0077.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0074.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Андрей,
<BR>
<P>----- Original Message -----
<BR>
From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
<BR>
To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
<BR>
Cc: &lt;refal@botik.ru&gt;
<BR>
Sent: Friday, December 17, 1999 6:55 PM
<BR>
Subject: Re: Refal+ abstract syntax
<BR>
<P><P><EM>&gt; Arkady Klimov wrote:
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Андрей, спасибо, это уже почти то, что надо.
</EM><BR>
<EM>&gt; &gt; &quot;У целом&quot; принимается.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; А теперь перейдем к постатейному обсуждению.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Но сначала одно общефилософское замечание.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; [note snipped]
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; С моей точки зрения главное в АС - это
</EM><BR>
<EM>&gt; 1) Общий синтаксис для всех рефалов.
</EM><BR>
<EM>&gt; 2) Самодостаточное описание модуля, не требующее никакой дополнительной
</EM><BR>
<EM>&gt;    информации для его компиляции.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Во всех своих утверждениях я исхожу именно из этого.
</EM><BR>
Арк:
<BR>
А я спорю с пунктом 2). См. ниже.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; А теперь перейдем к обсуждению по пунктам.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Сначала по изменениям.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; ----- Original Message -----
</EM><BR>
<EM>&gt; &gt; From: Andrey Slepuhin &lt;pooh@msu.ru&gt;
</EM><BR>
<EM>&gt; &gt; To: Arkady Klimov &lt;klark@bagirra.rinet.ru&gt;
</EM><BR>
<EM>&gt; &gt; Cc: Sergei M. Abramov &lt;abram@botik.ru&gt;; &lt;refal@botik.ru&gt;
</EM><BR>
<EM>&gt; &gt; Sent: Thursday, December 16, 1999 6:11 AM
</EM><BR>
<EM>&gt; &gt; Subject: Re: Refal+ abstract syntax
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; Добрый день всем!
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; Извиняюсь за некоторую паузу в дискуссии.
</EM><BR>
<EM>&gt; &gt; &gt; Я еще раз внимательно посмотрел на проект абстрактного синтаксиса
</EM><BR>
<EM>&gt; &gt; &gt; и сделал свой вариант. Он лежит на
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; <A HREF="http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html">http://forest.nmd.msu.ru/~pooh/refal_abstract_syntax.html</A>
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; На самом деле принципиальных различий практически нет, так что
</EM><BR>
<EM>&gt; &gt; &gt; я думаю, что утверждение окончательного варианта не за горами.
</EM><BR>
<EM>&gt; &gt; &gt; Что я изменил (по порядку):
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; 1) t.ProgramFile заменено на t.Module (чисто косметическая замена
</EM><BR>
:-))
<BR>
<EM>&gt; &gt; &gt; 2) t.Source удалено - вместо этого нужно использовать прагмы
</EM><BR>
<EM>&gt; &gt; &gt;    (тем более, что абстрактный синтаксис не обязательно может
</EM><BR>
<EM>&gt; &gt; &gt;    иметь какой-то исходный текст)
</EM><BR>
<EM>&gt; &gt; ОК
</EM><BR>
<EM>&gt; &gt; &gt; 3) t.Import удалено - на уровне абстрактного синтаксиса нельзя ничего
</EM><BR>
<EM>&gt; &gt; &gt;    вытащить из других модулей, т.к. их представление в АС может и не
</EM><BR>
<EM>&gt; &gt; &gt;    существовать. Вместо этого каждый объект имеет свой описатель
</EM><BR>
<EM>&gt; &gt; &gt;    IMPORT/EXPORT/LOCAL. Если нужно сохранить информацию о том,
</EM><BR>
<EM>&gt; &gt; &gt;    из каких модулей импортировались объекты - можно использовать
</EM><BR>
прагмы.
<BR>
<EM>&gt; &gt; Это, конечно же, нужно, поэтому непонятно,
</EM><BR>
<EM>&gt; &gt; почему для этого надо прибегать к прагмам.
</EM><BR>
<EM>&gt; &gt; Причем это нужно будет сохранять не только в АС, но и в загрузочном
</EM><BR>
модуле.
<BR>
<EM>&gt; &gt; Нам наконец пора иметь возможность (не обязательно в любой реализации,
</EM><BR>
<EM>&gt; &gt; но хотя бы в некоторых) обеспечить цивилизованную динамическую
</EM><BR>
загрузку.
<BR>
<EM>&gt; &gt; Цивилизованной я называю такую, когда при загрузке модуля автоматически
</EM><BR>
<EM>&gt; &gt; могут быть подзагружены все используемые в нем модули, если они еще
</EM><BR>
<EM>&gt; &gt; не загружены. При этом также не нужно будет перечислять имена всех
</EM><BR>
<EM>&gt; &gt; модулей для начальной загрузки. (Сейчас в рефале-6 загрузка не является
</EM><BR>
<EM>&gt; &gt; цивилизованной)
</EM><BR>
<EM>&gt; &gt; Поэтому предлагаю.
</EM><BR>
<EM>&gt; &gt; а) Оставить список (USE e.ModuleNames).
</EM><BR>
<EM>&gt; &gt; б) В имени функции (REF s.name) разрешить использовать полные имена для
</EM><BR>
<EM>&gt; &gt; внешних функций: (REF s.ModuleName s.Name). Имена таких функций s.Name
</EM><BR>
<EM>&gt; &gt; могут безболезненно пересекаться с другими локальными или внешними
</EM><BR>
<EM>&gt; &gt; фунциями. Можно ввести стадию разрешения, которая будет пополнять все
</EM><BR>
<EM>&gt; &gt; ссылки (REF s.Name) до полных.
</EM><BR>
<EM>&gt; &gt; в) В s.ModuleName можно использовать точку, которая при превращении в
</EM><BR>
имя
<BR>
<EM>&gt; &gt; файла переходит в слеш.
</EM><BR>
<EM>&gt; &gt; г) Считать ошибкой, если есть простая ссылка с именем, которое не
</EM><BR>
<EM>&gt; &gt; определено
</EM><BR>
<EM>&gt; &gt; ни локально, ни в одном из USEd модулей.
</EM><BR>
<EM>&gt; &gt; д) Декларации внешних функций пополнить именем модуля, где обнаружено
</EM><BR>
<EM>&gt; &gt; определение функции. Эти декларации вставляются на стадии разрешения,
</EM><BR>
<EM>&gt; &gt; а изначально могут отсутствовать (см.ниже).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; На самом деле я уже давно хотел (но боялся) предложить следующее:
</EM><BR>
<EM>&gt; все имена в момент использования (и разрешить это в исходном синтаксисе
</EM><BR>
<EM>&gt; -
</EM><BR>
<EM>&gt; вроде бы ограничений нет) представлять в виде
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &lt;name&gt; ::= &lt;simple_name&gt; | &lt;module_name&gt;.&lt;simple_name&gt;
</EM><BR>
<EM>&gt; &lt;module_name&gt; ::= &lt;level_name&gt; | &lt;module_name&gt;.&lt;level_name&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; При этом алгоритм следующий: если парсер встретил объявление имени -
</EM><BR>
<EM>&gt; то имя полностью раскрывается со всеми префиксами модулей и помещается в
</EM><BR>
<EM>&gt; таблицу. Если же имя встретилось в момент использования, то оно ищется
</EM><BR>
<EM>&gt; в таблице, но не по полному совпадению, а по совпадению с &quot;хвостом&quot;.
</EM><BR>
<EM>&gt; Если таких совпадений несколько - то ругаться, что имя слабо
</EM><BR>
<EM>&gt; специфицировано. Получается как в Java или C++... Тогда если в
</EM><BR>
<EM>&gt; абстрактном синтаксисе оставить только полностью специфицированные имена
</EM><BR>
<EM>&gt; (а оно так и должно быть), то в принципе можно обойтись и без USE
</EM><BR>
<EM>&gt; (а также и без linkage-спецификаторов - ведь для каждого имени будет
</EM><BR>
<EM>&gt; известен модуль, где оно определено).
</EM><BR>
<EM>&gt; А при компиляции в какой-то формат для динамической загрузки можно,
</EM><BR>
<EM>&gt; если что, создавать хэш-таблицу нужных модулей. Кроме того так мы не
</EM><BR>
<EM>&gt; потянем за собой никаких ненужных модулей если кто-то по ошибке
</EM><BR>
<EM>&gt; подключил их с помощью $use.
</EM><BR>
Арк:
<BR>
С идеей разрешить составные имена, в том числе в исходном синтаксисе,
<BR>
согласен.
<BR>
Когда именно ругаться - надо уточнять. Искать &quot;по хвостам&quot; - тоже
<BR>
сомнительный
<BR>
принцип. Ява ищет от начал, другое дело, что некоторые модули могут быть
<BR>
открыты
<BR>
на использование их имен простым образом (предложением import, по-нашему -
<BR>
use).
<BR>
<P>Идея, что в АС следует оставить только полные имена тоже правильная, если
<BR>
мы
<BR>
договорились о том, что разрешение имен парсером исходного текста уже
<BR>
сделано.
<BR>
Однако мне сам этот подход не вполне нравится. Альтернатива состоит в том,
<BR>
что
<BR>
собственно парсер использует только один исходный файл, а разрешение
<BR>
имен приоизводится отдельно как следующая фаза. Я бы предложил попытаться
<BR>
провести в жизнь оба подхода, то есть сделать как бы два АС: первичный и
<BR>
вторичный.
<BR>
Отличаться они будут только аспектами, связанными с именами и модулями.
<BR>
Если в каком-то встретятся непреодолимые трудности - ну тогдо можно и
<BR>
отказаться.
<BR>
<P>По поводу тезиса 2), что компилятор из АС должен мочь все сделать на основе
<BR>
информации об одном АС-модуле, у меня тоже есть сомнения, поскольку одному
<BR>
компилятору (как нынешний Рефал-6) достаточно и исходного модуля,
<BR>
Рефалу Плюс требуется кое-что от определений других модулей (форматы,
<BR>
например), а где гарантия, что новому компилятору не понадобится еще
<BR>
какая-нибудь информация (например, о вызываемости функциями друг друга).
<BR>
<P>Я бы хотел, чтобы еще кто-то высказался по этому вопросу. (Сережа Абрамов,
<BR>
ау!).
<BR>
Коротко повторю:
<BR>
Есть выбор из следующих вариантов:
<BR>
<P>A) Парсер использует как вход только один файл, выдает АС-модуль
<BR>
с неразрешенными именами.
<BR>
<P>B) Парсер использует данный файл и все его окружение и выдает
<BR>
АС-модуль, в котором все имена разрешены и имеется вся информация
<BR>
об их определениях, достаточная для (любого?) компилятора.
<BR>
<P>C) Реализуются оба варианта, то есть реализуется вариант A), который затем
<BR>
дополняется до B) написанием отдельной фазы (StaticElaboration), которая
<BR>
соберет всю информацию, достаточную для дальнейшей компиляции.
<BR>
А суть варианта C) в том, чтобы сейчас выработать и опубликовать оба
<BR>
стандартных
<BR>
представления АС, как до StaticElaboration, так и после него. Как вы
<BR>
понимете,
<BR>
я за 3).
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; &gt; 4) Описания определений всех объектов изменены в соответствии с 3).
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Вспомним философское замечание в начале письма. Данное изменение
</EM><BR>
<EM>&gt; &gt; предполагает, что поиск внешних определений произведен на стадии
</EM><BR>
<EM>&gt; &gt; до формирования АС, то есть парсером. Я не уверен, что это правильно.
</EM><BR>
<EM>&gt; &gt; Можно ли услышать аргументацию за это?
</EM><BR>
<EM>&gt; &gt; Мне лично кажется, что парсеру следовало поручить только обработку
</EM><BR>
<EM>&gt; &gt; отдельного файла,
</EM><BR>
<EM>&gt; &gt; а разрешение внешних имен выполнить как этап обработки в рамках АС.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Дело то в том, что модуль может и не существовать в виде АС,
</EM><BR>
<EM>&gt; а например будет только в откомпилированном виде + include file.
</EM><BR>
<EM>&gt; И что тогда делать? Парсер абстрактного синтаксиса не должен иметь
</EM><BR>
<EM>&gt; дело с синтаксисом include file'а конкретного рефала. Здесь есть некая
</EM><BR>
<EM>&gt; аналогия с .class-файлами в той же Java - там все имена уже полностью
</EM><BR>
<EM>&gt; специфицированы.
</EM><BR>
Арк:
<BR>
Ну, class-файлы, это уже результат компиляции, а никак не AC. А в целом
<BR>
данный аргумент (&quot;что модуль может и не существовать в виде AC&quot; -
<BR>
то есть в виде исходного текста, да?) говорит больше в пользу моего
<BR>
подхода:
<BR>
парсер работает только одним исходным файлом, тем, для которого его
<BR>
попросили. Если компилятору понадобилась дополнительная информация - он
<BR>
ее возьмет либо в ранее скомпилированных им структурах, которые этот
<BR>
компилятор и понимает, либо запустит парсер для других исходных модулей.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; При разрешении имен ведь нужно будет обращаться к интерфейсам других
</EM><BR>
<EM>&gt; &gt; модулей, то есть опять же к парсеру от них. (А если интерфейсы не
</EM><BR>
отделены,
<BR>
<EM>&gt; &gt; то и к парсеру от самих модулей). А что разрешатель будет иметь
</EM><BR>
<EM>&gt; &gt; как исходый материал для своей работы?
</EM><BR>
<EM>&gt; &gt; Если же парсер сделать только считывающим один файл, то разрешение имен
</EM><BR>
<EM>&gt; &gt; тогда
</EM><BR>
<EM>&gt; &gt; формализуется как этап обработки АС-терма, пополняющий его информацией.
</EM><BR>
<EM>&gt; &gt; Для некоторых реализаций (компиляторов) он будет не нужен (как например
</EM><BR>
<EM>&gt; &gt; для Рефала-6, с учетом его виртуального кода).
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<P><EM>&gt; &gt; &gt; 5) Добавлен оператор FLUSH - см. мое письмо от 26 ноября в 16:14.
</EM><BR>
---опущено
<BR>
<EM>&gt; &gt; &gt; 6) NOT и ITER сохранены как есть. С моей точки зрения их раскрытие
</EM><BR>
<EM>&gt; &gt; &gt;    слишком далеко двигает нас в сторону виртуального кода и может
</EM><BR>
<EM>&gt; &gt; &gt;    привести к менее удобному представлению при компиляции в
</EM><BR>
<EM>&gt; &gt; &gt;    императивные языки.
</EM><BR>
<EM>&gt; &gt; Это нормально. Но не отменяет возможности на ранней стадии компиляции
</EM><BR>
<EM>&gt; &gt; устранить NOT и ITER путем их раскрытия в АС же. Я не вижу почему эти
</EM><BR>
<EM>&gt; &gt; раскрытия специфичны для какого-то одного типа реализации. Полагаю,
</EM><BR>
<EM>&gt; &gt; они универсальны.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Я не против возможных расширений, но мне существенно не нравится
</EM><BR>
<EM>&gt; использование
</EM><BR>
<EM>&gt; LABEL в раскрытии ITER. Я бы еще согласился на
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; t.Label ::= (LABEL s.LabelName e.Sentence)
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; чтобы получились помеченные предложения, но не LABEL как
</EM><BR>
<EM>&gt; абстрактная метка.
</EM><BR>
Арк:
<BR>
Какая, собственно, разница?  А правильно ли я понимаю, что в твоем варианте
<BR>
после t.Label не должно быть продолжения предложения? (То есть t.Label
<BR>
тогда
<BR>
должен относиться к так называемым терминирующим операторам, таким как
<BR>
FAIL.) И тот же вопрос относительно Try и Iter (в последнем варианте).
<BR>
Замечу, что в своем (предыдущем) варианте я старался минимизировать
<BR>
количество таких операторов. Поэтому и у Error нет явного аргумента, его
<BR>
аргумент - все окончание предложения.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; &gt; 7) Немного изменены прагмы - но это не существенно.
</EM><BR>
<EM>&gt; &gt; &gt; 8) В конце приведен вариант синтаксиса, в котором есть нераскрытые
</EM><BR>
<EM>&gt; &gt; &gt; константы.
</EM><BR>
<EM>&gt; &gt; Это хорошо. Неясно теперь, как используются константы в теле программы.
</EM><BR>
<EM>&gt; &gt; Например, можно как (REF name), имея в виду, что такая конструкция
</EM><BR>
всегда
<BR>
<EM>&gt; &gt; подразумевает ее замену на значение константы по имени name. В случае
</EM><BR>
<EM>&gt; &gt; фукнций
</EM><BR>
<EM>&gt; &gt; и объектов следует считать, что строятся автоматически определения
</EM><BR>
<EM>&gt; &gt; констант,
</EM><BR>
<EM>&gt; &gt; значениями которых являются настоящие символы-ссылки.
</EM><BR>
<EM>&gt; &gt; Однако, обращаю внимание, что значением константы в общем случае будет
</EM><BR>
<EM>&gt; &gt; не обязательно символ, и даже не обязательно терм. Но всегда -
</EM><BR>
объектное
<BR>
<EM>&gt; &gt; (в смысле - ground) выражение, которое может быть всюду, включая
</EM><BR>
жесткий
<BR>
<EM>&gt; &gt; образец.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Как я уже писал - я бы ограничил константы до терма и ввел define'ы,
</EM><BR>
<EM>&gt; которые раскрываются сразу - на самом деле этого хватает для всего.
</EM><BR>
<EM>&gt; Я думаю, на первых порах можно константы сразу раскрывать, а позже
</EM><BR>
<EM>&gt; эту часть синтаксиса довести до ума.
</EM><BR>
Арк:
<BR>
Я хотел сказать, что, если уж имена-константы определяются в АС, то надо
<BR>
не забыть указать, как они там используются.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; Да, это расширение из Рефала-6. Он означает, что выражение должно быть
</EM><BR>
<EM>&gt; &gt; вычислено в момент загрузки. Вычисляется ради побочного эффекта,
</EM><BR>
<EM>&gt; &gt; значение игнорируется. Есть одна тонкость: момент вычисления
</EM><BR>
определяется
<BR>
<EM>&gt; &gt; положением среди других элементов. При этом нет гарантии, что
</EM><BR>
нижеследующие
<BR>
<EM>&gt; &gt; определения функций уже загружены и могут выполняться. Также уже должны
</EM><BR>
<EM>&gt; &gt; быть загружены целиком другие модули, которые используются из данного.
</EM><BR>
<EM>&gt; &gt; А это, в частности, означает, что в графе использований модулями друг
</EM><BR>
друга
<BR>
<EM>&gt; &gt; не должно быть циклов.
</EM><BR>
<EM>&gt; &gt; Вообще, я думаю, это полезная конструкция, посколку позволяют делать
</EM><BR>
<EM>&gt; &gt; модули,
</EM><BR>
<EM>&gt; &gt; которые содержат в себе свою инициализацию (содержимого ящиков,
</EM><BR>
например),
<BR>
<EM>&gt; &gt; и не требуют от пользователя вызывать инициализацию явно.
</EM><BR>
<EM>&gt; &gt; Кроме того, такие модули могут представлять самодостаточные программы,
</EM><BR>
не
<BR>
<EM>&gt; &gt; требующие указывать их входные точки (GO, Main, и т.п.).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Это все понятно и хорошо, правда проблем - не оберешься (см. мое
</EM><BR>
<EM>&gt; следующее
</EM><BR>
<EM>&gt; письмо).
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; А теперь несколько новых замечаний-дополнений.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; 1. Для объектов типов BOX, STRING, VECTOR и, возможно, TABLE - вести
</EM><BR>
<EM>&gt; &gt; понятие начального значения:
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; t.Object        ::= (s.Linkage s.ObjectType s.ObjectName
</EM><BR>
e.InitialValue)
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; e.InitialValue    ::= e.ResultExpression
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; (ограничения - те же, что и для initializer'а.
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Я уже думал над этим. Только непонятно, кто будет проверять, что
</EM><BR>
<EM>&gt; начальное значение, скажем для VECTOR имеет корректный формат?
</EM><BR>
Арк:
<BR>
В момент засылки, то есть при загрузке.
<BR>
<EM>&gt; И еще - начальное значение возможно только для s.IntLinkage.
</EM><BR>
Арк:
<BR>
Конечно.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; 2. PragmaTrace. Отсутствует traceAll. Преднамеренно?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Да. TraceAll - это Trace с пустым списком.
</EM><BR>
Арк:
<BR>
Можно и так.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; 3. В последнем письме от 17.12 ты предлагаешь разделить декларацию и
</EM><BR>
<EM>&gt; &gt; определения.
</EM><BR>
<EM>&gt; &gt; Мне кажется, это тоже можно вводить как стадию обработки в рамках АС.
</EM><BR>
Но
<BR>
<EM>&gt; &gt; может
</EM><BR>
<EM>&gt; &gt; компилятору это и не требуется?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Компилятору в момент использования функции надо знать ее форматы.
</EM><BR>
<EM>&gt; Если не разносить декларацию и определение, то потребуется два прохода.
</EM><BR>
Арк:
<BR>
А разве результат парсера не является объектным выражением, целиком
<BR>
находящимся оперативной памяти? Тогда лишний проход не составляет
<BR>
проблемы. А некоторые компиляторы все равно будут делать лишние проходы.
<BR>
Например, компилятор в Яву может интересоваться графом вызовов для
<BR>
оптимизации.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; Надеюсь, не слишком утомил?
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Конечно, нет :-))
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Всего доброго,
</EM><BR>
<EM>&gt; Андрей.
</EM><BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0077.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0075.html">Arkady Klimov: "Re: Announce: Refal+ v1.8.1 and future plans"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="0074.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="0077.html">Andrey Slepuhin: "Re: Refal+ abstract syntax"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="0074.html">Arkady Klimov: "Re: Refal+ abstract syntax"</A>
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.fts.frontec.se/~dast/hypermail/">hypermail 2b25</A> 
: <EM>Mon Oct 25 2004 - 21:24:58 MSD</EM>
</EM>
</SMALL>
</BODY>
</HTML>
