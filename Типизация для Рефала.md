Типизация для Рефала-5(λ)
=========================

_Александр Коновалов, июль 2020_

<script src="toc.js"></script>
<script>
makeTOC.localizedHeader = "Содержание"
makeTOC.localizedShow = "Показать";
makeTOC.localizedHide = "Скрыть";
</script>

Синтаксис
---------

**Типы объектных выражений** предлагается описывать при помощи грамматик,
нетерминалами которых выступают переменные (имена типов), в алфавит терминалов
входят символы Рефала и структурные скобки. (Расширение на квадратные скобки
тривиально, поэтому для простоты изложения его рассматривать не будем.)

Правила грамматики имеют вид

    〈имя-типа〉 ::= 〈ти́повое-выражение〉

где `〈имя-типа〉` — перемеменная (типа s-, t- или e-), а `〈типовое-выражение〉` —
выражение РБНФ, построенное из символов Рефала, переменных, круглых скобок,
фигурных скобок `{`, `}`, знака `|` и знаков `*`, `+`, `?`.

* Символы в правой части описывают символы, переменные — вхождения
  соответствующих нетерминалов, структурные скобки — структурные скобки.
* Наивысший приоритет имеют квантификаторы — знаки `*`, `+`, `?`, которые
  обозначают итерацию, позитивную итерацию и опцию. Знаки `+` и `?` являются
  синтаксическим сахаром, поэтому в теоретических выкладках использоваться,
  как правило, не будут.
* Следующей операцией по уровню приоритета является конкатенация, обозначаемая
  пробелов.
  Выражение `'ab'*` означает строки `'a'`, `'ab'`, `'abb'` и т.д.
* Наинизший приоритет имеет знак `|` означающий альтернативу.
* Знаки `{` и `}` используются для группировки и изменения приоритета.
* Скобки (структурные Рефала и группирующие фигурные) должны быть правильно
  сбалансированы.
* Пустое выражение мы будем обозначать при помощи знака `ε`.

Операция конкатенации ассоциативна. Операция альтернативы коммутативна
и ассоциативна.

Множество значений типа также может быть пустым, что мы будем обозначать
для наглядности знаком `з`.

Типы, описанные при помощи e-, t- и s-переменных, мы будем называть,
соответственно, **e-типами,** **t-типами** и **s-типами.**

Правая часть в правиле должна описывать _синтаксическое_ подмножество значений
типа слева.

* У e-типов справа может быть записано произвольное выражение.
* Правило для t-типов может иметь вид:
  ```
  t.Name ::= 〈терм〉 | 〈терм〉 …
  ```
  где `〈терм〉` — символ, произвольное выражение в скобках, s- или t-тип.
  Иначе говоря, на верхнем уровне выражения запрещены квантификаторы,
  конкатенация, e-типы и фигурные скобки, также выражение справа не может
  быть пустым. Таким образом обеспечивается, что значение t-типа может быть
  только одним объектным термом.
* Аналогично для s-типов в правой части правила может быть только набор
  альтернатив, включающий только символы и другие s-типы.

Можно было ввести требование _семантического_ значений для переменных типа,
например, следующие типы были бы допустимыми:

    e.OneTerm ::= (A*)
    e.Empty ::= ε
    t.OneTerm ::= e.OneTerm | e.Empty X e.Empty

Но работать с такими типами было бы гораздо сложнее.

Множество значений типа также может быть пустым, что мы будем обозначать
при помощи знака `@` — множество объектных выражений, описываемых этим
типом пустое (∅). В реальных программах этот тип будет использоваться редко
(возможно, только для записи типа результата функции `Exit`), но он будет
полезен в промежуточных выкладках и теоретических построениях.

Любое типовое выражение, содержащее символ `@` можно либо привести к выражению,
состоящему из единственного символа `@`, либо к выражению, этого символа
не содержащему. Для этого достаточно воспользоваться следующими правилами
сокращения:

    E @ = @ E = @
    E | @ = @ | E = E
    (@) = @+ = @
    @* = @? = ε

Нотация также подразумевает использование нескольких предопределённых
типов: `s.CHAR`, `s.WORD`, `s.NUMBER` означают соответствующие категории
символов Рефала-5 — множество литер, множество слов (составных символов,
идентификаторов) и множество чисел (макроцифр). В Рефале-5λ к ним можно
добавить `s.FUNCTION` — указатель на функцию или замыкание. Но здесь типы
высшего порядка мы рассматривать не будем, ограничимся только первым порядком.

Также удобно ввести обозначения `s.ANY`, `t.ANY` и `e.ANY` — любой символ,
любой терм и любое выражение. Можно считать, что они определены как

    s.ANY ::= s.CHAR | s.WORD | s.NUMBER
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

Типы `s.ANY`, `t.ANY` и `e.ANY` далее мы будем называть **универсумом.**

Типы вида `s.CHAR`, `s.WORD` и `s.NUMBER` будем называть **субуниверсумами.**

Набор таких правил грамматики, что в левых частях все имена типов разные,
а в правых частях используются переменные, для которых в наборе есть правила,
либо они предопределённые, будем называть **грамматикой типов.**

Аксиому грамматики явно вводить не будем, типы, определённые в этом наборе
правил, могут использоваться в описаниях типов функции (см. далее). Причём типы
разных функций могут зависеть от разных типов грамматики. В крайнем случае можно
считать, что аксиомами являются все типы, которые упоминаются хотя бы в одном
типе функции.

Далее по тексту имена s-, t- и e-типов для краткости будут называться s-, t-
и e-переменными, если это не приводит к недоразумениям.

**Тип функции** записывается следующим образом:

    <〈имя-функции〉 〈типовое-выражение〉> == 〈типовое-выражение〉

Знак `==` символизирует, что функция может вычислять свой результат за несколько
шагов рефал-машины. Типовое выражение внутри угловых скобок описывает тип
аргумента, типовое выражение справа от `==` — тип результата (возвращаемого
значения).

Если тип результата записан как альтернатива, то будем использовать следующий
синтаксический сахар:

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉
      == 〈тип-результата-2〉
         …
      == 〈тип-результата-N〉

что является альтернативной записью для

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉 | … | 〈тип-результата-N〉


Язык типов как неформальная нотация
-----------------------------------
Описанный выше язык типов автор этих строк уже давно использует как
полуформальную нотацию при программировании на Рефале. В частности, эта
нотация используется для описания типов в [Рефале-5λ][R5L], в [Рефал-05][R05],
[в наборе библиотек][R5FW] для Рефала-5 и Рефала-05, в [Модульном Рефале][MR].
В документации к Рефалу-5λ есть даже [приложение][R5L-A], посвящённое
использованию этой нотации в комментариях.

Да. Эта нотация пока используется только в комментариях и служит для
документирования типов функций. Корректность типов, описанных в этой нотации,
автоматически не проверяется — программист сам должен следить за тем, чтобы
комментарии соответствовали действительности.

Притягательной является идея по автоматической верификации типов программ
на Рефале — имея некоторую программу на Рефале и описания типов функций для
неё, проверить, что функции действительно могут принимать значения указанных
типов и что они возвращают значения, входящие в тип результата, типы фактических
аргументов в вызовах функций входят в их формальные типы.

Такая попытка уже [однажды делалась][RTV], но потерпела неудачу. И система
типов, и используемый алгоритм верификации были не до конца продуманы.

В данной работе делается попытка описать теоретические основы для работы
с описанными типами.


Регулярное ограничение на типы
------------------------------

### Мотивация ограничения грамматики

Нотация, описанная выше, позволяет описывать контекстно-свободые (КС) грамматики
произвольного вида. Но произвольные контестно-свободные грамматики слишком
неудобны для анализа. Для них почти нет никаких хороших свойств в смысле
теоретико-множественных операций. Например, операция пересечения множеств
не замкнута на множестве контестно-свободных грамматик. Единственное известное
мне хорошее свойство — пересечение КС-грамматики с автоматной грамматикой тоже
является КС-грамматикой.

Поэтому разумно ограничить грамматики типов таким образом, чтобы хотя бы они
были замкнуты относительно операций над множествами.

Хорошо известно, что таким свойством замкнутости обладают регулярные языки.
Поэтому в поисках ограничений на грамматики типов будем вдохновляться
регулярными языками.

**Внимание!** Далее мы будем рассматривать грамматики без субуниверсумов, т.е.
предопределённых типов вида `s.CHAR`. Под универсумом мы будем понимать набор
типов вида

    s.ANY ::= 〈все символы, явно заданные в грамматике типов〉
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

Позже мы отдельно рассмотрим, каким образом в наш подход можно включить
субуниверсумы.

### Определение регулярной грамматики типов

Будем говорить, что **грамматика типов регулярная,** если не существует вывода
из какого-либо e-типа, что

    e.〈тип〉 →* 〈слева〉 e.〈тип〉 〈справа〉

при этом части сентенциальной формы `〈слева〉` и `〈справа〉` являются правильными
непустыми объектными выражениями, т.е. состоят только из символов и структурных
скобок, при этом скобки сбалансированы.

Идея регулярной грамматики типов состоит в том, что её можно привести к виду,
содержащему в себе элементы регулярных выражений, а также _обладающему
свойствами замкнутости_ относительно операций над множествами _подобно
регулярным выражениям.

Чтобы грамматика типов не была регулярной, части сентенциальной формы `〈слева〉`
и `〈справа〉` должны одновременно удовлетворять двум свойствам:

* оба являются корректными объектными выражениями,
* эти выражения непустые.

Если хотя бы одно из этих требований не выполняется, грамматику можно привести
к «регулярному виду».

В [работе Ёмера Эгециоглю][Omer2009] со ссылкой на Хомского утверждается, что
если если грамматика несамовложимая (non-self-embedding), то она описывает
регулярный язык. В нашем случае самовложение допустимо, но оно должно быть
внутри структурных скобок.

### Нормальная форма регулярной грамматики типов

Опишем **нормальную форму регулярной грамматики типов:**

* Все типы грамматики объединены в тройки: для каждого типа, описываемого
  переменной с некоторым индексом, существуют связанные с ним два типа других
  видов с тем же индексом. Тройка типов с одинаковым индексом объединена
  следующим соотношением:
  ```
  t.SomeType ::= s.SomeType | (e.SomeType)
  ```
* Все t-типы определены так, как описано выше.
* Типовое выражение для s-типа может быть либо `@`, либо перечислением
  константных символов (не может включать s-переменные).
* Типовое выражение для e-типа может быть либо `@`, либо состоять только
  из t-переменных, фигурных скобок, знаков `|` и `*`.

Далее для краткости нормальную форму регулярной грамматики типов будем
называть **регулярной нормальной формой.**

### Преобразование грамматики к нормальной форме

Можно показать, что любую регулярную грамматику типов можно привести
к регулярной нормальной форме.

Преобразование выполняется в несколько этапов:

1. Устранение квантификаторов `?` и `+`.
2. Назначение типам уникальных индексов — в результате в грамматике не должно
   остаться типов разного вида с одинаковыми индексами.
3. Упрощение правил для s- и t-типов
4. Построение троек для s- и e-типов.
5. Нормализация и построение троек для t-типов.
6. Устранение символов, s-переменных и круглых скобок из правил для e-типов.
7. Устранение e-переменных из правил для e-типов.

В ходе дальнейших преобразований мы будем определять новые типы. Тип с индексом
`.NEW` будет означать создание новой тройки типов с индексом, который
не совпадает ни с одним из индексов в рассматриваемой грамматике.

#### 1. Устранение квантификаторов `?` и `+`

Квантификаторы `?` и `+` устраняются как синтаксический сахар по правилам:

    EXPR? → { ε | EXPR }
    EXPR+ → EXPR EXPR*

Это самый простой и тривиальный этап.

#### 2. Назначение типам уникальных индексов

В исходной грамматике могут присутствовать типы, обозначенные переменными
разного вида, но с одинаковым индесом. При нормализации нам потребуется
преобразовывать типы в тройки типов — для каждого s-типа создавать связанные
типы t- и e-, и аналогично для типов других видов. Поэтому для предупреждения
конфликта имён типы исходной грамматики нужно переименовать.

Самый простой способ переименования — просто пронумеровать типы
последовательными натуральными числами. Но при этом также придётся сохранять
отображение «число → исходное имя», например, для целей отладки.

Альтернативный вариант преобразования, сохраняющий исходные имена, следующий.
Все e-типы вида `e.〈имя〉` переименовываются в `e.e〈имя〉`, аналогично
переименовываются типы других видов: `t.〈имя〉` → `t.t〈имя〉`, `s.〈имя〉` →
`s.s〈имя〉`.

Для целей нормализации не важно, каким образом будут создаваться уникальные
индексы, но это может быть важно в самом приложении.

#### 3. Упрощение правил t- и s-типов

Правила для s- и t-типов по определению имеют вид

    〈тип〉 → 〈терм1〉 | 〈терм2〉 | … | 〈термN〈

Т.е. фактически их можно рассматривать просто как множества, элементами
которых являются термовые типовые выражения. Для s-типов элементами множества
будут конкретные значения символов и имена s-типов. Для t-типов те же элементы,
что и для s-типов плюс t-переменные и типовые выражения в структурных скобках.

Опишем процедуру, позволяющую устранить из описаний s- и t-типов ссылки
на другие s- и t-типы. В результате правила для s-типов будут включать только
символьные константы, а правила для t-типов — символьные константы и типовые
выражения в скобках.

* Для каждого s- и t-типа `〈T〉` введём множество `SET[〈T〉]`.
* Для каждого правила
  ```
  〈T〉 ::= 〈T1〉 | 〈T2〉 | … | 〈Tn〉
  ```
  где `〈Ti〉` — типовое выражение для терма, проинициализируем множество
  ```
  SET[〈T〉] := { 〈T1〉, 〈T2〉, …, 〈Tn〉 }
  ```
* Следующий цикл повторяем, пока множества `SET[〈T〉]` не перестанут изменяться:
  ```
  Для каждого s- и t-типа 〈T〉 исходной программы:
    Для каждого 〈U〉 ∈ SET[〈T〉], такого что 〈U〉 является s- или t-переменной:
      SET[〈T〉] := SET[〈T〉] ⋃ SET[〈U〉]
  ```
* Из элементов `SET[〈T〉]` удаляем все термы-переменные на верхнем уровне (т.е.
  внутри скобочных термов ничего не трогаем).
* Заменяем правила для s- и t-типов на правила
  ```
  〈T〉 ::= 〈T1〉 | 〈T2〉 | … | 〈Tn〉
  ```
  где `〈Ti〉` — соответствующие элементы множеств `SET[〈T〉]`. Если множество
  пустое, то добавляется правило
  ```
  〈T〉 ::= @
  ```

#### 4. Построение троек для s- и e-типов

Для этих типов тройки строятся тривиально. Для каждого s-типа `s.〈имя〉`
строятся t- и e-типы

    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)
    e.〈имя〉 ::= @

Аналогично для e-типа `e.〈имя〉`:

    s.〈имя〈 ::= @
    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)

#### 5. Нормализация и построение троек для t-типов

Для t-типов процедура чуть более интересна. После упрощения t-типы имеют вид:

    t.〈имя〈 ::= 〈Sym1〉 | … | 〈SymM〉 | (〈Expr1〉) | … | (〈ExprN〉)

Все значения-символы переносим в s-тип, все содержимые скобок — в e-тип:

    s.〈имя〉 ::= 〈Sym1〉 | … | 〈SymM〉
    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)
    e.〈имя〉 ::= 〈Expr1〉 | … | 〈ExprN〉

#### 6. Устранение символов, s-переменных и круглых скобок из правил для e-типов

От нормальной формы нас отделяет только вид правил для e-типов. В типовых
выражениях для e-правил могут использоваться только t-переменные, фигурные
скобки и знаки `|` и `*`. Т.е. из описаний e-типов нам нужно исключить
константные символы, s-переменные, структурные скобки и e-переменные.

Устранять их будем поэтапно.

1. Устраняем константные символы. Для каждого вхождения символа `〈Sym〉`
   в правиле для e-типа создаётся тройка:
   ```
   s.NEW ::= 〈Sym〉
   t.NEW ::= s.NEW | (e.NEW)
   e.NEW ::= @
   ```
   После этого каждое символа этого `〈Sym〉` в правилах для e-типов заменяется
   на `t.NEW`.
2. Каждое вхождение s-типа заменяется на одноимённый t-тип. Действительно,
   каждый из s-типов исходной грамматики мы достроили до тройки, t-тип которой
   идентичен исходному s-типу, т.к. e-тип тройки является пустым множеством.
3. Для каждого скобочного терма `(〈Expr〉)` в правиле для e-типа создаётся
   новая тройка
   ```
   s.NEW ::= @
   t.NEW ::= s.NEW | (e.NEW)
   e.NEW ::= 〈Expr〉
   ```
   Вхождение `(〈Expr〉)` заменяется на `t.NEW`.
   Этот этап повторяется до тех пор, пока скобочные термы из всех e-правил
   не будут исключены.

Теперь правила для e-переменных содержат только t- и e-переменные, фигурные
скобки и знаки `*` и `|`. Устранять e-переменные сложнее, чем элементы,
рассмотренные в этом параграфе, поэтому им посвящён отдельный подпараграф.

#### 7. Устранение e-переменных из правил для e-типов

E-тип назовём **рекурсивным,** если существует вывод

    e.〈тип〉 →* 〈элементы-слева〉 e.〈тип〉 〈элементы-справа〉

причём на каждом шаге раскрываются только e-переменные, либо упрощаются
правила РБНФ: альтернатива коллапсирует в один из её элементов, итерация
заменяется на некоторое количество последовательных вхождений повторяемого
элемента. Т.е. в этом выводе не участвуют правила для t-типов.

Если такого вывода нет, то e-тип назовём **нерекурсивным.**

Очевидно, каждое вхождение имени нерекурсивного e-типа в правило для другого
e-типа можно заменить правой частью этого e-типа (при необходимости заключив
в фигурные скобки). Повторять операцию подстановки нерекурсивных типов можно
конечное число раз.

Для регулярной грамматики типов любой рекурсивный тип может быть либо
леворекурсивным, либо праворекурсивным. (Вообще-то, это теорема, но автору
доказывать её лень.)

**Леворекурсивным** назовём такой тип, рекурсивные раскрытия которого имеют
вид:

    e.〈тип〉 →* e.〈тип〉 〈элементы-справа〉

При этом, как и раньше в раскрытии не участвуют t-типы.

**Праворекурсивный** тип определяем аналогично.

Наша задача состоит в том, чтобы каждый рекурсивный тип преобразовать
в нерекурсивный. После преобразования некоторого типа в нерекурсивный, все
его вхождения в грамматике можно заменить на правую часть его правила и таким
образом устранить вхождения одной из e-переменных.

Определим процедуру **преобразования рекурсивного типа в нерекурсивный.** Будем
рассматривать леворекурсивный тип. Процедура для праворекурсивных типов,
очевидно, будет точно такой же, только формулы будут записаны зеркально
симметрично.

Правило для леворекурсивного типа имеет вид

    e.〈тип〉 ::= 〈Альтернатива1〉 | … | 〈АльтернативаN〉

(альтернатива может быть и единственной, т.е. `N = 1`)

Альтернатива имеет следующий вид

    〈Альтернатива〉 → 〈Голова〉 〈Хвост〉

При этом `〈Хвост〉` не может содержать e-типы, которые при раскрытии могут дать
исходный тип.



[R5L]: https://github.com/bmstu-iu9/refal-5-lambda
[R05]: https://github.com/Mazdaywik/Refal-05
[R5FW]: https://github.com/Mazdaywik/refal-5-framework
[MR]: https://github.com/Mazdaywik/MRefal
[R5L-A]: https://bmstu-iu9.github.io/refal-5-lambda/A-formats-and-types
[RTV]: https://github.com/bmstu-iu9/refal-type-verifier
[Omer2009]: https://www.cs.ucsb.edu/sites/default/files/docs/reports/2009-06.pdf
