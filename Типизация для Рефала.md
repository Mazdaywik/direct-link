Типизация для Рефала-5
======================

_Александр Коновалов, июль 2020_

<script src="toc.js"></script>
<script>
makeTOC.localizedHeader = "Содержание"
makeTOC.localizedShow = "Показать";
makeTOC.localizedHide = "Скрыть";
</script>

Синтаксис
---------

Переменные в Рефале бывают трёх разновидностей: s-, t- и e-переменные. Обычно,
`s`, `t` и `e` называют типами переменных, но в данной работе термин «тип»
удобнее использовать для других целей. Поэтому разновидности переменных `s`,
`t` и `e` мы будем называть **видами** переменных.

**Типы объектных выражений** предлагается описывать при помощи грамматик,
нетерминалами которых выступают переменные (имена типов), в алфавит терминалов
входят символы Рефала и структурные скобки. (Расширение на квадратные скобки
тривиально, поэтому для простоты изложения его рассматривать не будем.)

Правила грамматики имеют вид

    〈имя-типа〉 ::= 〈ти́повое-выражение〉

где `〈имя-типа〉` — перемеменная (вида s-, t- или e-), а `〈типовое-выражение〉` —
выражение РБНФ, построенное из символов Рефала, переменных, круглых скобок,
фигурных скобок `{`, `}`, знака `|` и знаков `*`, `+`, `?`.

* Символы в правой части описывают символы, переменные — вхождения
  соответствующих нетерминалов, структурные скобки — структурные скобки.
* Наивысший приоритет имеют квантификаторы — знаки `*`, `+`, `?`, которые
  обозначают итерацию, позитивную итерацию и опцию. Знаки `+` и `?` являются
  синтаксическим сахаром, поэтому в теоретических выкладках использоваться,
  как правило, не будут.
* Следующей операцией по уровню приоритета является конкатенация, обозначаемая
  пробелов.
  Выражение `'ab'*` означает строки `'a'`, `'ab'`, `'abb'` и т.д.
* Наинизший приоритет имеет знак `|` означающий альтернативу.
* Знаки `{` и `}` используются для группировки и изменения приоритета.
* Скобки (структурные Рефала и группирующие фигурные) должны быть правильно
  сбалансированы.
* Пустое выражение мы будем обозначать при помощи знака `ε`.

Операция конкатенации ассоциативна. Операция альтернативы коммутативна
и ассоциативна.

Типы, описанные при помощи e-, t- и s-переменных, мы будем называть,
соответственно, **e-типами,** **t-типами** и **s-типами.**

Правая часть в правиле должна описывать _синтаксическое_ подмножество значений
типа слева.

* У e-типов справа может быть записано произвольное выражение.
* Правило для t-типов может иметь вид:
  ```
  t.Name ::= 〈терм〉 | 〈терм〉 …
  ```
  где `〈терм〉` — символ, произвольное выражение в скобках, s- или t-тип.
  Иначе говоря, на верхнем уровне выражения запрещены квантификаторы,
  конкатенация, e-типы и фигурные скобки, также выражение справа не может
  быть пустым. Таким образом обеспечивается, что значение t-типа может быть
  только одним объектным термом.
* Аналогично для s-типов в правой части правила может быть только набор
  альтернатив, включающий только символы и другие s-типы.

Можно было ввести требование _семантического_ значений для переменных типа,
например, следующие типы были бы допустимыми:

    e.OneTerm ::= (A*)
    e.Empty ::= ε
    t.OneTerm ::= e.OneTerm | e.Empty X e.Empty

Но работать с такими типами было бы гораздо сложнее.

Множество значений типа также может быть пустым, что мы будем обозначать
при помощи знака `@` — множество объектных выражений, описываемых этим
типом пустое (∅). В реальных программах этот тип будет использоваться редко
(возможно, только для записи типа результата функции `Exit`), но он будет
полезен в промежуточных выкладках и теоретических построениях.

Любое типовое выражение, содержащее символ `@` можно либо привести к выражению,
состоящему из единственного символа `@`, либо к выражению, этого символа
не содержащему. Для этого достаточно воспользоваться следующими правилами
сокращения:

    E @ = @ E = @
    E | @ = @ | E = E
    (@) = @+ = @
    @* = @? = ε

Нотация также подразумевает использование нескольких предопределённых
типов: `s.CHAR`, `s.WORD`, `s.NUMBER` означают соответствующие категории
символов Рефала-5 — множество литер, множество слов (составных символов,
идентификаторов) и множество чисел (макроцифр). В Рефале-5λ к ним можно
добавить `s.FUNCTION` — указатель на функцию или замыкание. Но здесь типы
высшего порядка мы рассматривать не будем, ограничимся только первым порядком.

Также удобно ввести обозначения `s.ANY`, `t.ANY` и `e.ANY` — любой символ,
любой терм и любое выражение. Можно считать, что они определены как

    s.ANY ::= s.CHAR | s.WORD | s.NUMBER
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

Типы `s.ANY`, `t.ANY` и `e.ANY` далее мы будем называть **универсумом.**

Типы вида `s.CHAR`, `s.WORD` и `s.NUMBER` будем называть **субуниверсумами.**

Набор таких правил грамматики, что в левых частях все имена типов разные,
а в правых частях используются переменные, для которых в наборе есть правила,
либо они предопределённые, будем называть **грамматикой типов.**

Аксиому грамматики явно вводить не будем, типы, определённые в этом наборе
правил, могут использоваться в описаниях типов функции (см. далее). Причём типы
разных функций могут зависеть от разных типов грамматики. В крайнем случае можно
считать, что аксиомами являются все типы, которые упоминаются хотя бы в одном
типе функции.

Далее по тексту имена s-, t- и e-типов для краткости будут называться s-, t-
и e-переменными, если это не приводит к недоразумениям.

**Тип функции** записывается следующим образом:

    <〈имя-функции〉 〈типовое-выражение〉> == 〈типовое-выражение〉

Знак `==` символизирует, что функция может вычислять свой результат за несколько
шагов рефал-машины. Типовое выражение внутри угловых скобок описывает тип
аргумента, типовое выражение справа от `==` — тип результата (возвращаемого
значения).

Если тип результата записан как альтернатива, то будем использовать следующий
синтаксический сахар:

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉
      == 〈тип-результата-2〉
         …
      == 〈тип-результата-N〉

что является альтернативной записью для

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉 | … | 〈тип-результата-N〉


Язык типов как неформальная нотация
-----------------------------------
Описанный выше язык типов автор этих строк уже давно использует как
полуформальную нотацию при программировании на Рефале. В частности, эта
нотация используется для описания типов в [Рефале-5λ][R5L], в [Рефал-05][R05],
[в наборе библиотек][R5FW] для Рефала-5 и Рефала-05, в [Модульном Рефале][MR].
В документации к Рефалу-5λ есть даже [приложение][R5L-A], посвящённое
использованию этой нотации в комментариях.

Да. Эта нотация пока используется только в комментариях и служит для
документирования типов функций. Корректность типов, описанных в этой нотации,
автоматически не проверяется — программист сам должен следить за тем, чтобы
комментарии соответствовали действительности.

Притягательной является идея по автоматической верификации типов программ
на Рефале — имея некоторую программу на Рефале и описания типов функций для
неё, проверить, что функции действительно могут принимать значения указанных
типов и что они возвращают значения, входящие в тип результата, типы фактических
аргументов в вызовах функций входят в их формальные типы.

Такая попытка уже [однажды делалась][RTV], но потерпела неудачу. И система
типов, и используемый алгоритм верификации были не до конца продуманы.

В данной работе делается попытка описать теоретические основы для работы
с описанными типами.


Регулярное ограничение на типы
------------------------------

### Мотивация ограничения грамматики

Нотация, описанная выше, позволяет описывать контекстно-свободые (КС) грамматики
произвольного вида. Но произвольные контестно-свободные грамматики слишком
неудобны для анализа. Для них почти нет никаких хороших свойств в смысле
теоретико-множественных операций. Например, операция пересечения множеств
не замкнута на множестве контестно-свободных грамматик. Единственное известное
мне хорошее свойство — пересечение КС-грамматики с автоматной грамматикой тоже
является КС-грамматикой.

Поэтому разумно ограничить грамматики типов таким образом, чтобы хотя бы они
были замкнуты относительно операций над множествами.

Хорошо известно, что таким свойством замкнутости обладают регулярные языки.
Поэтому в поисках ограничений на грамматики типов будем вдохновляться
регулярными языками.

**Внимание!** Далее мы будем рассматривать грамматики без субуниверсумов, т.е.
предопределённых типов вида `s.CHAR`. Под универсумом мы будем понимать набор
типов вида

    s.ANY ::= 〈все символы, явно заданные в грамматике типов〉
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

Позже мы отдельно рассмотрим, каким образом в наш подход можно включить
субуниверсумы.

### Определение регулярной грамматики типов

Будем говорить, что **грамматика типов регулярная,** если не существует вывода
из какого-либо e-типа, что

    e.〈тип〉 →* 〈слева〉 e.〈тип〉 〈справа〉

при этом части сентенциальной формы `〈слева〉` и `〈справа〉` являются правильными
объектными выражениями, т.е. состоят только из символов и структурных скобок,
при этом скобки сбалансированы.

Идея регулярной грамматики типов состоит в том, что её можно привести к виду,
содержащему в себе элементы регулярных выражений, а также _обладающему
свойствами замкнутости_ относительно операций над множествами _подобно
регулярным выражениям.

В [работе Омера Эгеджиоглу][Omer2009] со ссылкой на Хомского утверждается, что
если если грамматика несамовложимая (non-self-embedding), то она описывает
регулярный язык. В нашем случае самовложение допустимо, но оно должно быть
внутри структурных скобок.

В принципе, в языке можно ограниченно допустить и «плоскую» рекурсию для
e-типов, но описание частных случаев для этого довольно громоздко, кроме того
неоправданно усложнится алгоритм нормализации.

### Нормальная форма регулярной грамматики типов

Опишем **нормальную форму (НФ) регулярной грамматики типов:**

* Все типы грамматики объединены в тройки: для каждого типа, описываемого
  переменной с некоторым индексом, существуют связанные с ним два типа других
  видов с тем же индексом. Тройка типов с одинаковым индексом объединена
  следующим соотношением:
  ```
  t.SomeType ::= s.SomeType | (e.SomeType)
  ```
* Все t-типы определены так, как описано выше.
* Типовое выражение для s-типа может быть либо `@`, либо перечислением
  константных символов (не может включать s-переменные).
* Типовое выражение для e-типа может быть либо `@`, либо состоять только
  из t-переменных, фигурных скобок, знаков `|` и `*`.

Далее для краткости нормальную форму регулярной грамматики типов будем
называть **регулярной нормальной формой.**

### Преобразование грамматики к нормальной форме

Можно показать, что любую регулярную грамматику типов можно привести
к регулярной нормальной форме.

Будем считать, что в исходной грамматике индексы типов или уникальны, т.е.
не существует двух типов разных видов с одинаковым индексом, или три типа
с одинаковым индексом уже представляют собой тройку, т.е. t-тип выражен
как

    t.〈индекс〉 ::= s.〈индекс〉 | e.〈индекс〉

Примером уже готовой тройки типов является тройка с индексом `.ANY`.

Если это не так, переименуем типы с конфликтующими индексами.

Преобразование выполняется в несколько этапов:

1. Устранение квантификаторов `?` и `+`.
2. Упрощение правил для s- и t-типов.
3. Построение троек для s- и e-типов.
4. Нормализация и построение троек для t-типов.
5. Нормализация для e-типов.

В ходе дальнейших преобразований мы будем определять новые типы. Тип с индексом
`.NEW` будет означать создание новой тройки типов с индексом, который
не совпадает ни с одним из индексов в рассматриваемой грамматике.

#### 1. Устранение квантификаторов `?` и `+`

Квантификаторы `?` и `+` устраняются как синтаксический сахар по правилам:

    EXPR? → { ε | EXPR }
    EXPR+ → EXPR EXPR*

Это самый простой и тривиальный этап.

#### 2. Упрощение правил t- и s-типов

Правила для s- и t-типов по определению имеют вид

    〈тип〉 → 〈терм1〉 | 〈терм2〉 | … | 〈термN〈

Т.е. фактически их можно рассматривать просто как множества, элементами
которых являются термовые типовые выражения. Для s-типов элементами множества
будут конкретные значения символов и имена s-типов. Для t-типов те же элементы,
что и для s-типов плюс t-переменные и типовые выражения в структурных скобках.

Опишем процедуру, позволяющую устранить из описаний s- и t-типов ссылки
на другие s- и t-типы. В результате правила для s-типов будут включать только
символьные константы, а правила для t-типов — символьные константы и типовые
выражения в скобках.

* Для каждого s- и t-типа `〈T〉` введём множество `SET[〈T〉]`.
* Для каждого правила
  ```
  〈T〉 ::= 〈T1〉 | 〈T2〉 | … | 〈Tn〉
  ```
  где `〈Ti〉` — типовое выражение для терма, проинициализируем множество
  ```
  SET[〈T〉] := { 〈T1〉, 〈T2〉, …, 〈Tn〉 }
  ```
* Следующий цикл повторяем, пока множества `SET[〈T〉]` не перестанут изменяться:
  ```
  Для каждого s- и t-типа 〈T〉 исходной программы:
    Для каждого 〈U〉 ∈ SET[〈T〉], такого что 〈U〉 является s- или t-переменной:
      SET[〈T〉] := SET[〈T〉] ⋃ SET[〈U〉]
  ```
* Из элементов `SET[〈T〉]` удаляем все термы-переменные на верхнем уровне (т.е.
  внутри скобочных термов ничего не трогаем).
* Заменяем правила для s- и t-типов на правила
  ```
  〈T〉 ::= 〈T1〉 | 〈T2〉 | … | 〈Tn〉
  ```
  где `〈Ti〉` — соответствующие элементы множеств `SET[〈T〉]`. Если множество
  пустое, то добавляется правило
  ```
  〈T〉 ::= @
  ```

#### 3. Построение троек для s- и e-типов

Если некоторый s- или e-тип уже входит в правильную тройку, то этот этап для
него не выполняется.

Для этих типов тройки строятся тривиально. Для каждого s-типа `s.〈имя〉`
строятся t- и e-типы

    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)
    e.〈имя〉 ::= @

Аналогично для e-типа `e.〈имя〉`:

    s.〈имя〈 ::= @
    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)

#### 4. Нормализация и построение троек для t-типов

Если некоторый тип уже входит в правильную тройку, то этот этап для него
не выполняется.

Для t-типов процедура чуть более интересна. После упрощения t-типы имеют вид:

    t.〈имя〈 ::= 〈Sym1〉 | … | 〈SymM〉 | (〈Expr1〉) | … | (〈ExprN〉)

Все значения-символы переносим в s-тип, все содержимые скобок — в e-тип:

    s.〈имя〉 ::= 〈Sym1〉 | … | 〈SymM〉
    t.〈имя〉 ::= s.〈имя〉 | (e.〈имя〉)
    e.〈имя〉 ::= 〈Expr1〉 | … | 〈ExprN〉

#### 5. Нормализация для e-типов

От нормальной формы нас отделяет только вид правил для e-типов. В типовых
выражениях для e-правил могут использоваться только t-переменные, фигурные
скобки и знаки `|` и `*`. Т.е. из описаний e-типов нам нужно исключить
константные символы, s-переменные, структурные скобки и e-переменные.

Устранять их будем поэтапно.

1. Устраняем константные символы. Для каждого вхождения символа `〈Sym〉`
   в правиле для e-типа создаётся тройка:
   ```
   s.NEW ::= 〈Sym〉
   t.NEW ::= s.NEW | (e.NEW)
   e.NEW ::= @
   ```
   После этого каждое символа этого `〈Sym〉` в правилах для e-типов заменяется
   на `t.NEW`.
2. Каждое вхождение s-типа заменяется на одноимённый t-тип. Действительно,
   каждый из s-типов исходной грамматики мы достроили до тройки, t-тип которой
   идентичен исходному s-типу, т.к. e-тип тройки является пустым множеством.
3. Для каждого скобочного терма `(〈Expr〉)` в правиле для e-типа создаётся
   новая тройка
   ```
   s.NEW ::= @
   t.NEW ::= s.NEW | (e.NEW)
   e.NEW ::= 〈Expr〉
   ```
   Вхождение `(〈Expr〉)` заменяется на `t.NEW`.
   Этот этап повторяется до тех пор, пока скобочные термы из всех e-правил
   не будут исключены.
4. Поскольку грамматика типов является регулярной, «плоских» рекурсивных
   вхождений для e-типов не будет, а значит, все e-переменные в описаниях
   e-типов можно заменить на конкретные значения.

Можно заметить, что в нормальной форме для регулярной грамматики типов выражения
для e-типов фактически являются регулярными выражениями поверх алфавита имён
t-типов. Именно поэтому такая грамматика типов и названа регулярной.

Раз мы можем e-типы описывать при помощи регулярных выражений, возникает соблазн
использовать матапарат для регулярных языков для операций над типами: проверка
вложения, пересечение, объединение, разность, дополнение и т.д. Но не всё так
просто. t-типы, в терминах которых описываются e-типы, могут накладываться друг
на друга, а значит, проводить формальные операции над множествами над ними
бессмысленно.

Поскольку в НФ e-типы описаны как регулярные выражения поверх алфавита t-типов,
можно считать, что e-типы описаны как регулярные языки. А любой регулярный язык
может быть описан и при помощи регулярного выражения, и при помощи конечного
автомата: для любого регулярного выражения можно построить эквивалентный конечный
автомат, для любого конечного автомата можно построить эквивалентное регулярное
выражение. Поэтому, когда нам это будет удобно, будем считать, что e-типы в НФ
описаны не регулярными выражениями, а конечными автоматами.

### Ортогональная нормальная форма грамматики типов

Опишем форму грамматики, в которой выразимы такие операции, как пересечение
и разность множеств. Если грамматику типов формально дополнить универсальным
типом вида

    s.ANY ::= 〈все символы, явно записанные в грамматике〉
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

то дополнение некоторого типа до универсума будет выражаться как разность
универсального и рассматриваемого типа.

Проверка на вложение одного типа в другое сводится к вычислению разности типов
и проверке этой разности на пустоту.

Будем говорить, что два типа одного вида **ортогональны,** если они описывают
непересекающиеся множества объектных выражений.

Опишем **ортогональную нормальную форму (ОНФ) регулярной грамматики типов.**
Типы в ОНФ делятся на две группы — **набор исходных типов,** (`SRC`) т.е. типы,
которые были в исходной грамматике до нормализации, и **набор ортогональных
типов,** (`ORTHO`) построенный в ходе процедуры нормализации.

Типы из `ORTHO` записаны в НФ — s-типы представляют собой множества символов,
e-типы — регулярные языки в алфавите t-типов из `ORTHO`, t-типы — как
объединение s-типа и скобочного терма с e-типом внутри.

Тройки типов из `ORTHO` попарно ортогональны.

Типы из `SRC` описаны как объединения типов соответствующего вида из `ORTHO`.

    s.〈src1〉 ::= s.〈ortho1〉 | … | s.〈orthoK〉
    t.〈src2〉 ::= t.〈ortho1〉 | … | t.〈orthoM〉
    e.〈src3〉 ::= e.〈ortho1〉 | … | e.〈orthoN〉

Очевидно, что для набора исходных типов операции над множествами выражаются
тривиально — как операции над множествами ортогональных типов.

Но при этом не очевидно, что для любой грамматики регулярных типов можно
построить ОНФ.

Покажем, что это возможно — опишем процедуру построения ОНФ.

### Процедура ортогонализации регулярной грамматики типов

Процедуру построения ортогональной нормальной формы для краткости назовём
процедурой **ортогонализации** регулярной грамматики типов.

Как и процедура нормализации, процедура ортогонализации делится на несколько
этапов:

1. Построение нормальной формы и нумерация троек.
2. Построение набора имён ортогональных типов, запись ортогональных t-типов.
3. Выражение исходных t-типов через ортогональные.
4. Вычисление значений ортогональных s-типов.
5. Запись исходных e-типов в алфавите ортогональных типов.
6. Вычисление значений ортогональных e-типов.
7. Выражение исходных s- и e-типов через ортогональные.

Как и ранее, будем считать, что в исходной грамматике типов нет типов разного
вида, но с одинаковыми индексами. Либо есть три типа с одним индексом и они
уже образуют правильную тройку.

Также будем считать, что в исходной грамматике типов нет типов, индексы которых
начинаются на `0` или `1`. Если таковые есть, переименуем их.

#### 1. Построение нормальной формы и нумерация троек

Строим нормальную форму регулярной грамматики. Множество `SRC` инициализируем
как множество построенных типов, множество `ORTHO` — как пустое множество.
Да, в `SRC` в данном случае будут находиться «лишние» типы, которых не было
в исходной грамматике, но это не принципиально. «Лишними» будут типы, которые
были построены в ходе процедуры нормализации — дополнения до троек, символы
и скобочные термы, вынесенные из определений e-типов. Эти «лишние» типы при
необходимости можно безопасно удалить после завершения построения ОНФ.

Также будем считать, что процедура нормализации не создаёт новых типов
с индексами, начинающимися на `0` и `1`.

Каждой тройке в НФ назначаем номер, начиная с `1`. Далее будем считать, что
у нас получилось `N` троек.

#### 2. Построение набора имён ортогональных типов, запись ортогональных t-типов

Сгенерируем `2`<sup>`N`</sup> различных строк из знаков `0` и `1` длиной
`N`. Это будут индексы типов из набора `ORTHO`. Набор `ORTHO` должен быть
описан в нормальной форме, т.е. быть набором троек. Поэтому каждый из этих новых
индексов будет индексом и s-, и t-, и e-типа. Ортогональные t-типы записываются
как

    t.〈ortho〉 ::= s.〈ortho〉 | (e.〈ortho〉)

Каждый тип из `ORTHO` представляет собой пересечение `N` множеств, каждое
из этих множеств — либо множество значений типа данного вида из некоторой
исходной тройки, либо дополнение типа исходной тройки до универсума. Знак `1`
в i-й позиции индекса означает, что i-е множество совпадает с типом
соответствующего вида исходной тройки, знак `0` — что берётся дополнение
этого типа тройки до универсума соответствующего вида.

Если сопоставить два разных индекса типов из `ORTHO`, то найдётся как минимум
одна позиция, где у одного типа будет `1`, а у другого `0`. Пусть это будет
i-я позиция. Тогда первый тип будет подмножеством типа i-й тройки, а второй —
подмножеством её дополнения. Таким образом типы из `ORTHO` будут ортогональными.

Также по построению очевидно, что объединение всех типов некоторого вида
из `ORTHO` образует универсум, а также объединение всех типов некоторого вида
из `ORTHO` с `1` в i-й позиции — компонент соответствующего вида i-й тройки.

Таким образом, весь набор `ORTHO` есть разбиение универсума, а его подмножество
с `1` в i-й позиции — разбиение i-й тройки.

#### 3. Выражение исходных t-типов через ортогональные

Каждый t-тип из `SRC` записываем как объединение t-типов из `ORTHO` с `1`
в i-й позиции, где i — номер тройки данного t-типа:

    t.〈i〉 ::= … | t.〈…〉1〈…〉 | …

#### 4. Вычисление значений ортогональных s-типов

Значения s-типов из `ORTHO` выражаются как пересечения `N` множеств исходных
s-типов или их дополнений.

    s.〈bitstr〉 ::= SET(s, 1, 〈bitstr〉) ⋂ … ⋂ SET(s, N, 〈bitstr〉)

где функция `SET(〈вид〉, i, 〈bitstr〉)` определена как

    SET(mode, i, bitstr) =  mode.i, bitstr[i] == '1'
                         | ~mode.i, bitstr[i] == '0'

Здесь знаком `~` обозначено дополнение до универсума:

    ~〈вид〉.〈имя〉 = 〈вид〉.ANY \ 〈вид〉.〈имя〉

Поскольку s-типы в `SRC` находятся в ортогональной форме, они представляют собой
просто перечисления константных символов без повторений — описывают множество
значений просто в виде перечисления его элементов. Поэтому вычисление конкретных
значений для s-типов из `ORTHO` осуществляется при помощи обычных операций над
множествами.

#### 5. Запись исходных e-типов в алфавите ортогональных типов

t-типы из `SRC` ранее были определены как объединения t-типов из `ORTHO`. Для
записи e-типов в `SRC` в терминах t-типов из `ORTHO` достаточно сделать
соответствующую подстановку t-типов в их регулярные выражения.

Если регулярные языки e-типов были описаны при помощи конечных автоматов,
то преобразование будет сложнее. Каждыйо переход из состояния `Qi` в `Qj`
по символу `t.〈i〉` заменяется на `2`<sup>`N−1`</sup> переходов по t-типам
из `ORTHO`, в индексах которых в i-й позиции находится `1`. Автомат при этом
может стать недетерминированным.

В результате выполнения этого этапа регулярные языки e-типов оказываются
определены в алфавите непересекающихся символов, а это значит, что для
вычисления пересечений и разностей этих языков можно использовать
соответствующие процедуры из теории конечных автоматов.

#### 6. Вычисление значений ортогональных e-типов

Значения e-типов из `ORTHO` записываются аналогично значениям для s-типов:

    e.〈bitstr〉 ::= SET(e, 1, 〈bitstr〉) ⋂ … ⋂ SET(e, N, 〈bitstr〉)

Однако теперь для вычисления пересечений и дополнений множеств используются
соответствующие процедуры из теории конечных автоматов.

#### 7. Выражение исходных s- и e-типов через ортогональные

s- и e-типы из `SRC` выражаются аналогично t-типам ранее — как объединение типов
соответствующего вида из `ORTHO` с `1` в i-й позиции, где i — номер тройки
данного типа:

    s.〈i〉 ::= … | s.〈…〉1〈…〉 | …
    e.〈i〉 ::= … | e.〈…〉1〈…〉 | …






[R5L]: https://github.com/bmstu-iu9/refal-5-lambda
[R05]: https://github.com/Mazdaywik/Refal-05
[R5FW]: https://github.com/Mazdaywik/refal-5-framework
[MR]: https://github.com/Mazdaywik/MRefal
[R5L-A]: https://bmstu-iu9.github.io/refal-5-lambda/A-formats-and-types
[RTV]: https://github.com/bmstu-iu9/refal-type-verifier
[Omer2009]: https://www.cs.ucsb.edu/sites/default/files/docs/reports/2009-06.pdf
