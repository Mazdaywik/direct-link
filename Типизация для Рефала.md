Типизация для Рефала-5(λ)
=========================

_Александр Коновалов, июль 2020_

<script src="toc.js"></script>
<script>
makeTOC.localizedHeader = "Содержание"
makeTOC.localizedShow = "Показать";
makeTOC.localizedHide = "Скрыть";
</script>

Синтаксис
---------

**Типы объектных выражений** предлагается описывать при помощи грамматик,
нетерминалами которых выступают переменные (имена типов), в алфавит терминалов
входят символы Рефала и структурные скобки. (Расширение на квадратные скобки
тривиально, поэтому для простоты изложения его рассматривать не будем.)

Правила грамматики имеют вид

    〈имя-типа〉 ::= 〈типовое-выражение〉

где `〈имя-типа〉` — перемеменная (типа s-, t- или e-), а `〈типовое-выражение〉` —
выражение РБНФ, построенное из символов Рефала, переменных, круглых скобок,
фигурных скобок `{`, `}`, знака `|` и знаков `*`, `+`, `?`.

* Символы в правой части описывают символы, переменные — вхождения
  соответствующих нетерминалов, структурные скобки — структурные скобки.
* Наивысший приоритет имеют квантификаторы — знаки `*`, `+`, `?`, которые
  обозначают итерацию, позитивную итерацию и опцию. Знаки `+` и `?` являются
  синтаксическим сахаром, поэтому в теоретических выкладках использоваться,
  как правило, не будут.
* Следующей операцией по уровню приоритета является конкатенация, обозначаемая
  пробелов.
  Выражение `'ab'*` означает строки `'a'`, `'ab'`, `'abb'` и т.д.
* Наинизший приоритет имеет знак `|` означающий альтернативу.
* Знаки `{` и `}` используются для группировки и изменения приоритета.
* Скобки (структурные Рефала и группирующие фигурные) должны быть правильно
  сбалансированы.
* Пустое выражение мы будем обозначать при помощи знака `ε`.

Типы, описанные при помощи e-, t- и s-переменных, мы будем называть,
соответственно, **e-типами,** **t-типами** и **s-типами.**

Правая часть в правиле должна описывать _синтаксическое_ подмножество значений
типа слева.

* У e-типов справа может быть записано произвольное выражение.
* Правило для t-типов может иметь вид:
  ```
  t.Name ::= 〈терм〉 | 〈терм〉 …
  ```
  где `〈терм〉` — символ, произвольное выражение в скобках, s- или t-тип.
  Иначе говоря, на верхнем уровне выражения запрещены квантификаторы,
  конкатенация, e-типы и фигурные скобки, также выражение справа не может
  быть пустым. Таким образом обеспечивается, что значение t-типа может быть
  только одним объектным термом.
* Аналогично для s-типов в правой части правила может быть только набор
  альтернатив, включающий только символы и другие s-типы.

Можно было ввести требование _семантического_ значений для переменных типа,
например, следующие типы были бы допустимыми:

    e.OneTerm ::= (A*)
    e.Empty ::= ε
    t.OneTerm ::= e.OneTerm | e.Empty X e.Empty

Но работать с такими типами было бы гораздо сложнее.

**Тип функции** записывается следующим образом:

    <〈имя-функции〉 〈типовое-выражение〉> == 〈типовое-выражение〉

Знак `==` символизирует, что функция может вычислять свой результат за несколько
шагов рефал-машины. Типовое выражение внутри угловых скобок описывает тип
аргумента, типовое выражение справа от `==` — тип результата (возвращаемого
значения).

Если тип результата записан как альтернатива, то будем использовать следующий
синтаксический сахар:

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉
      == 〈тип-результата-2〉
         …
      == 〈тип-результата-N〉

что является альтернативной записью для

    <〈имя-функции〉 〈тип-аргумента〉>
      == 〈тип-результата-1〉 | … | 〈тип-результата-N〉

Нотация также подразумевает использование нескольких предопределённых
типов: `s.CHAR`, `s.WORD`, `s.NUMBER` означают соответствующие категории
символов Рефала-5 — множество литер, множество слов (составных символов,
идентификаторов) и множество чисел (макроцифр). В Рефале-5λ к ним можно
добавить `s.FUNCTION` — указатель на функцию или замыкание. Но здесь типы
высшего порядка мы рассматривать не будем, ограничимся только первым порядком.

Также удобно ввести обозначения `s.ANY`, `t.ANY` и `e.ANY` — любой символ,
любой терм и любое выражение. Можно считать, что они определены как

    s.ANY ::= s.CHAR | s.WORD | s.NUMBER
    t.ANY ::= s.ANY | (e.ANY)
    e.ANY ::= t.ANY*

Типы `s.ANY`, `t.ANY` и `e.ANY` далее мы будем называть **универсумом.**


Язык типов как неформальная нотация
-----------------------------------
Описанный выше язык типов автор этих строк уже давно использует как
полуформальную нотацию при программировании на Рефале. В частности, эта
нотация используется для описания типов в [Рефале-5λ][R5L], в [Рефал-05][R05],
[в наборе библиотек][R5FW] для Рефала-5 и Рефала-05, в [Модульном Рефале][MR].
В документации к Рефалу-5λ есть даже [приложение][R5L-A], посвящённое
использованию этой нотации в комментариях.

Да. Эта нотация пока используется только в комментариях и служит для
документирования типов функций. Корректность типов, описанных в этой нотации,
автоматически не проверяется — программист сам должен следить за тем, чтобы
комментарии соответствовали действительности.

Притягательной является идея по автоматической верификации типов программ
на Рефале — имея некоторую программу на Рефале и описания типов функций для
неё, проверить, что функции действительно могут принимать значения указанных
типов и что они возвращают значения, входящие в тип результата, типы фактических
аргументов в вызовах функций входят в их формальные типы.

Такая попытка уже [однажды делалась][RTV], но потерпела неудачу. И система
типов, и используемый алгоритм верификации были не до конца продуманы.

В данной работе делается попытка описать теоретические основы для работы
с описанными типами.


Регулярное ограничение на типы
------------------------------


[R5L]: https://github.com/bmstu-iu9/refal-5-lambda
[R05]: https://github.com/Mazdaywik/Refal-05
[R5FW]: https://github.com/Mazdaywik/refal-5-framework
[MR]: https://github.com/Mazdaywik/MRefal
[R5L-A]: https://bmstu-iu9.github.io/refal-5-lambda/A-formats-and-types
[RTV]: https://github.com/bmstu-iu9/refal-type-verifier
